Revision: 06cd7929904d3bc8759a3cea8240db957e32ff28
Patch-set: 2
File: runtime/gc/collector/concurrent_copying-inl.h

33:0-38:60
Tue Aug 23 22:48:18 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 88357b64_97a5d6f8
Bytes: 233
Careful about the subtle race condition that this comment describes.

As I understand, we don't have this "false gray" issue here because we now allow the same object to be pushed more than once?

I'd like the comment updated anyhow.

50:19-50:46
Tue Aug 23 22:48:18 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 88357b64_f76782ba
Bytes: 152
Now we changed such that an unevac-from-space object is marked if it's marked in the mark bitmap or its gray bit is set, correct? Can you add a comment?

52:4-52:11
Tue Aug 23 22:48:18 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 88357b64_57c66e46
Bytes: 150
If kUseBakerReadBarrier is false, we should negate the result of AtomicTestAndSet and change this line to "success = !bitmap->AtomicTestAndSet(ref);"?

File: runtime/gc/collector/concurrent_copying.cc

1308:56-1308:59
Tue Aug 23 23:17:06 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 88357b64_4c3ee0ba
Bytes: 70
After the offline discussion with Hans, this should be a StoreRelaxed.

1582:17-1582:38
Tue Aug 23 23:17:06 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 88357b64_ec69f4c6
Bytes: 34
and this should be a load acquire.

1583:12-1583:43
Tue Aug 23 22:48:18 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 88357b64_29eb4e0a
Bytes: 177
Probably related to the TODO comment above, the bitmap is written by GC only without a CAS or a release.

Is this correct? The feasibility of this change seems to hinge on this.

1631:17-1631:38
Tue Aug 23 23:17:06 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 88357b64_8c4f086d
Bytes: 34
and this should be a load acquire.

1632:12-1632:43
Tue Aug 23 22:48:18 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 88357b64_c9df4264
Bytes: 5
Same.

1672:8-1672:38
Tue Aug 23 22:48:18 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 88357b64_d7ca7e76
Bytes: 141
This should be "GetReadBarrierPointer() == ReadBarrier::GrayPtr() || region_space_bitmap_->Test(obj)" aside from the correctness issue above?

1672:8-1672:38
Tue Aug 23 23:17:06 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 88357b64_d7ca7e76
UUID: 88357b64_8c762899
Bytes: 51
The GetReadBarrierPointer should be a load acquire.

2144:4-2144:47
Tue Aug 23 22:48:18 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 88357b64_c912e25c
Bytes: 5
Same.

2144:4-2144:47
Tue Aug 23 23:17:06 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 88357b64_c912e25c
UUID: 88357b64_2cb27c4a
Bytes: 192
The GetReadBarrierPointer() may as well be a load acquire though this may be safe without an acquire because a mutator calling this and not seeing a mark may be harmless for the GetReferent().

File: runtime/gc/collector/concurrent_copying.h

107:47-107:63
Tue Aug 23 22:48:18 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 88357b64_09cbea56
Bytes: 223
You mean this more as "kMaybeFromMutator" (a negated one would be "kFromGC")? Or at least that makes more sense to me.

Can you add an assert:

if (!kMaybeFromMutator) {
  DCHECK_EQ(Thread::Current(), thread_running_gc_);
}

