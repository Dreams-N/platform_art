Revision: d4b4457b987f8fd9af06a99439432f2cafbb18d1
Patch-set: 1
File: compiler/optimizing/code_generator_x86.cc

6052:0-6067:13
Mon Feb 29 19:04:39 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e27a7932_8d43788a
Bytes: 31
Do these support read barriers?

6052:0-6067:13
Mon Feb 29 23:43:46 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e27a7932_8d43788a
UUID: 82affd8e_2c6bab83
Bytes: 81
Does it need to? The strings are in the boot image, so never collected nor moved.

6052:0-6067:13
Tue Mar 01 21:46:59 2016 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 82affd8e_2c6bab83
UUID: 22ef3134_5fa0e66a
Bytes: 1118
I think so. If we don't have a read barrier there, the string could be a from-space (white) object and the to-space invariant (mutators see only gray or black objects and we may miss correctly marking objects without it) would break and the checks would fail. Once it's broken, anything transitively reachable/loaded through it like the string class, etc... would have the same issue because loading from a white object won't trigger the read barrier. This is still the case even if an object is in the image or non-moving as non-moving objects can (transitively) point to moving objects. This is sort of a principle with a Baker-style read barrier.

That doesn't necessarily mean there aren't specific cases where we could remove read barriers. But that would likely need to be done with care and proper checks and assertions, I would think. Currently, I am not sure if it's safe.

Is it hard to have read barriers implemented there? If we choose not implementing read barriers there, I'd ask that we disable these string load optimizations for the read barrier build for now and consider enabling them in the future.

6052:0-6067:13
Tue Mar 01 22:33:02 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 22ef3134_5fa0e66a
UUID: 62eda937_22c190a2
Bytes: 94
OK, good catch. Then yeah, I agree the safest would be to disable those optimizations for now.

6052:0-6067:13
Wed Mar 02 17:25:58 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 62eda937_22c190a2
UUID: c209f5de_5d48ef2a
Bytes: 145
Agreed; we should disable the optimization when `kEmitCompilerReadBarrier` is true.

I can implement those read barriers later in a follow-up CL.

File: compiler/optimizing/nodes.h

5489:32-5489:49
Sat Feb 27 14:25:09 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 22c49160_3e2aed15
Bytes: 7
String.

File: compiler/optimizing/sharpening.cc

173:9-173:50
Sat Feb 27 14:25:09 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 02c30d5c_c8f69f40
Bytes: 13
IsSameDexFile

180:0-181:31
Sat Feb 27 14:25:09 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 22c49160_5e1fa9f2
Bytes: 7
unused?

259:0-267:1
Sat Feb 27 14:25:09 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a2b881d5_621f6cf3
Bytes: 82
Seems like a useful method worth moving to the Heap class (if not already there?)?

