Revision: e2aa3265594486b4b977453752645cdce3026e82
Patch-set: 2
File: runtime/base/stringpiece.h

152
Thu Oct 22 17:48:53 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 19337ad8_c4cb52db
Bytes: 139
Why not just 

   return strncmp(data(), rhs.data(), std::min(size(), rhs.size())

(which is very similar to what operator== already does).

152
Thu Oct 22 18:06:52 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 19337ad8_c4cb52db
UUID: 3942fe30_9f18c318
Bytes: 62
strncmp has to check for null characters, its probably slower.

152
Thu Oct 22 18:10:46 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 19337ad8_c4cb52db
UUID: 79739694_f8180dbe
Bytes: 91
That looks like ignoring the tail and stopping on embedded zeros (we want "x\0y" < "x\0z").

152
Thu Oct 22 19:50:03 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 79739694_f8180dbe
UUID: 16d269e7_92b79cbd
Bytes: 476
I'm glad you brought this up. I think this needs to be fixed.

Right now operator== uses strncmp so it will treat "x\0y" == "x\0z"

Let's make both of them consistent, why don't we?

----
I would weakly vote for using the operator== behavior because a) it's what we were already doing and what the rest of the code relies on, b) it's a string which means 0-terminated in C++ land, c) we would want to call it a vectorpiece or similar if it was just arbitrary byte array slice.

File: runtime/mirror/class.cc

580
Thu Oct 22 17:48:53 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 3942fe30_df2c0b69
Bytes: 158
This can overflow, please fix

   size_t mid = low + ((high - low) / 2);

http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html

580
Thu Oct 22 18:06:52 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 3942fe30_df2c0b69
UUID: 369ccd29_9bd6eb24
Bytes: 140
It actually cant, consider that sizeof(ArtField) > 4 bytes. Therefore on 4GB ram, you can have at most 1B of them which wont cause overflow.

580
Thu Oct 22 18:10:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 369ccd29_9bd6eb24
UUID: 369ccd29_5b1b83ba
Bytes: 131
Well if that's the case then maybe it wouldn't hurt to add a DCHECK?

That being said why not just write more secure code up front?

580
Thu Oct 22 18:22:20 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 369ccd29_5b1b83ba
UUID: 16d269e7_12aaccaa
Bytes: 4
Done

