Revision: e2aa3265594486b4b977453752645cdce3026e82
Patch-set: 2
File: runtime/base/stringpiece.h

152
Thu Oct 22 17:48:53 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 19337ad8_c4cb52db
Bytes: 139
Why not just 

   return strncmp(data(), rhs.data(), std::min(size(), rhs.size())

(which is very similar to what operator== already does).

152
Thu Oct 22 18:06:52 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 19337ad8_c4cb52db
UUID: 3942fe30_9f18c318
Bytes: 62
strncmp has to check for null characters, its probably slower.

152
Thu Oct 22 18:10:46 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 19337ad8_c4cb52db
UUID: 79739694_f8180dbe
Bytes: 91
That looks like ignoring the tail and stopping on embedded zeros (we want "x\0y" < "x\0z").

152
Thu Oct 22 19:50:03 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 79739694_f8180dbe
UUID: 16d269e7_92b79cbd
Bytes: 476
I'm glad you brought this up. I think this needs to be fixed.

Right now operator== uses strncmp so it will treat "x\0y" == "x\0z"

Let's make both of them consistent, why don't we?

----
I would weakly vote for using the operator== behavior because a) it's what we were already doing and what the rest of the code relies on, b) it's a string which means 0-terminated in C++ land, c) we would want to call it a vectorpiece or similar if it was just arbitrary byte array slice.

152
Thu Oct 22 19:58:01 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 16d269e7_92b79cbd
UUID: 16e8a964_459f3ca5
Bytes: 263
I would vote for implementing the operator==(const StringPiece&, const char*) by forwarding to operator==(const StringPiece&, const StringPiece&). Or, given the conversion constructor StringPiece(const char*), I would just delete the operators taking const char*.

File: runtime/mirror/class.cc

568
Thu Oct 22 21:20:34 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 16d269e7_d22be41a
Bytes: 175
By the way, what was wrong with using std::lower_bound here and then comparing the elements were equal?

(std::binary_search wasn't going to work anyway since it returns bool)

568
Thu Oct 22 21:24:36 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 16d269e7_d22be41a
UUID: 56a1415d_df89bf28
Bytes: 104
std::lower_bound would work but that does extra comparisons since it does not use an integer comparator.

568
Thu Oct 22 21:31:37 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 56a1415d_df89bf28
UUID: 3675adb9_564b5224
Bytes: 163
If it uses a custom comparator function , it can do the same logic as line 584-586, the only problem is needing to do the check again (only once) at the end, IIUC?

568
Thu Oct 22 21:33:51 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 3675adb9_564b5224
UUID: b6699de6_faaa8556
Bytes: 96
Actuall you're right, I thought the implementation had two comparisons for some loop iterations.

580
Thu Oct 22 17:48:53 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 3942fe30_df2c0b69
Bytes: 158
This can overflow, please fix

   size_t mid = low + ((high - low) / 2);

http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html

580
Thu Oct 22 18:06:52 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 3942fe30_df2c0b69
UUID: 369ccd29_9bd6eb24
Bytes: 140
It actually cant, consider that sizeof(ArtField) > 4 bytes. Therefore on 4GB ram, you can have at most 1B of them which wont cause overflow.

580
Thu Oct 22 18:10:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 369ccd29_9bd6eb24
UUID: 369ccd29_5b1b83ba
Bytes: 131
Well if that's the case then maybe it wouldn't hurt to add a DCHECK?

That being said why not just write more secure code up front?

580
Thu Oct 22 18:22:20 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 369ccd29_5b1b83ba
UUID: 16d269e7_12aaccaa
Bytes: 4
Done

