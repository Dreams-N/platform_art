Revision: e2aa3265594486b4b977453752645cdce3026e82
Patch-set: 2
File: runtime/base/stringpiece.h

152
Thu Oct 22 17:48:53 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 19337ad8_c4cb52db
Bytes: 139
Why not just 

   return strncmp(data(), rhs.data(), std::min(size(), rhs.size())

(which is very similar to what operator== already does).

152
Thu Oct 22 18:06:52 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 19337ad8_c4cb52db
UUID: 3942fe30_9f18c318
Bytes: 62
strncmp has to check for null characters, its probably slower.

152
Thu Oct 22 18:10:46 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 19337ad8_c4cb52db
UUID: 79739694_f8180dbe
Bytes: 91
That looks like ignoring the tail and stopping on embedded zeros (we want "x\0y" < "x\0z").

File: runtime/mirror/class.cc

580
Thu Oct 22 17:48:53 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 3942fe30_df2c0b69
Bytes: 158
This can overflow, please fix

   size_t mid = low + ((high - low) / 2);

http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html

580
Thu Oct 22 18:06:52 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 3942fe30_df2c0b69
UUID: 369ccd29_9bd6eb24
Bytes: 140
It actually cant, consider that sizeof(ArtField) > 4 bytes. Therefore on 4GB ram, you can have at most 1B of them which wont cause overflow.

580
Thu Oct 22 18:10:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 369ccd29_9bd6eb24
UUID: 369ccd29_5b1b83ba
Bytes: 131
Well if that's the case then maybe it wouldn't hurt to add a DCHECK?

That being said why not just write more secure code up front?

