Revision: 502a4aee63c62042c46b546861813cd3668b5a5b
Patch-set: 3
File: compiler/optimizing/induction_var_analysis.cc

156:27-156:35
Fri Jul 31 21:08:37 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ca2490af_766a010b
Bytes: 2
0?

156:27-156:35
Fri Jul 31 21:25:56 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ca2490af_766a010b
UUID: 4a6260ef_35547bd1
Bytes: 4
Done

160
Fri Jul 31 21:08:37 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ea295486_e2a74e05
Bytes: 145
Is phi guaranteed to be true for IsLoopHeaderPhi? If yes, a DCHECK here would be nice to tie the SSA-based cycle detection back to CFG-based one.

160
Fri Jul 31 21:25:56 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ea295486_e2a74e05
UUID: 8a2e188f_7a6665a1
Bytes: 37
defensive start of the classification

166
Fri Jul 31 21:08:37 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ea295486_82976aa1
Bytes: 166
The loop phi's input0 is always loop invariant so it's not necessary to try the two orders, if it's guaranteed to be a loop header phi as said in my previous comment.

166
Fri Jul 31 21:25:56 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ea295486_82976aa1
UUID: ca4d7087_9a2d9995
Bytes: 217
yeah, I suspected that, but was not sure if I really could rely on such properties (I like to have defensive code in such case); but if first is always external and second internal, I can remove the second call indeed

246
Fri Jul 31 21:08:37 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ea523422_a0e5c615
Bytes: 95
So even though SCC (a graph) is detected, we only handle a single-cycle case now for iv, right?

246
Fri Jul 31 21:25:56 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ea523422_a0e5c615
UUID: 0a5ce834_565b7a5b
Bytes: 153
there will be more classifications later, some of which are more general; I just did not want this code to grow above what can be reviewed first time :-)

297:10-297:17
Fri Jul 31 17:43:17 2015 +0000
Author: Razvan A Lupusoru <1013855@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ca2490af_a23dc446
Bytes: 53
Why is this classified as linear for multiplications?

297:10-297:17
Fri Jul 31 18:16:58 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ca2490af_a23dc446
UUID: 8a2e188f_dfb8abc0
Bytes: 424
This is the transfer over * (so think derived, not basic).
So if we have x * y
  where x is classified linear as a_ * i + b_
  and y is classified as invariant, just itself,
we get a new linear expression
   (a_ * y) * i + (b_ * y)

Perhaps naming the parameters x and y instead of a and b would be a bit more clear to see the difference between top and sub expressions better (as I realized writing down the explanation :-)

File: compiler/optimizing/induction_var_analysis.h

62
Fri Jul 31 21:08:37 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0a5ce834_fbb137cd
Bytes: 51
I think we don't use xxx_ naming for public fields.

