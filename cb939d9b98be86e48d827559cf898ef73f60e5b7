Revision: cb939d9b98be86e48d827559cf898ef73f60e5b7
Patch-set: 1
File: /COMMIT_MSG

7
Mon Jan 12 20:39:18 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: cee48d53_2ada037b
Bytes: 62
Link to docs or some high level explanation of how this works?

7
Tue Jan 13 22:14:22 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cee48d53_2ada037b
UUID: 0efa25f3_a762c5f4
Bytes: 18
Let's have a chat.

File: runtime/gc/accounting/read_barrier_table.h

69:4-72:5
Tue Jan 13 01:58:16 2015 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0efa25f3_3068ae8f
Bytes: 224
Is there any reason to believe this is faster than the obvious memset call?  I would guess it's typically slower, especially on 64-bit hardware.  Memset already has this optimization, plus more specific architectural tweaks.

69:4-72:5
Thu Jan 15 02:30:57 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0efa25f3_3068ae8f
UUID: 6e26419e_0fa02d77
Bytes: 17
Good point. Done.

90:2-90:58
Tue Jan 13 01:58:16 2015 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2eab69f1_fb21fb8e
Bytes: 7
remove?

90:2-90:58
Thu Jan 15 02:30:57 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2eab69f1_fb21fb8e
UUID: 6e26419e_4f9a254b
Bytes: 4
Done

File: runtime/gc/collector/concurrent_copying.cc

110
Mon Jan 12 20:39:18 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2eab69f1_12b02cfc
Bytes: 96
So what this is doing is adding mark bitmaps for the image / zygote correct? Why is this needed?

110
Tue Jan 13 22:14:22 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2eab69f1_12b02cfc
UUID: 0efa25f3_67c71d55
Bytes: 859
Yes, correct.

With the Baker read barrier, we decide whether the read barrier slow path should be taken based on whether the read barrier pointer is gray or not. If we treat image/zygote objects as always marked without using a bitmap (as in the mark sweep collector case), then we'd have to make sure that all those objects are somehow colored as gray at the beginning of the marking phase or else the to-space invariant would break (a mutator may see an unmarked/from-space ref). Maybe we could concurrently color them gray before the marking phase begins (in addition, we'd have to have a check if the GC is marking or not in the read barrier slow path and we'd have to mark through them specially.) This may work. But it'd add one extra phase. I'd have to try and see, but I see it as an optimization (not a correctness issue). I'll leave a TODO for now.

322
Mon Jan 12 20:39:18 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8eee1533_a5e48ab7
Bytes: 8
CHECK_EQ

322
Thu Jan 15 02:30:57 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8eee1533_a5e48ab7
UUID: 2e20c981_243992c2
Bytes: 4
Done

362
Mon Jan 12 20:39:18 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8eee1533_05da96f5
Bytes: 18
Procces -> Process

362
Thu Jan 15 02:30:57 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8eee1533_05da96f5
UUID: 0e1dc54d_03b3ae0b
Bytes: 4
Done

812
Mon Jan 12 20:39:18 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2eab69f1_f2e92010
Bytes: 8
CHECK_EQ

812
Thu Jan 15 02:30:57 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2eab69f1_f2e92010
UUID: 2e20c981_64ce2a70
Bytes: 4
Done

814
Mon Jan 12 20:39:18 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4ef09d0f_06d3c069
Bytes: 8
CHECK_EQ

814
Thu Jan 15 02:30:57 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4ef09d0f_06d3c069
UUID: 6e26419e_0c8afbad
Bytes: 4
Done

818
Mon Jan 12 20:39:18 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2eab69f1_d2eea415
Bytes: 36
ConcurrentCopying* const collector_;

818
Thu Jan 15 02:30:57 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2eab69f1_d2eea415
UUID: 6e26419e_4c84f39d
Bytes: 4
Done

File: runtime/gc/collector/concurrent_copying.h

50
Mon Jan 12 20:39:18 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2eab69f1_0cdad77a
Bytes: 307
This seems general purpose, move to its own file? Also since this is a queue, does that result in worst object locality than a stack? I was under the impression that a mark stack was advantageous since it resulted in better object locality of moved objects and better cache coherence during marking process.

50
Tue Jan 13 22:14:22 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2eab69f1_0cdad77a
UUID: 4e75fd75_1e42118d
Bytes: 449
I don't see any problem with moving it its own file. But I think we can defer it to a later point depending on how general purpose it turns out.

You are probably right about the locality characteristics about a stack vs a queue. I tried, but atomic_stack.h didn't work for some reason. It may be that in push_back() it'd have to busy-wait for a slot to be filled with a valid pointer/ref after a slot is secured and in pop_back() null out the slot.

61
Mon Jan 12 20:39:18 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4ef09d0f_c09540cf
Bytes: 57
Using unique_ptr shouldn't be additional overhead I think

61
Thu Jan 15 02:30:57 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4ef09d0f_c09540cf
UUID: 2e20c981_64eb8a83
Bytes: 4
Done

76
Mon Jan 12 20:39:18 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2eab69f1_cc40cf67
Bytes: 166
Even though you CHECK that IsPowerOfTwo, I don't think the compiler is smart enough to turn this % into an &. I'd recommend doing buf_[t & (size_ - 1)] manually here.

76
Thu Jan 15 02:30:57 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2eab69f1_cc40cf67
UUID: 2e20c981_44520eaa
Bytes: 17
Good point. Done.

88
Mon Jan 12 20:39:18 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2eab69f1_2c36b302
Bytes: 8
And here

88
Thu Jan 15 02:30:57 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2eab69f1_2c36b302
UUID: 2e20c981_a4b3c28c
Bytes: 4
Done

101
Mon Jan 12 20:39:18 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4ef09d0f_e094bcd0
Bytes: 8
And here

101
Thu Jan 15 02:30:57 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4ef09d0f_e094bcd0
UUID: 0e1dc54d_e3f8528a
Bytes: 4
Done

146
Mon Jan 12 20:39:18 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0efa25f3_21298af4
Bytes: 52
Comment meant to say couldn't be constexpr pointers?

146
Thu Jan 15 02:30:57 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0efa25f3_21298af4
UUID: 6e26419e_0fdd8d72
Bytes: 23
Yes. Fixed the comment.

200:18-200:19
Mon Jan 12 21:37:24 2015 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0efa25f3_caf0bb3c
Bytes: 18
const .. and below

200:18-200:19
Thu Jan 15 02:30:57 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0efa25f3_caf0bb3c
UUID: 2e20c981_a49ae2fc
Bytes: 4
Done

297
Mon Jan 12 21:37:24 2015 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2eab69f1_b5766274
Bytes: 28
DEFAULT_MUTEX_ACQUIRED_AFTER

297
Thu Jan 15 02:30:57 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2eab69f1_b5766274
UUID: 0e1dc54d_e385b2e5
Bytes: 4
Done

File: runtime/gc/space/region_space.h

253:17-253:18
Mon Jan 12 21:37:24 2015 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2eab69f1_d5b32eda
Bytes: 18
const .. and below

253:17-253:18
Thu Jan 15 02:30:57 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2eab69f1_d5b32eda
UUID: 0e1dc54d_83315e90
Bytes: 4
Done

File: runtime/mirror/art_method-inl.h

482
Mon Jan 12 20:39:18 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2eab69f1_b20038f9
Bytes: 118
DCHECK_EQ will print the values already if they don't match, its redundant to print them yourself by using the stream.

482
Thu Jan 15 02:30:57 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2eab69f1_b20038f9
UUID: 0e1dc54d_2368aa8f
Bytes: 4
Done

File: runtime/read_barrier-inl.h

40
Mon Jan 12 20:39:18 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0efa25f3_6a2d27ad
Bytes: 116
Is there a way to abstract this so that we can have read barriers in other GCs such as concurrent semi-space, etc...

40
Tue Jan 13 22:14:22 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0efa25f3_6a2d27ad
UUID: ae53d9fb_b952035c
Bytes: 480
I think it actually depends on the read barrier type as opposed to the collector type even though HasGrayReadBarrierPointer() is currently defined in the ConcurrentCopying class, which should be separated out more cleanly.

If we have multiple read barrier types, we probably need to treat them more like the different allocator types that we have (some cases may be specialized via templates). Particularly, if we'd like it to be a runtime option rather than a build time option.

File: runtime/runtime.h

302:9-302:21
Mon Jan 12 21:37:24 2015 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4ef09d0f_66872472
Bytes: 44
FlipThreadRoots as more intention revealing?

302:9-302:21
Thu Jan 15 02:30:57 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4ef09d0f_66872472
UUID: 2e20c981_e44cdac3
Bytes: 4
Done

File: runtime/thread.h

860
Mon Jan 12 20:39:18 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2eab69f1_8fc7d9d6
Bytes: 41
I think you can make this function const.

860
Thu Jan 15 02:30:57 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2eab69f1_8fc7d9d6
UUID: 0e1dc54d_0352ceda
Bytes: 4
Done

File: runtime/thread_list.h

102
Mon Jan 12 20:39:18 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0efa25f3_24b078fc
Bytes: 88
I'm confused why we can't do the root flipping by using normal checkpoints? Any comment?

102
Tue Jan 13 22:14:22 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0efa25f3_24b078fc
UUID: 4e3a5daa_500f32a3
Bytes: 386
With a checkpoint, there could be missed writes. Since not all threads flip at the exact same time, some threads could concurrently see two (from-space and to-space) copies of the same object. If a thread which hasn't flipped yet writes to the from-space copy of an object and another thread which has already flipped reads the to-space copy of the same object, the write would be lost.

