Revision: d7eab1d539c78600293f85f1fcc0704a390b3380
Patch-set: 2
File: compiler/elf_writer_quick.cc

834:2-836:87
Fri Jul 25 16:44:23 2014 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d91ff043_99e8e7cc
Bytes: 52
Any particular reason for moving this onto the heap?

834:2-836:87
Mon Jul 28 07:07:53 2014 +0000
Author: Yevgeny Y Rouban <1037563@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d91ff043_99e8e7cc
UUID: 7937e4c3_526aca26
Bytes: 107
The reason is the local frame limitation in the art/build/Android.common_build.mk: -Wframe-larger-than=1728

849:0-854:3
Fri Jul 25 16:44:23 2014 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b91cfc52_32d1ce8f
Bytes: 94
Why the fore loop. Is only some of the dbg_info's having line information possible/meaningful?

849:0-854:3
Mon Jul 28 07:07:53 2014 +0000
Author: Yevgeny Y Rouban <1037563@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b91cfc52_32d1ce8f
UUID: b9431c33_d41152eb
Bytes: 44
this loop is check if there is any line info

856
Fri Jul 25 16:44:23 2014 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d91ff043_79e40bef
Bytes: 124
This seems like it could be wrong.

Can we have one without the other?

Do we actually handle having only one intelligently?

856
Mon Jul 28 07:07:53 2014 +0000
Author: Yevgeny Y Rouban <1037563@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d91ff043_79e40bef
UUID: 9932d8d1_7e36b9d2
Bytes: 174
We generate .debug_abbrev, .debug_info and .debug_str if we got lineInfo or CFI.
We generate .debug_frame only if we got CFI.
We generate .debug_line only if we got lineInfo.

1048:0-1050:1
Fri Jul 25 16:44:23 2014 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 96e70794_b103ea9b
Bytes: 30
strcmp already does this IIRC.

1048:0-1050:1
Mon Jul 28 07:07:53 2014 +0000
Author: Yevgeny Y Rouban <1037563@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 96e70794_b103ea9b
UUID: 9932d8d1_9e41ad24
Bytes: 100
which strcmp do you mean?
I have just verified the standard strcmp from libc. It crashes with NULLs.

1048:0-1050:1
Mon Jul 28 16:16:57 2014 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 9932d8d1_9e41ad24
UUID: d91ff043_b9067981
Bytes: 133
NVM you're right. Still is null being passed in here an acceptable input?

This is just a nit-pick though. Feel free to disregard it.

1090:2-1102:4
Fri Jul 25 16:44:23 2014 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 96e70794_b1608a5c
Bytes: 52
A lambda or static function would probably be nicer.

1090:2-1102:4
Mon Jul 28 07:07:53 2014 +0000
Author: Yevgeny Y Rouban <1037563@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 96e70794_b1608a5c
UUID: b9431c33_f4164ee0
Bytes: 4
Done

1230:0-1231:61
Fri Jul 25 16:44:23 2014 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b91cfc52_1d15c35b
Bytes: 45
I am fairly certain this is wrong, see below.

1282
Fri Jul 25 16:44:23 2014 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b91cfc52_f242d672
Bytes: 45
I am fairly certain this is wrong. See below.

1295
Fri Jul 25 16:44:23 2014 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 96e70794_b181aa75
Bytes: 45
I am fairly certain this is wrong, see below.

1312:0-1313:63
Fri Jul 25 16:44:23 2014 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b91cfc52_f26bb6f2
Bytes: 305
I think this will break current gdb behavior since IIRC the low_pc_/high_pc_ are offsets from the start of the text section already. We save them as that since we don't know what the actual addresses of these things will be until later when we have already loaded the oat file.

See ElfFile::GdbJITSupport

1312:0-1313:63
Mon Jul 28 09:36:36 2014 +0000
Author: Yevgeny Y Rouban <1037563@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b91cfc52_f26bb6f2
UUID: 7937e4c3_12a3f223
Bytes: 559
I used 'dwarfdump -ka' to check the generated OAT file and found it needs VMA address (i.e. base + offset) in the .debug_line at least. That is why, to get the base address for .debug_* generation I had to split ElfBuilder::Write into ElfBuilder::Init and ElfBuilder::Write. Could you please describe the patching workflow and why/when it is needed? Why can not we use the standard Elf relocation? Why we have to patch boot.oat once it is generated?
I believe that in GdbJITSupport we have to *offset* the debugging info rather than *set* a new .text address.

1312:0-1313:63
Mon Jul 28 16:16:57 2014 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7937e4c3_12a3f223
UUID: 36f65b4a_28576ae7
Bytes: 717
No the problem isn't that it's that at this point we still do not have any idea the actual address this code will be loaded at. If we are compiling boot.oat we need to first figure out the size of the image (which happens next) and if we are compiling an application we need to wait until runtime.

Therefore we just keep the PC as relative to the start of the .text section and then when loading the oat file fix up these by adding the actual text section address to them. The code for this is in runtime/elf_file.cc:1285 (FixupDebugInfo). If you really want the final word though I'd suggest you ask your colleague Mark Mendel (mark.p.mendell@intel.com) since he was the one who initially wrote in this gdb support.

1312:0-1313:63
Mon Jul 28 17:50:19 2014 +0000
Author: Yevgeny Y Rouban <1037563@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 36f65b4a_28576ae7
UUID: 9932d8d1_9911c7be
Bytes: 214
I would suggest to keep these values valid virtual adresses and fix FixDebugInfo accordingly. This way other Elf and Dwarf tools will be able to read the data. 
Can you share any reference to the oat patching docs?

