Revision: f29931edd7e24866c9d266fd53f293ec7ef38cc2
Patch-set: 1
File: compiler/optimizing/intrinsics_arm64.cc

624:0-624:41
Wed Jun 29 11:25:16 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e0152784_c592da11
Bytes: 22
Fits on a single line.

625:39-625:40
Wed Jun 29 11:25:16 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e0152784_e59556fc
Bytes: 12
Extra space.

632:11-632:12
Wed Jun 29 11:25:16 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e0152784_a506be4d
Bytes: 12
Extra space.

637:5-637:28
Tue Jun 28 22:55:13 2016 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 80bb8b9f_9f1c87bf
Bytes: 35
Hopefully generates zero for a NaN?

637:5-637:28
Wed Jun 29 09:34:02 2016 +0000
Author: Xueliang Zhong <1096678@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 80bb8b9f_9f1c87bf
UUID: e0152784_0514f29a
Bytes: 609
Yes, FCVTAS generates zero for NaN inputs.

This FCVTAS is the one we found in ARM64 ISA which is closest to Java 8's Math.round() definition.
The only difference is that it has different rounding direction for negative 'half' values. That's why we need a few instructions below to check and handle these negative 'half' values.

We actually have art/test/082-inline-execute/Main.java test to test Math.round implementation. The test cases cover inputs like NaN, +/-0.0, 0.4999999701976776123046875, +/-infinity, floating-point values which are bigger or smaller than Integer.MAX_VALUE/Integer.MIN_VALUE, etc.

