Revision: 04dd2a9bccc733ed47801ab0a3129131fdb3f293
Patch-set: 2
File: runtime/class_linker.cc

2676:6-2676:35
Wed Mar 16 15:59:07 2016 +0000
Author: David Srbecky <1065473@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b76525c6_a3e4a88c
Bytes: 364
I have removed the condition on JitAtFirstUse and replaced with IsNativeDebuggable.

This means JitAtFirstUse has its pure meaning again - instead for waiting for method to get hot in the interpreter, it will JIT it when it is used for first time, and it will wait for this compilation to complete.

JitAtFirstUse no longer affects decisions about AOT vs JIT code.

2682:4-2682:8
Wed Mar 16 17:30:46 2016 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b74a8540_5bc4af09
Bytes: 85
Remove the else and place the if statement on the next line to follow the style here.

2682:4-2682:8
Wed Mar 16 17:40:59 2016 +0000
Author: David Srbecky <1065473@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b74a8540_5bc4af09
UUID: 1cc1b619_4d94395f
Bytes: 4
Done

2685:4-2685:10
Wed Mar 16 15:59:07 2016 +0000
Author: David Srbecky <1065473@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b76525c6_c3e99c65
Bytes: 74
This is counter-part to the code in Debugger:GoActive. I missed it in PS1.

File: runtime/debugger.cc

629:75-629:93
Wed Mar 16 17:30:46 2016 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b76525c6_a35d88f4
Bytes: 390
In what circumstances an app is considered "native debuggable"? Is it limited to a specific config or is it true when running under Android Studio, ... ?

I'm asking the question because it impacts the debuggability of Java stack frames in the boot image. So if "native debuggable" is something that will be true quite often, we won't "deoptimize" boot image methods for the Java debugging.

629:75-629:93
Wed Mar 16 17:40:59 2016 +0000
Author: David Srbecky <1065473@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b76525c6_a35d88f4
UUID: 1cc1b619_0d9e317d
Bytes: 282
It is limited to specific config of Android Studio when we debug using LLDB instead of JDWP. The target audience is C++ developers who might have just a bit of java source code in the application. We will not use JDWP to set breakpoints, step or view local variables in this config.

629:75-629:93
Wed Mar 16 18:47:00 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1cc1b619_0d9e317d
UUID: 9cd5a6d1_b4f96e94
Bytes: 300
The question was how this is communicated to the runtime. If simply having Android Studio driving the debugging always switches to this (e.g., just because the project contains native code), then the Java debugging would suffer.

So he's asking how DEBUG_NATIVE_DEBUGGABLE is derived in the frontend.

629:75-629:93
Wed Mar 16 18:53:58 2016 +0000
Author: David Srbecky <1065473@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 9cd5a6d1_b4f96e94
UUID: 1cc1b619_edff2578
Bytes: 420
The debugger type of the run configuration has to be switched from Java to Native. (internally we have a lot of bike-shedding how these should be called)

If that is done, android studio will start the app with "adb shell am start" with additional -N flag.  This in turn will be transalted by the activity manager to the DEBUG_NATIVE_DEBUGGABLE flag.

We definitely do not want to do this for normal Java debugging flow.

629:75-629:93
Thu Mar 17 00:02:36 2016 +0000
Author: Vince Harron <1048574@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1cc1b619_edff2578
UUID: bc842acd_25d1b8cc
Bytes: 306
This is not a replacement for JDWP based Java debugging.  This is an enhancement to the C++ debugging experience.  An app developer who prioritizes a rich Java debugging experience should and will get JDWP.  A developer who prioritizes a rich C++ experience with some Java awareness will get this debugger.

