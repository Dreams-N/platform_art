Revision: ea1420f434b183c93b7115998cd8bbb41407eec3
Patch-set: 1
File: compiler/optimizing/bounds_check_elimination.cc

893
Fri Jul 15 16:33:38 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 6ae91769_02bfea16
Bytes: 14
Line too long.

893
Fri Jul 15 16:58:26 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6ae91769_02bfea16
UUID: 3ad1308d_6f4a629b
Bytes: 4
Done

1339
Fri Jul 15 16:33:38 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ba20c083_a4f4a226
Bytes: 1057
If you're rewriting the transformation, can I suggest a very different approach? For example, the "stencil" test is transformed to

  if (end >= start) {
    if (array == null) deopt;
    if (Above(start - 2, start + 2) deopt;
    if (Above(start + 2, end + 2) deopt;
    if (Above(end + 2, array.length) deopt;
  }
  for (int i = end; i >= start; i--) {
    <body without null/bound checks>;
  }

but I'd prefer

  if (end < start) goto skip_loop;
  if (array == null) deopt;
  // The max 'i' for accessing elements in range [i, i+5).
  int max_i = array.length - 5;
  if (max_i < 0) deopt;
  if (Above(end - 2, max_i) deopt;  // AIOOB in first iteration?
  int cutoff = max(start, 2);
  int i;
  for (i = end; i >= cutoff; --i) {
    <body without null/bound checks>;
  } while (i >= start);
  if (i >= start) deopt;
  skip_loop:

This approach is also applicable in cases where we previously didn't want to deoptimize, for example where an early exit from the loop can avoid AIOOB. And if we do throw AIOOB, this will speed up the execution to get there.

1339
Fri Jul 15 16:58:26 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ba20c083_a4f4a226
UUID: 3ad1308d_cff0ae6d
Bytes: 127
Ok, I will study this a bit (but for now I like to keep the CL as is, since this approach would require some more "soldering").

1424:0-1424:109
Fri Jul 15 09:25:09 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: caf9233e_bdb3bfe5
Bytes: 31
line too long (here and below).

1424:0-1424:109
Fri Jul 15 16:23:55 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: caf9233e_bdb3bfe5
UUID: 3ad1308d_7dfa1bae
Bytes: 29
So it is. Changed, below too.

File: test/449-checker-bce/src/Main.java

1390:7-1390:12
Fri Jul 15 09:25:09 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: caf9233e_fdb947c9
Bytes: 18
Add one line 1385?

1390:7-1390:12
Fri Jul 15 16:23:55 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: caf9233e_fdb947c9
UUID: 3ad1308d_9dc9cf8d
Bytes: 51
Ai, I messed up what I wanted to say here. Changed.

File: test/530-checker-loops3/src/Main.java

31:0-32:37
Fri Jul 15 09:25:09 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: caf9233e_ddb68bd7
Bytes: 77
Nit: maybe worth adding a comment for each Deoptimize what purpose it serves?

31:0-32:37
Fri Jul 15 16:23:55 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: caf9233e_ddb68bd7
UUID: 3ad1308d_5dd0f727
Bytes: 150
Ok, note that I already had some comments before the loop. Do you want me to make those more elaborate, or move those up to above the checks, or both?

31:0-32:37
Fri Jul 15 16:27:42 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 3ad1308d_5dd0f727
UUID: ba20c083_c44b5e49
Bytes: 74
Actually, I see you're commenting in the code body. so scratch my comment.

31:0-32:37
Fri Jul 15 16:49:15 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ba20c083_c44b5e49
UUID: 3ad1308d_ef5db263
Bytes: 184
Ok. I added more checks for the cases where subsequent HDeoptimize are optimized away (by design we don't simplify too much in the range codegen itself, since we rely on later phases).

132
Fri Jul 15 16:33:38 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ba20c083_247d1295
Bytes: 225
One Deopt is later eliminated (fold+simplify) because Above(0,.) is always false. There is a missed optimization opportunity to eliminate another Deopt because Below(x,2) is always false in a branch taken on GreaterThan(x,1).

132
Fri Jul 15 16:58:26 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ba20c083_247d1295
UUID: 3ad1308d_efa81243
Bytes: 382
Yes it is. I actually was just adding the test on that optimization. Note that by design (and earlier request from Nicolas), I don't to full optimization in the range code gen to keep that simple and rely on subsequent phases to remove the redundant cases). We could use the range information on i to do the other optimization you suggest (since later phases cannot do that indeed).

156
Fri Jul 15 16:33:38 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ba20c083_242fd298
Bytes: 181
Similarly, one Deopt eliminated by fold+simplify, another missed opportunity (though relating Below(x+1,4) to GreaterThan(x,2) requires considering that x+1 does not overflow to 0).

156
Fri Jul 15 16:58:26 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ba20c083_242fd298
UUID: 3ad1308d_6f9542f7
Bytes: 13
same feedback

178
Fri Jul 15 16:33:38 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: fa26b89b_c67522b2
Bytes: 282
Optimization opportunity: the loop body is always executed and the null check is the first instruction there, so the Deopt is unnecessary if we do an actual (implicit) null check on the ArrayLength, though we would need to provide an environment appropriate for the first iteration.

178
Fri Jul 15 16:58:26 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: fa26b89b_c67522b2
UUID: 3ad1308d_afc73a07
Bytes: 5
noted

205
Fri Jul 15 16:33:38 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: caf9233e_7dde57db
Bytes: 757
What we generate for the inputs of these Deopts is pretty brain-dead (especially since we do not run GVN after BCE). There are additions and subtractions that cancel each other out but they make it all the way to codegen.

  i64 = start - 1
  i65 = end - (start - 1) = end - start + 1
  i66 = (end - start + 1) - 1 = end - start
  i67 = end + 2
  i68 = (end + 2) - (end - start) = start + 2
  i70 = end + 2
  i72 = start - 1
  i73 = end - (start - 1) = end - start + 1
  i74 = (end - start + 1) - 1 = end - start
  i75 = end - 2
  i76 = (end - 2) - (end - start) = start - 2
  z79 = (start - 2) above (start + 2)
  v80 Deoptimize[z79]
  z81 = (start + 2) above (end + 2)
  v82 Deoptimize[z81]
  z83 = (end + 2) above/equal array.length
  v84 Deoptimize[z83]

205
Fri Jul 15 16:58:26 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: caf9233e_7dde57db
UUID: 3ad1308d_2fb4ea90
Bytes: 258
I had originally much more simplification in induction/range var code generator, but we decided for the less bug prone way of avoiding duplication of simplification rules; if we don't optimize enough in the eventual code, though, we should revisit indeed....

