Revision: 19fa3ef1aa5af01bb7b61806a50e781f38f68acf
Patch-set: 1
File: compiler/dex/reference_map_calculator.h

26:0-28:78
Mon Oct 13 19:26:24 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 104ec00c_69014c26
Bytes: 208
Could you expand the context of this. Its using the verifier's GC maps and then pruning/expanding the data. Why not have a pass that computes the reference maps from LIR? This would be useful for the comment.

26:0-28:78
Mon Oct 13 21:07:51 2014 +0000
Author: Razvan A Lupusoru <1013855@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 104ec00c_69014c26
UUID: 10f960d6_5818c967
Bytes: 1252
I will expand the comment on this but to answer you here, the calculator will not reuse the verifier GC maps. This is because it may need to generate GC maps for: offsets which did not exist, offsets that are not in original program order, instructions using compiler temps. Therefore what ends up happening is that the results of type inference are used by the reference map calculator. It will generate maps for each instruction (that has safepoint) based on what references reach that point. The backend changes very little in that it is only updated to call the new interface instead of verifier and the runtime does not change at all.

You are right that I could've done the reference maps from LIRs, but conceptually it did not match what I wanted. Namely, the reference registers are a bytecode level semantic. Additionally, in absence of LIRGraph with reference type information, the MIRGraph was a better alternative. The only ugliness that arose from this approach is that the ME must provide information on whether something has safepoint when safepoints are generated by BE. However, this to me is fundamentally needed anyway since ME level optimizations must have knowledge of safepoints in order to prevent/reduce code motion around them.

File: runtime/dex_file.cc

715:0-715:72
Mon Oct 13 19:26:24 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d0218832_68e06b52
Bytes: 73
Is this a TODO or an optimization? Some more information would be useful.

715:0-715:72
Mon Oct 13 21:07:51 2014 +0000
Author: Razvan A Lupusoru <1013855@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d0218832_68e06b52
UUID: d038a85e_39d4fa4d
Bytes: 660
This is more of a TODO actually. The runtime must be augmented with extra information in cases where offsets did not exist in original method but can escape to runtime with information for this offset. This can happen due to inlining method with loops for example. Another place it can happen is if you do some loop unrolling and you duplicate offsets. The reference map calculator will end up assigning a non-disambiguating offset if the reference maps are different at those points. This new offset will not have debug information unless we explicitly record it in the oat method (something we can definitely do but I wanted to keep it out of this solution).

