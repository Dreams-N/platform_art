Revision: d669c3f31ea1bc86e24ee55ebe4b2ab7715380e9
Patch-set: 2
File: compiler/oat_writer.cc

1195:52-1196:38
Wed Aug 10 14:20:43 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 79af3bf6_52d4740f
Bytes: 64
I think this should be GetDexCache(patch.TargetStringDexFile());

1195:52-1196:38
Wed Aug 10 17:51:02 2016 +0000
Author: Christina Wadsworth <1109993@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 79af3bf6_52d4740f
UUID: b927f349_11cebb87
Bytes: 24
Yes, I will change this.

File: runtime/class_linker.cc

1275:35-1275:77
Wed Aug 10 14:20:43 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 59dd179f_692a6584
Bytes: 78
std::min(dex_file->NumStringIds(), mirror::DexCache::kDexCacheStringCacheSize)

1275:35-1275:77
Wed Aug 10 17:51:02 2016 +0000
Author: Christina Wadsworth <1109993@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 59dd179f_692a6584
UUID: b927f349_b12b479a
Bytes: 206
All dex caches need to be of size 1024 because of assumptions other places in the code. There isn't a lot of space lost doing this, and we still have 95% savings total compared to previous string dex cache.

1275:35-1275:77
Thu Aug 11 18:34:16 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b927f349_b12b479a
UUID: fefcf12c_1ee3cd2c
Bytes: 219
Where do we make such assumptions? I'd expect everything to be fine if we use the min() because for

    index < dex_file->NumStringIds()

we would access entry at

    index % 1024 < min(1024, dex_file->NumStringIds())

1275:35-1275:77
Thu Aug 11 18:36:31 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: fefcf12c_1ee3cd2c
UUID: 7ee9e168_2ce41cd1
Bytes: 215
That would require an additional load in the fast-path, wouldn't it?

I think it would be easiest to show statistics. I'd imagine that for most cases the size of the string table is simply larger than 1024, anyways.

1275:35-1275:77
Thu Aug 11 18:38:18 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7ee9e168_2ce41cd1
UUID: 1e69c5e4_57326cf5
Bytes: 40
Why would it require an additional load?

1275:35-1275:77
Thu Aug 11 18:39:50 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1e69c5e4_57326cf5
UUID: 7ee9e168_8c720812
Bytes: 158
How do you find the slot you're interested in? I thought the scheme is a direct mapping using %. If you have a non-constant size, you'd have to use that here.

1275:35-1275:77
Thu Aug 11 18:43:30 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7ee9e168_8c720812
UUID: 7ee9e168_4c9080f4
Bytes: 203
Actually the % is a red herring, it uses &(1-size) in the assembly so it has to be a power of 2.

So it would need the loads and the slower division code potentially if you wanted to minimize memory use.

1275:35-1275:77
Thu Aug 11 18:48:42 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7ee9e168_4c9080f4
UUID: 7ee9e168_ec4bd483
Bytes: 60
The "and (size-1)" is an implementation detail of "%"... :-)

1275:35-1275:77
Thu Aug 11 18:51:44 2016 +0000
Author: Christina Wadsworth <1109993@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7ee9e168_4c9080f4
UUID: 7ee9e168_8c11e864
Bytes: 223
Yes, for the reasons that both Igor and Andreas stated above, I decided to do 1024 for all arrays. I also talked to Nicolas about it when he was here, and he was fine with doing so. I'll find numbers and upload a statistic.

1275:35-1275:77
Thu Aug 11 18:51:51 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7ee9e168_ec4bd483
UUID: 1e69c5e4_172cf493
Bytes: 255
Guys, this is simple math. The function

    f(x) = x%1024

maps the range [0,N) to [0,min(1024,N)).

So, using a valid string index, you cannot map it beyond the proposed

    std::min(dex_file->NumStringIds(), mirror::DexCache::kDexCacheStringCacheSize)

1275:35-1275:77
Thu Aug 11 19:00:48 2016 +0000
Author: Christina Wadsworth <1109993@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1e69c5e4_172cf493
UUID: 7ee9e168_8ce9e80f
Bytes: 203
Oh I see what you're saying. You're proposing to leave all entrypoints as they are and then just change the c++ because theoretically if everything is done right, x%N and x%1024 are the same if N < 1024.

1275:35-1275:77
Thu Aug 11 19:05:34 2016 +0000
Author: Christina Wadsworth <1109993@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7ee9e168_8ce9e80f
UUID: 7ee9e168_ec251455
Bytes: 390
Yes upon further reflection, I realize that you literally just have 1024-N empty spaces and that we don't lose anything by doing this. I'm going to start implementing it because it will save us space without any type of runtime hit. First I'm going to upload my current patch though, because it has all current comments fixed except this one. LMK if anyone thinks it's a bad idea to change.

1275:35-1275:77
Thu Aug 11 19:05:55 2016 +0000
Author: Christina Wadsworth <1109993@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7ee9e168_ec251455
UUID: 7ee9e168_ace70c12
Bytes: 24
And thank you @vmarko :)

1275:35-1275:77
Thu Aug 11 19:52:01 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7ee9e168_ace70c12
UUID: 7ee9e168_ffbff80e
Bytes: 374
Right vmarko, was overthinking this.

If the array size is <1024 at runtime, don't we still want to have a bounds check everywhere we access it that the requested index is within range?

Otherwise we get a buffer overrun?

Maybe there's something in another part of the system which guarantees this invariant ahead of time without needing to put it into the asm entrypoints?

File: runtime/utils/dex_cache_arrays_layout-inl.h

96:19-96:61
Wed Aug 10 14:20:43 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b9a8d3f4_acb3c3b2
Bytes: 135
std::min(dex_file->NumStringIds(), mirror::DexCache::kDexCacheStringCacheSize), there is no reason to waste memory for small dex files.

