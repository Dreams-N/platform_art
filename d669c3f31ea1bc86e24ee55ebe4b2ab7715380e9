Revision: d669c3f31ea1bc86e24ee55ebe4b2ab7715380e9
Patch-set: 2
File: compiler/oat_writer.cc

1195:52-1196:38
Wed Aug 10 14:20:43 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 79af3bf6_52d4740f
Bytes: 64
I think this should be GetDexCache(patch.TargetStringDexFile());

1195:52-1196:38
Wed Aug 10 17:51:02 2016 +0000
Author: Christina Wadsworth <1109993@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 79af3bf6_52d4740f
UUID: b927f349_11cebb87
Bytes: 24
Yes, I will change this.

File: runtime/class_linker.cc

1275:35-1275:77
Wed Aug 10 14:20:43 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 59dd179f_692a6584
Bytes: 78
std::min(dex_file->NumStringIds(), mirror::DexCache::kDexCacheStringCacheSize)

1275:35-1275:77
Wed Aug 10 17:51:02 2016 +0000
Author: Christina Wadsworth <1109993@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 59dd179f_692a6584
UUID: b927f349_b12b479a
Bytes: 206
All dex caches need to be of size 1024 because of assumptions other places in the code. There isn't a lot of space lost doing this, and we still have 95% savings total compared to previous string dex cache.

1275:35-1275:77
Thu Aug 11 18:34:16 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b927f349_b12b479a
UUID: fefcf12c_1ee3cd2c
Bytes: 219
Where do we make such assumptions? I'd expect everything to be fine if we use the min() because for

    index < dex_file->NumStringIds()

we would access entry at

    index % 1024 < min(1024, dex_file->NumStringIds())

1275:35-1275:77
Thu Aug 11 18:36:31 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: fefcf12c_1ee3cd2c
UUID: 7ee9e168_2ce41cd1
Bytes: 215
That would require an additional load in the fast-path, wouldn't it?

I think it would be easiest to show statistics. I'd imagine that for most cases the size of the string table is simply larger than 1024, anyways.

1275:35-1275:77
Thu Aug 11 18:38:18 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7ee9e168_2ce41cd1
UUID: 1e69c5e4_57326cf5
Bytes: 40
Why would it require an additional load?

1275:35-1275:77
Thu Aug 11 18:39:50 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1e69c5e4_57326cf5
UUID: 7ee9e168_8c720812
Bytes: 158
How do you find the slot you're interested in? I thought the scheme is a direct mapping using %. If you have a non-constant size, you'd have to use that here.

1275:35-1275:77
Thu Aug 11 18:43:30 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7ee9e168_8c720812
UUID: 7ee9e168_4c9080f4
Bytes: 203
Actually the % is a red herring, it uses &(1-size) in the assembly so it has to be a power of 2.

So it would need the loads and the slower division code potentially if you wanted to minimize memory use.

1275:35-1275:77
Thu Aug 11 18:48:42 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7ee9e168_4c9080f4
UUID: 7ee9e168_ec4bd483
Bytes: 60
The "and (size-1)" is an implementation detail of "%"... :-)

File: runtime/utils/dex_cache_arrays_layout-inl.h

96:19-96:61
Wed Aug 10 14:20:43 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b9a8d3f4_acb3c3b2
Bytes: 135
std::min(dex_file->NumStringIds(), mirror::DexCache::kDexCacheStringCacheSize), there is no reason to waste memory for small dex files.

