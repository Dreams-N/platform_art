Revision: a6b1ead81603513fd40b77fd72f06d8cb1f35276
Patch-set: 2
File: runtime/debugger.cc

5047:0-5047:83
Wed Oct 07 08:26:42 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 90ec99cf_cdc0495e
Bytes: 240
This does not seem right. Native code also holds jmethodid, and those don't have the luxury of this VisitRoots hook.

Either we need to find a way to get a jmethodid automatically create a root, or handle a jmethodid from an unloaded class.

5047:0-5047:83
Wed Oct 07 16:54:26 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 90ec99cf_cdc0495e
UUID: 5061411e_c7314e92
Bytes: 165
jmethodID aren't supposed to prevent class unloading. They become invalid if their corresponding class gets unloaded. It is the users job to not use stale jmethodID.

5047:0-5047:83
Wed Oct 07 17:42:27 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 5061411e_c7314e92
UUID: b06c3d16_b68608da
Bytes: 120
Is that specified? If the users want the method to stay alive, does he have to create a jobject for its declaring class?

5047:0-5047:83
Wed Oct 07 17:50:05 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b06c3d16_b68608da
UUID: 5061411e_e27d5872
Bytes: 106
It is specified. The users need to keep a reference to the class or reobtain the jmethodIDs and jfieldIDs.

5047:0-5047:83
Wed Oct 07 21:08:27 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 5061411e_e27d5872
UUID: 506b0131_03588e1a
Bytes: 66
What happens when the user gives an old jmethodid to a JNI method?

5047:0-5047:83
Wed Oct 07 21:11:03 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 506b0131_03588e1a
UUID: 1001893d_80b0c01f
Bytes: 95
We probably want to have check JNI give an abort, otherwise we could just SIGSEGV or something.

