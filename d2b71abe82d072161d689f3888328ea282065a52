Revision: d2b71abe82d072161d689f3888328ea282065a52
Patch-set: 1
File: /COMMIT_MSG

12:0-13:49
Fri Aug 22 16:35:08 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 53076152_043a264d
Bytes: 225
I thought it was computed globally and initialized in the entry block. Which is a cost on all paths not just the one that needs the code pointer. That said for x86-64 we just shouldn't be generating code pointer calculations.

12:0-13:49
Fri Aug 22 17:09:23 2014 +0000
Author: Razvan A Lupusoru <1013855@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 53076152_043a264d
UUID: 13f169a2_5d9c07e8
Bytes: 826
Let me clarify :)

So the code pointer register is calculated at start of method and then spilled into its home location (temp VR on stack). All paths that need it load this register which is then cached by the backend temp system that tries to prevent reloads. Well when you have a diamond shape in the generated code (the code that generates is linear), then only one of the paths would have loaded the start of method register. Thus at merge of diamond shape it is not valid to say that the backend temp always is loaded in physical register even though the temp caching system says so.

Regarding x86_64, I agree. All accesses should be done relative to instruction pointer (future feature). But I think you are right to note this because the code right now explicitly assumes that explicit non-rip register is being used.

File: compiler/dex/quick/x86/fp_x86.cc

733:0-733:36
Fri Aug 22 16:33:11 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 13f169a2_427ee2f0
Bytes: 35
why should this hold? add a comment

733:0-733:36
Mon Aug 25 08:34:02 2014 +0000
Author: Alexei Zavjalov <1039893@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 13f169a2_427ee2f0
UUID: f3dbf536_23756ea2
Bytes: 142
I think we have to use a condition here instead of CHECK, because base_of_code_ may not be initialized in some cases (see AnalyzeInvokeStatic)

733:0-733:36
Tue Aug 26 00:35:12 2014 +0000
Author: Razvan A Lupusoru <1013855@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f3dbf536_23756ea2
UUID: 9399d985_b22c5586
Bytes: 47
Agreed with Alexei. Thanks for catching it Ian.

734:0-742:5
Fri Aug 22 16:33:11 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 13f169a2_8278ca01
Bytes: 32
what's this doing? add a comment

734:0-742:5
Tue Aug 26 00:35:12 2014 +0000
Author: Razvan A Lupusoru <1013855@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 13f169a2_8278ca01
UUID: f3c4d562_d2880567
Bytes: 4
Done

File: compiler/dex/quick/x86/utility_x86.cc

956:0-957:83
Fri Aug 22 16:33:11 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 13f169a2_021e9ac5
Bytes: 64
for x86-64 this should just be a no-op and we use RIP addressing

956:0-957:83
Tue Aug 26 00:35:12 2014 +0000
Author: Razvan A Lupusoru <1013855@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 13f169a2_021e9ac5
UUID: f3c4d562_d23d65d8
Bytes: 40
Completely agreed as a future feature :)

