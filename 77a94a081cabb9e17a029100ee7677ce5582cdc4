Revision: 77a94a081cabb9e17a029100ee7677ce5582cdc4
Patch-set: 7
File: compiler/optimizing/code_generator_arm.cc

288:41-288:50
Wed Sep 16 15:45:17 2015 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 44725a92_f06d6b88
Bytes: 11
overwrites?

288:41-288:50
Wed Sep 16 16:00:35 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 44725a92_f06d6b88
UUID: 09e87b64_05fa547c
Bytes: 4
Done

4419:6-4419:28
Wed Sep 16 16:24:43 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 44209a82_0a457f35
Bytes: 819
This is good for readability but it is still 2 or 3 extra instructions compared to

      __ Bind(&loop);
      __ LoadFromOffset(kLoadWord, out, out, super_offset);
      __ MaybeUnpoisonHeapReference(out);
      // We can go to `done` if out is already zero.
      __ CompareAndBranchIfZero(out, &done);  // CBZ unless out is high reg.
      // Branch here from kClassHierarchyCheck, see below.
      __ cmp(out, ShifterOperand(cls));
      __ b(&loop, NE);
      __ LoadImmediate(out, 1);
      if (zero.IsLinked()) {
        __ b(&done);
      }

This would save "__ b(&abstract_entry);" and the unconditional "__ b(&done)" and likely also use actual CBZ instead of CMP+Bcc.

It would be actually better for kClassHierarchyCheck to jump into the middle of _this_ loop, potentially saving one instruction on the CBZ.

4445:29-4445:36
Wed Sep 16 16:24:43 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e9ea475e_a44a8c41
Bytes: 57
"if" - Using "because" before we actually compare is odd.

File: compiler/optimizing/code_generator_arm64.cc

428:41-428:50
Wed Sep 16 15:45:17 2015 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 6473de94_f779f3c3
Bytes: 11
overwrites?

428:41-428:50
Wed Sep 16 16:00:35 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6473de94_f779f3c3
UUID: a9f4cf41_a200400c
Bytes: 4
Done

2309:6-2309:18
Wed Sep 16 16:24:43 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 09e87b64_850f843a
Bytes: 359
Similar to Thumb2, you can avoid this instruction if you implement kClassHierarchyCheck by jumping into kAbstractClassCheck rather than the other way around. Unlike Thumb2, you're not getting any extra benefits from CBZ but code size for kClassHierarchyCheck will remain the same while kAbstractClassCheck will have 2 fewer instructions.

Same for x86/x86-64.

File: compiler/optimizing/code_generator_x86.cc

304:41-304:50
Wed Sep 16 15:45:17 2015 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0465c2c3_ab02b611
Bytes: 11
overwrites?

304:41-304:50
Wed Sep 16 16:00:35 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0465c2c3_ab02b611
UUID: e9ea475e_445aa01b
Bytes: 4
Done

5029:6-5029:11
Wed Sep 16 15:45:17 2015 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8478d270_879ec9c9
Bytes: 9
NearLabel

