Revision: b545fdff2395ba20a6d75861a08354bf69659519
Patch-set: 1
File: compiler/optimizing/code_generator_arm64.cc

634:10-634:21
Mon Nov 24 16:30:04 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 9f448158_38dfcde2
Bytes: 109
No need any more, the compiler falls back to interpreter and there is no quick frame to deal with at runtime.

634
Fri Nov 28 13:38:43 2014 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 9f448158_38dfcde2
UUID: 9f448158_d8967c21
Bytes: 4
Done

817
Fri Nov 21 14:09:27 2014 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 9f448158_cf2d9d04
Bytes: 109
This is inherited from 32bit ARM.  What if class->status_ > kStatusInitialized ? Shouldn't it be B(ne, ...) ?

817
Mon Nov 24 16:30:04 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 9f448158_cf2d9d04
UUID: 7f526d24_2f6c2929
Bytes: 80
I don't understand. If it's greater or equal it's initialized, so nothing to do.

817
Mon Nov 24 16:39:46 2014 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7f526d24_2f6c2929
UUID: 7f526d24_7acc21c8
Bytes: 259
What I meant here is - if class->status_ has a random, higher than kStatusInitialized value we should not go through. Thus for every != kStatusInitialized value of class->status_ we should go to slow_path->GetEntryLabel().

__ B(ne, slow_path->GetEntryLabel()

817
Mon Nov 24 17:28:46 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7f526d24_7acc21c8
UUID: 9f448158_b82a9de8
Bytes: 54
Can we have something greater than kStatusInitialized?

817
Wed Nov 26 12:01:19 2014 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 9f448158_b82a9de8
UUID: 9f448158_2478c8e9
Bytes: 148
It seems not, I do not know why the first time I have looked at this I was under the impression that there can be other states > kStatusInitialized.

818:73-818:79
Wed Nov 26 01:22:25 2014 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 3f4d55af_3095d0a2
Bytes: 353
It's probably unflushed store buffers and outstanding loads rather than caches.  And this isn't the place to teach people about memory ordering.  Maybe just delete that part of the comment, leaving
// Even if the initialized flag is set, we need to ensure consistent ...

That's not part of the proposed change, but while we're touching this comment ...

818
Wed Nov 26 12:01:19 2014 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 3f4d55af_3095d0a2
UUID: 9f448158_048dc48f
Bytes: 7
Will do

818
Fri Nov 28 13:38:43 2014 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 9f448158_048dc48f
UUID: 5f404975_401ed087
Bytes: 4
Done

826
Fri Nov 21 14:09:27 2014 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 9f448158_0fee054a
Bytes: 133
Hans: Do we always have a "dmb ish st" before setting the class status to initialised? If so this relaxed order should be sufficient.

826
Wed Nov 26 01:22:25 2014 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 9f448158_0fee054a
UUID: 9f572141_dad00106
Bytes: 653
AFAICT, we effectively set the initialized flag using a Java volatile store.  That's overkill, but it'll do, and it's not performance critical.  I suspect just a dmb st would not be correct because loads in the initialization code could see stores in code that follows the initialization.  You probably need a full dmb.  Thus the comment looks wrong to me, but the code looks correct.

Theoretically an acquire load should be cheaper.  You might know whether it is in practice.

This may not be the best way to do the initialization check due to the barrier/ordering costs.  We've been discussing some possible alternatives. But that's a separate issue.

826
Wed Nov 26 12:01:19 2014 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 9f572141_dad00106
UUID: 1f633129_f31b708e
Bytes: 103
Thanks Hans! Will remove the comments. For now, the Dmb(Domain, Read) is cheaper than the load-acquire.

826
Fri Nov 28 13:38:43 2014 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1f633129_f31b708e
UUID: 9f448158_388108d6
Bytes: 4
Done

1298
Fri Nov 21 14:09:27 2014 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 9f448158_efb9814e
Bytes: 205
Would it be worth moving  this logic in VisitSuspend? (following->IsGoto() ?)

There are currently 3 places where we decide to add/remove Suspend Checks:
* HGoto
* HSuspendCheck
* instruction_simplifier.cc

1298
Mon Nov 24 16:30:04 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 9f448158_efb9814e
UUID: 9f448158_780e75da
Bytes: 239
So the logic in the backends should be where to place these suspend checks. instruciton_simplifier will just remove them from the graph.

A backend could as well decide not to do anything and generate the suspend checks where it sees them.

File: compiler/optimizing/code_generator_arm64.h

47:0-47:71
Mon Nov 24 16:30:04 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 7f526d24_8f831d62
Bytes: 82
We're not using counters on arm anymore. Can we get rid of this as well for arm64?

47
Mon Nov 24 16:39:46 2014 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7f526d24_8f831d62
UUID: 9f448158_f86b855e
Bytes: 8
Will do.

47
Fri Nov 28 13:38:43 2014 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 9f448158_f86b855e
UUID: 1f633129_33bcc891
Bytes: 4
Done

