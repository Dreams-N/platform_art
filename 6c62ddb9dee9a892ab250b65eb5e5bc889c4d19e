Revision: 6c62ddb9dee9a892ab250b65eb5e5bc889c4d19e
Patch-set: 7
File: runtime/base/scoped_arena_containers.h

1:0-1:2
Wed Oct 21 10:22:43 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 391bde5c_c313569f
Bytes: 23
Remove this whitespace.

1:0-1:2
Wed Oct 21 16:21:04 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 391bde5c_c313569f
UUID: 194a9a42_b26300cf
Bytes: 15
Accidental tab.

File: runtime/base/stl_util.h

156:6-156:66
Wed Oct 21 10:22:43 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 5947b23e_0c0e7779
Bytes: 63
How does that catch double-free? (It can catch use-after-free.)

156:6-156:66
Wed Oct 21 16:21:04 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 5947b23e_0c0e7779
UUID: 99784a71_f6df40c2
Bytes: 98
The destructor is more likely to crash on the second free, but I suppose it doesn't really matter.

156:6-156:66
Wed Oct 21 21:44:26 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 99784a71_f6df40c2
UUID: b9618ebd_a0d020b7
Bytes: 383
It should just set a destructed bit=true in the underlying arena memory (meaning it should've allocated extra memory from the arena).

Then this destroyer can DCHECK(destructed bit = false) to prevent double frees.

Use after free (not in a memory tool) would have to be done by overloading the operator-> or operator* which is probably not worth the effort for the scope of this CL.

156:6-156:66
Wed Oct 21 21:51:11 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b9618ebd_a0d020b7
UUID: 19337ad8_b39b0a72
Bytes: 154
That seems invasive, it would require all arena allocators to add that extra bit so that the DestroyOnlyDelete can check it. Can we do that in another CL?

