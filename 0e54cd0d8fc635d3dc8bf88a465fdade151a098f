Revision: 0e54cd0d8fc635d3dc8bf88a465fdade151a098f
Patch-set: 3
File: runtime/gc/accounting/mod_union_table-inl.h

29:6-29:37
Wed Mar 26 18:26:27 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1c23318f_a4e2d7f2
Bytes: 233
Related question: Does this class ever remove references from the reference cache? If not, I wonder if the cache gets very large over time as different references are written to the image space, in particular with a moving collector?

29
Wed Mar 26 18:35:18 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1c23318f_a4e2d7f2
UUID: 1c23318f_4478434e
Bytes: 83
The references associated with a card are recomputed each time the card is dirtied.

29
Wed Mar 26 18:56:34 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1c23318f_4478434e
UUID: 392487a3_dce8c520
Bytes: 251
Are you sure? :) Does ModUnionTableReferenceCache::references_ get elements *removed* from it ever (I see only references_->push_back() or ->Put())? And, it looks like we don't recreate the mod union table object or the references_ map at each gc. No?

29
Wed Mar 26 19:07:11 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 392487a3_dce8c520
UUID: 590f7b24_dd49db4f
Bytes: 242
Well, it is possible that some references could be held live if the card isn't dirtied. This can happen if you write only nulls into the card. But if it is dirtied, we recompute cards_references and do references_.Put(card, cards_references).

29
Wed Mar 26 23:24:24 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 590f7b24_dd49db4f
UUID: 1c23318f_73cd03a2
Bytes: 72
I see that the Put call overwrites the existing vector of cards. Thanks.

35:7-35:19
Tue Mar 25 20:17:08 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dc435932_0bb01dd5
Bytes: 134
Is ShouldAddReference a better name?

Is this equivalent to "return !space_->HasAddress(ref)" without needing to loop over the spaces?

35
Wed Mar 26 18:35:18 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dc435932_0bb01dd5
UUID: 590f7b24_3abc5d4b
Bytes: 126
Nice catch, it is equivalent to !GetHeap()->GetImageSpace()->HasAddress(). This won't work with multiple image spaces however.

35
Wed Mar 26 18:56:34 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 590f7b24_3abc5d4b
UUID: 1c23318f_44cbe3e8
Bytes: 189
As the mod union table object has a reference to its space (ModUnionTable::space_), it's self-contained, that is, we don't need to refer back to Heap or assume there's only one image space.

35
Wed Mar 26 19:07:11 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1c23318f_44cbe3e8
UUID: 392487a3_1c64fdf4
Bytes: 25
Nevermind, you are right.

File: runtime/gc/collector/immune_region.h

70:18-70:22
Tue Mar 25 20:17:08 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 9c3721c3_69de052e
Bytes: 110
This is fine. Future note: if end_ is dropped (and just size_ is used), then there's no need for UpdateSize()?

70
Wed Mar 26 18:35:18 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 9c3721c3_69de052e
UUID: 392487a3_39bc6b4b
Bytes: 108
I considered doing that, but decided against it since it would have complicated the AddContinuousSpace code.

