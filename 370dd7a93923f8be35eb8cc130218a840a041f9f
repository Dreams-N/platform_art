Revision: 370dd7a93923f8be35eb8cc130218a840a041f9f
Patch-set: 2
File: compiler/optimizing/code_generator_arm.cc

2878:18-2878:36
Fri Jan 09 09:34:28 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2eb529f8_9c29a5b0
Bytes: 16
Why this change?

2878:18-2878:36
Fri Jan 09 11:34:54 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2eb529f8_9c29a5b0
UUID: 0eb22512_db05f307
Bytes: 417
The code was already there to handle constants (in the instruction code generator)

wrt having two options: 
- it's just an incremental approach where I didn't feel changing the existing working code
- in theory you can save a register in some case (as you don't need to move the constant). Not sure if that actually happen and if it has any impact.
- I can clean this up in the next CL if you still think it's worth.

File: compiler/optimizing/code_generator_arm64.cc

2299
Tue Jan 13 12:00:32 2015 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ce800d7c_81723a7a
Bytes: 71
No need for a temp register here since anyway we do not use this value.

2299
Tue Jan 13 14:19:36 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ce800d7c_81723a7a
UUID: 4ec7bdd5_45782a2c
Bytes: 4
Done

2301
Tue Jan 13 12:00:32 2015 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0ec145c3_233c0ab2
Bytes: 148
Use wzr - see GenerateFrameEntry().

Any valid ARMv8 micro-architecture would execute the load - thus trigger the exception, but discard the result.

2301
Tue Jan 13 14:19:36 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0ec145c3_233c0ab2
UUID: 4ec7bdd5_657ba62a
Bytes: 4
Done

File: compiler/optimizing/code_generator_x86.cc

2929:18-2929:21
Fri Jan 09 09:34:28 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2eb529f8_5c0c3d5f
Bytes: 72
Just require register. It's not worth the trouble having two strategies.

2929:18-2929:21
Fri Jan 09 11:34:54 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2eb529f8_5c0c3d5f
UUID: 0eb22512_bb0a2716
Bytes: 21
see my other comment.

2939:5-2939:56
Thu Jan 08 19:51:56 2015 +0000
Author: Razvan A Lupusoru <1013855@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0ee6a5ff_64222094
Bytes: 684
Although this is implicit (as in it will throw exception via the fault), it is not really how it is supposed to work by design. If the fault would happen on the object access, you wouldn't need the extra test instruction. With this approach, you have just one less instruction than before (no branch) which I don't think would really give you any wins.

Anyway, to be fair, I get why you implemented it this way, which is because you need to satisfy the null check semantics of the null check node at the correct point. But this makes me wonder whether it is even worth it having implicit checks in the first place... I don't think you're really going to get a benefit in performance.

2939:5-2939:56
Fri Jan 09 11:34:54 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0ee6a5ff_64222094
UUID: 0eb22512_5b97a351
Bytes: 129
Thanks Razvan. I'm aware of this. As I discussed with Nicolas this is a start, and I'll work pushing the check in each operation.

File: compiler/optimizing/code_generator_x86_64.cc

2604:18-2604:34
Fri Jan 09 09:34:28 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0eb22512_db1f3385
Bytes: 20
Same comment as x86.

2604:18-2604:34
Fri Jan 09 11:34:54 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0eb22512_db1f3385
UUID: 2eb529f8_3ce851b6
Bytes: 21
see my other comment.

