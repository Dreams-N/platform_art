Revision: 47fae318e5b20e55a1c4927b74ce061b34a2fb20
Patch-set: 1
File: compiler/optimizing/intrinsics_arm64.cc

296
Thu Jan 28 22:40:29 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 548b02a3_40dcb035
Bytes: 134
This seems a clever way of doing the compare(), but what do I know, I worked for intel :-). So please be nice, my first ARM code here.

298:0-298:58
Thu Jan 28 23:27:21 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 94ed7a3a_7fce8f88
Bytes: 27
This doesn't change cflags?

298:0-298:58
Fri Jan 29 00:43:25 2016 +0000
Author: Serban Constantinescu <1072549@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 94ed7a3a_7fce8f88
UUID: 910e6c27_f7aba092
Bytes: 219
No, for ARM64 there is no MOV + setflags. If you are referring to the issue we have recently discussed that applies only to ARM Thumb2 code and in particular when instructions that set flags are used inside an IT block.

299:1-300:86
Fri Jan 29 00:43:25 2016 +0000
Author: Serban Constantinescu <1072549@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 51207491_15a734cc
Bytes: 470
I guess we can do this without the MOV as follows:

Register zero_register = is_long ? xzr : wzr;

__Cinc(out, zero_register, gt);
__Cinv(out, out, lt);

Please note that for ARM64 we have a dedicated zero register:
- XZR - 64bit register view
- WZR - 32bit register view

Here are a couple of useful presentations on the ARM64 ISA:
http://malideveloper.arm.com/downloads/ARMv8_InstructionSetOverview.pdf
http://malideveloper.arm.com/downloads/ARMv8_64_bit_migration.pdf

299:1-300:86
Fri Jan 29 01:01:37 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 51207491_15a734cc
UUID: 548b02a3_a3c9fe36
Bytes: 87
Pure genius! I like it, very compact.
Thanks for the links. I even book an ARM book :-)

299:1-300:86
Fri Jan 29 01:22:56 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 548b02a3_a3c9fe36
UUID: f465d6c4_c0419294
Bytes: 452
Hmm. I am having trouble setting the rn to zero reg.
The code breaks on the 3th assertion below. What am I missing (btw. we don't need the is_long, since the output is 32-bit, so we can use wzr in all cases)

void Cinc(const Register& rd, const Register& rn, Condition cond) {
    VIXL_ASSERT(allow_macro_instructions_);
    VIXL_ASSERT(!rd.IsZero());
    VIXL_ASSERT(!rn.IsZero());
    SingleEmissionCheckScope guard(this);
    cinc(rd, rn, cond);
  }

299:1-300:86
Fri Jan 29 01:35:01 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f465d6c4_c0419294
UUID: 5422228b_08ad87a8
Bytes: 123
Ah, I guess they force you to use the Cset, which is an alias for this case when rn is zero. Bit elaborate, but okay.

PTAL

