Revision: d89d710bd5f41d91b6eb7ea88a37eb4b6888caf5
Patch-set: 5
File: compiler/optimizing/induction_var_analysis_test.cc

403:5-403:7
Sat Aug 01 00:14:23 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: aa33dcf3_e15cec00
Bytes: 97
PTAL

this beautiful syntax ensures that the test
is less sensitive on how the SSA graph is built

403:5-403:7
Sat Aug 01 00:18:11 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: aa33dcf3_e15cec00
UUID: eaf154a3_eededffd
Bytes: 227
that seems like it could be better off replacing every character that actually needs escaping after the fact with its escaped version. 

(it doesn't seem like there's any non-escaped usage of these special characters is there?)

403:5-403:7
Sat Aug 01 00:24:20 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: eaf154a3_eededffd
UUID: 4a6260ef_2b22d8a8
Bytes: 163
I am not sure I follow.
( ) + * 
need special treatment with \
Since this is C++ we need to escape \ as \\
(alternatively we could use raw strings, but same thing)

403:5-403:7
Sat Aug 01 00:31:41 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: eaf154a3_eededffd
UUID: 4a6260ef_0b9b9449
Bytes: 202
Ah, I think I know what you meant
(build the regexp string using replacements).

Unfortunately we use + as literal, and also as reg exp in d+

(there are ways around that, but seems this is easiest way)

403:5-403:7
Sat Aug 01 00:35:36 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4a6260ef_2b22d8a8
UUID: 0a5ce834_6128fa88
Bytes: 884
It looks like it's trying to express these literal characters:

  (:)*+

however since in regex grammar they are special (denoting a capture group, a wildcard, and so on..) they need to be escaped with a \, but then C++ makes us escape with \\

So usages instead end up looking like:

  \\(
  \\:
  \\)
  \\*
  \\+

The only situation here which wants to use a non-literal is '\d+' as that is truly trying to match any digit

I don't see any capture groups or wild cards used here, so I was just musing the following characters could get \\ substituted after-the-fact (with a string replace):

  (:)*  

(but not + since there's another + which is used without \\)

e.g.

  "((2:Constant) * i + ...".replace(r"\\(|\\:\\)\\*", "\\$1") ,
   // replace with actual regex method there

(or alternatively just use [:], [(], [+], [*], thats slightly more readable than \\: , \\(, etc IMHO).

