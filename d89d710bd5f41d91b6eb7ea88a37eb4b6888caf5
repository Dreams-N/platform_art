Revision: d89d710bd5f41d91b6eb7ea88a37eb4b6888caf5
Patch-set: 5
File: compiler/optimizing/induction_var_analysis_test.cc

403:5-403:7
Sat Aug 01 00:14:23 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: aa33dcf3_e15cec00
Bytes: 97
PTAL

this beautiful syntax ensures that the test
is less sensitive on how the SSA graph is built

403:5-403:7
Sat Aug 01 00:18:11 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: aa33dcf3_e15cec00
UUID: eaf154a3_eededffd
Bytes: 227
that seems like it could be better off replacing every character that actually needs escaping after the fact with its escaped version. 

(it doesn't seem like there's any non-escaped usage of these special characters is there?)

403:5-403:7
Sat Aug 01 00:24:20 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: eaf154a3_eededffd
UUID: 4a6260ef_2b22d8a8
Bytes: 163
I am not sure I follow.
( ) + * 
need special treatment with \
Since this is C++ we need to escape \ as \\
(alternatively we could use raw strings, but same thing)

403:5-403:7
Sat Aug 01 00:31:41 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: eaf154a3_eededffd
UUID: 4a6260ef_0b9b9449
Bytes: 202
Ah, I think I know what you meant
(build the regexp string using replacements).

Unfortunately we use + as literal, and also as reg exp in d+

(there are ways around that, but seems this is easiest way)

403:5-403:7
Sat Aug 01 00:35:36 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4a6260ef_2b22d8a8
UUID: 0a5ce834_6128fa88
Bytes: 884
It looks like it's trying to express these literal characters:

  (:)*+

however since in regex grammar they are special (denoting a capture group, a wildcard, and so on..) they need to be escaped with a \, but then C++ makes us escape with \\

So usages instead end up looking like:

  \\(
  \\:
  \\)
  \\*
  \\+

The only situation here which wants to use a non-literal is '\d+' as that is truly trying to match any digit

I don't see any capture groups or wild cards used here, so I was just musing the following characters could get \\ substituted after-the-fact (with a string replace):

  (:)*  

(but not + since there's another + which is used without \\)

e.g.

  "((2:Constant) * i + ...".replace(r"\\(|\\:\\)\\*", "\\$1") ,
   // replace with actual regex method there

(or alternatively just use [:], [(], [+], [*], thats slightly more readable than \\: , \\(, etc IMHO).

403:5-403:7
Sat Aug 01 00:38:58 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0a5ce834_6128fa88
UUID: aa33dcf3_2138b487
Bytes: 111
Our comments crossed :-)
If you really insist, I will change
but imho nothing that uses regexpr is readable :-)

403:5-403:7
Sat Aug 01 00:44:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: aa33dcf3_2138b487
UUID: 6a5f2428_999ec76c
Bytes: 730
I believe only having to escape \\d+ would be ideal but that seems like a lot of work so it's probably not worth it. If we were doing this in every single optimizing test then it probably is worth it.

It's common in a few places (such as vim) to flip around their regex escapes so that things like () etc are regular literals.

--- 
As a less interesting alternative (and this is more of thinking out loud than asking for any changes),

Using [x] instead of \\x should be slightly more readable because I think we as programmers are trained a little bit better to handle open/close pairs

  [)][)][)] is slightly more readable than
  \\)\\)\\)

and also because we can ignore every other character instead of every 2/3 characters

403:5-403:7
Sat Aug 01 00:47:18 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6a5f2428_999ec76c
UUID: ea295486_68cd7f5c
Bytes: 6
Noted.

