Revision: da51fb287153ed36e895ef22c5a50ecb82ac9fa4
Patch-set: 1
File: compiler/dex/quick/x86/target_x86.cc

831
Thu Jul 10 09:07:47 2014 +0000
Author: Dmitry Petrochenko <1039576@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 593f80b5_3025a898
Bytes: 130
Please handle here cu_->target64 case:
... Thread::ThreadSuspendTriggerOffset<8> ...
Is rs_rAX still applicable here for 64-bit?..

831
Thu Jul 10 09:11:43 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 593f80b5_3025a898
UUID: 395d6c32_2add3f7f
Bytes: 216
What's the issue with rs_rAX? The reason for using the test operation on Intel rather than a load is to avoid needing a temporary register to clobber. The result is not used, we're relying on the load for a segfault.

831
Thu Jul 10 09:25:01 2014 +0000
Author: Dmitry Petrochenko <1039576@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 395d6c32_2add3f7f
UUID: 593f80b5_50eeecd7
Bytes: 156
Well, sorry, it seems that there is no issue with rAX here. Only Thread::ThreadSuspendTriggerOffset<8> change needed (it is one of cross compilation issues)

831
Thu Jul 10 21:00:49 2014 +0000
Author: Dave Allison <1036486@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 593f80b5_50eeecd7
UUID: f97cb4a5_f53858e9
Bytes: 101
Surely this is a 32 bit mov.  My understanding is that ...Offset<4> is correct for that.  Am I wrong?

831
Thu Jul 10 21:06:00 2014 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f97cb4a5_f53858e9
UUID: 1980a8c3_561b5465
Bytes: 277
It is a 32 bit move, but the offset that it is to move from is in the 64 bit thread area.  I think Dmitry wants:
NewLIR2(kX86Mov32RT, rs_rAX.GetReg(),  cu_->target64 ? Thread::ThreadSuspendTriggerOffset<8>().Int32Value() : Thread::ThreadSuspendTriggerOffset<4>().Int32Value());

