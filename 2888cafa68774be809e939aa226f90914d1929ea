Revision: 2888cafa68774be809e939aa226f90914d1929ea
Patch-set: 4
File: runtime/arch/x86_64/quick_entrypoints_x86_64.S

1054:4-1054:8
Thu Aug 11 09:53:30 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 7e3721db_d2e0a4be
Bytes: 4
ANDQ

1054:4-1054:8
Thu Aug 11 17:48:25 2016 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7e3721db_d2e0a4be
UUID: 7ee9e168_fcbf090f
Bytes: 4
Done

1078:4-1078:20
Thu Aug 11 09:53:30 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 7e3721db_32ea50a2
Bytes: 241
Can we just "movq %rcx, %r8" at the beginning and load the component size shift straight to %rcx?

Based on previous information from Intel, XCHG is slow even when operating on registers. They didn't want to use it in parallel move resolver.

1078:4-1078:20
Thu Aug 11 17:48:25 2016 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7e3721db_32ea50a2
UUID: 7ee9e168_dc89e525
Bytes: 75
Maybe, but we need to move back to 32 bit register for storing class later.

1078:4-1078:20
Thu Aug 11 18:11:36 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7ee9e168_dc89e525
UUID: def9ed3d_fd7dc749
Bytes: 122
We can use r8-r15 as 32-bit registers. But we really need the Class* to be in ecx for the slow path as you've done in PS5.

