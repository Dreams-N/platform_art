Revision: e8a2e9d1dfe9c88acade68114604addac736089a
Patch-set: 3
File: runtime/interpreter/interpreter.cc

496:4-508:5
Mon Jan 19 19:42:11 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: eb586371_2048ee8d
Bytes: 122
Feels like this belongs in interpreter_common(-inl), as it's shared (it's a straight-forward copy from switch, isn't it?).

496:4-508:5
Tue Jan 20 07:27:26 2015 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: eb586371_2048ee8d
UUID: 4bc24f1f_16eba207
Bytes: 281
It's similar but not exactly the same. We handle both "pending exception" and "no pending exception" paths here. In the interpreter, this is shared between the instruction handling (when there is no pending exception) and the exception handling (when there is a pending exception).

File: runtime/interpreter/interpreter_goto_table_impl.cc

152:4-154:5
Mon Jan 19 19:42:11 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: eb586371_803d7ae2
Bytes: 269
I think this is actually wrong with deopt (mea culpa). What if the catch handler starts there? It's not valid Java, but one should be able to construct a dex file for it. (I'm decent with the instruction constraints, but it has been a while for structural constraints.)

152:4-154:5
Tue Jan 20 07:27:26 2015 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: eb586371_803d7ae2
UUID: 4b408f75_60faec80
Bytes: 281
I don't think a catch handler can start at 0x0. A catch handler would need a previous instruction to throw the exception. This instruction could be at 0x0 but not the catch handler. Plus the instruction throwing the instruction itself cannot be part of the catch handler I believe.

152:4-154:5
Tue Jan 20 08:33:48 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4b408f75_60faec80
UUID: 2b66fb36_3aae5929
Bytes: 671
No. Just like many other bytecode formats, dex defines exception handlers by a (nested) structure containing the starting pc of the handler and the range of PCs covered. So a handler can be lexically before the guarded region. (See dex file format, start at try_item.)

What I don't know is whether the verifier rejects such a thing on the grounds of an exception register conflict (no exception on method entry, but exception on handler entry). But exceptions are not in a regular dalvik register (that's why move-exception exists), and if the "catch-block" doesn't start with this, I believe the verifier would let that go through as a perfectly fine start of a method.

152:4-154:5
Tue Jan 20 08:40:54 2015 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2b66fb36_3aae5929
UUID: 4bc24f1f_96179269
Bytes: 519
I mean when we invoke a method, we start by its instruction at 0x0. We don't expect any exception pending at this time so it can't be the first instruction of a catch handler. The only way is to have jump (with a "goto" for instance) after the catch handler. Maybe that's something we should check at verification time?

Anyway, I can move the check in the Execute method (the caller). It's the normal interpreter path (not the deoptimization path) starting at DEX pc 0x0 so we know there is no exception pending there.

152:4-154:5
Tue Jan 20 08:47:51 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4bc24f1f_96179269
UUID: 2b66fb36_5abd1556
Bytes: 938
I mean: catch handlers are not separated in the code by anything, they are just designated by a secondary structure. The only thing possibly distinguishing them is if they use the exception, their first instruction must be a move-exception. Just going of the file format, nothing is stopping you from running "catch handler" code like regular code. So imagine a catch handler that just prints "hello" and never touches the exception. That code is perfectly fine no matter whether there was an exception or not. So from my view, this is legal:

 0: const-string v0, "Hello World"
 1: invoke-static ...  // setup out, shortcut here
 2: new-instance v1, RuntimeException
 3: throw v1

And assign pc 0 as the handler for the pc-range [3...3].

Don't change the check just yet. I still have hope that I just don't know enough about the verifier and what we sort out. I really like where we check right now (and that it's not in the caller...).

152:4-154:5
Tue Jan 20 08:50:51 2015 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2b66fb36_5abd1556
UUID: cbd63fdb_17139cca
Bytes: 53
Right, I see your point now (thanks for the example).

152:4-154:5
Tue Jan 20 18:18:40 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cbd63fdb_17139cca
UUID: 6bf1d3a1_ce81638f
Bytes: 323
I confirmed that this code passes the verifier and gets compiled (haven't tested running, obviously...):

 .method public static run()V
 .registers 6
 :Label1
        const v1, 15
        const v2, 0
 
 :Label2
        div-int v0, v1, v2
 
 :Label3
        return-void
 
 .catchall {:Label2 .. :Label3} :Label1
 .end method

