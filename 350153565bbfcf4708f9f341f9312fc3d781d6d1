Revision: 350153565bbfcf4708f9f341f9312fc3d781d6d1
Patch-set: 1
File: runtime/stack.cc

368:5-369:65
Thu Dec 10 14:55:22 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0576b2c5_13bf2cce
Bytes: 103
this is confusing, which one are we implementing and care about? Please just state the one we're using.

368:5-369:65
Fri Dec 11 15:41:31 2015 +0000
Author: Goran Jakovljevic <1067943@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0576b2c5_13bf2cce
UUID: 4520aa91_fbd82747
Bytes: 773
Actually, both. For aosp_mips-eng, architecture is MIPS32r2 with 32 fpu registers, each 32-bit long. For doubles we are using pairs F0-F1, F2-F3... On the other hand, for aosp_mips64-eng, 2nd architecture is MIPS32r6 with 32 fpu registers, each 64-bit long.

To simplify things, in optimizing we are using 16 even-numbered 64-bit registers. 16 odd-numbered registers on MIPS32r6 are not used, and on MIPS32 pars of registers are used, but we see them as 64-bit registers. We are distinguishing those 2 cases on assembler level. E.g. to load upper half word to F12, on MIPS32r2 we use:

  lwc1  $f13, 4($sp)

while on MIPS32r6 we use:

  lw    $t0, 4($sp)
  mthc1 $t0, $f12

But mostly, same instructions are generated for both cases (e.g. ldc1 $f12, 0($sp) works for both).

371:0-374:3
Thu Dec 10 14:57:01 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c03648c7_09b66946
Bytes: 79
But why don't we encode the reg for low and reg + 1 for high in the stack maps?

371:0-374:3
Fri Dec 11 15:41:31 2015 +0000
Author: Goran Jakovljevic <1067943@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c03648c7_09b66946
UUID: 251f3657_37191204
Bytes: 93
Can you point me how to do that? If it is possible at all because of things in above comment.

