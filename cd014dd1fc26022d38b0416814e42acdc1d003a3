Revision: cd014dd1fc26022d38b0416814e42acdc1d003a3
Patch-set: 12
File: /COMMIT_MSG

18
Fri Nov 06 01:12:42 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1698aa84_e7d6191b
Bytes: 13
That's great!

File: compiler/optimizing/bounds_check_elimination.cc

515:22-515:38
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 56030291_86626aba
Bytes: 48
pointers :( How about using the block header id?

518:22-518:38
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 16e42a25_aff655b8
Bytes: 5
ditto

1101:0-1101:39
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b637de6a_41ab12dd
Bytes: 96
Maybe add a comment that we are going to use this HDeoptimize to refine the range of the length?

1122:6-1122:64
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 760c86c0_673bf27a
Bytes: 40
Explain why there are such restrictions.

1123
Sat Nov 07 00:18:46 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d69a9277_a8a944b9
Bytes: 68
Is it done by licm? Maybe try bce before licm and get this for free?

1206:27-1206:39
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 760c86c0_4738ee7b
Bytes: 7
const&?

1224:27-1224:60
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 760c86c0_2745faf3
Bytes: 76
isn't that the reverse? "Use analysis for static bce only if loop is finite"

1226
Sat Nov 07 00:18:46 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b620be2e_e2d81ca7
Bytes: 107
Should we always set try_dynamic_bce's value? If it's not an induction variable, it should be set to false?

1231:66-1231:84
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d61d32f8_7adef92d
Bytes: 6
we try

1232:34-1232:45
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 56030291_66588e09
Bytes: 10
by adding?

1233:17-1233:20
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b6127ed6_69862584
Bytes: 5
will?

1237:21-1237:33
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 16e42a25_6fe18ded
Bytes: 13
HBoundsCheck?

1245:100-1245:102
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b637de6a_613bb67a
Bytes: 13
line too long

1250
Sat Nov 07 00:18:46 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f6923665_e3ba8dfb
Bytes: 48
Can you make it clear it's unsigned comparisons?

1251:12-1251:28
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d60ff2af_aa5d2ffc
Bytes: 96
this sounds too generic. Maybe be more precise: "or ... if we know the the lower bound of upper.

1253
Sat Nov 07 00:18:46 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1698aa84_e18602ca
Bytes: 97
I think combining is still nice. Maybe we can find a way to combine the HDeoptimize instructions?

1257:0-1260:90
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 36fe8ebd_8514a21d
Bytes: 101
Update the comment line 1250 that it's actually:
if (lower > upper) deopt;
if (upper >= length) deopt

1283:0-1284:88
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b6127ed6_49836172
Bytes: 39
How about doing this in a follow-up cl?

1287
Sat Nov 07 00:18:46 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f6923665_3ec6686f
Bytes: 106
Loop header can have successor outside the loop. Can deopt approach still benefit accesses in loop header?

1317:0-1317:48
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 9609fab1_0b8441ed
Bytes: 4
why?

1319:0-1319:75
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 16e42a25_0fe8c9ce
Bytes: 177
As a side effect, this will put the (obj == null) deopt instruction. You're doing the CanHandleLength line 1247 as the last check, so you're fine, but still, this looks brittle.

1335:0-1335:47
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d61d32f8_da1385a7
Bytes: 4
why?

1351:30-1351:43
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b6127ed6_097d6949
Bytes: 4
can?

1352:80-1352:90
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b637de6a_a1477ef7
Bytes: 4
why?

1354:67-1354:69
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d60ff2af_6a585709
Bytes: 2
in

1357:100-1357:101
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d60ff2af_4a5593cd
Bytes: 13
line too long

1359:0-1362:7
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d6345268_62cdf6dd
Bytes: 110
Can a loop be somehow changed from finite to infinite? If not, we could put that flag in the HLoopInformation.

1389:0-1389:36
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d6345268_42d47268
Bytes: 52
I think it always has. Did you see cases it did not?

1425
Sat Nov 07 00:18:46 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b69d1e72_fd65d260
Bytes: 312
The old code has an example of the transformation of some source code which is still helpful so it's better to be kept, including phi insertion and explanation of the strong guarantee that no deoptimization is triggered if the loop body itself doesn't throw AIOOBE.
The combining part can be modified/done later.

1465:0-1466:72
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d60ff2af_aa940fb6
Bytes: 71
Also explain why you ended up in that situation. An example might help.

1506:2-1509:25
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d60ff2af_6a9f37d2
Bytes: 21
This looks misplaced.

1544:2-1544:22
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 56030291_c68f42a1
Bytes: 7
const&?

1582:5-1582:28
Fri Nov 06 11:44:05 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d60ff2af_ca762373
Bytes: 44
Add more explanations about what breaks SSA.

File: compiler/optimizing/optimizing_compiler.cc

498:82-498:87
Fri Nov 06 11:44:05 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 56030291_c6762273
Bytes: 65
`final` is not so expressive. `after_bce` is much more revealing.

556:6-556:11
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d61d32f8_5a08d56e
Bytes: 49
Add a comment what you want to achieve with this?

