Revision: cd014dd1fc26022d38b0416814e42acdc1d003a3
Patch-set: 12
File: /COMMIT_MSG

18
Fri Nov 06 01:12:42 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1698aa84_e7d6191b
Bytes: 13
That's great!

18
Mon Nov 09 19:43:47 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1698aa84_e7d6191b
UUID: b620be2e_0da461c7
Bytes: 28
Thanks. I am very happy too!

File: compiler/optimizing/bounds_check_elimination.cc

515:22-515:38
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 56030291_86626aba
Bytes: 48
pointers :( How about using the block header id?

515:22-515:38
Mon Nov 09 19:43:47 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 56030291_86626aba
UUID: b620be2e_6db39d11
Bytes: 4
Done

518:22-518:38
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 16e42a25_aff655b8
Bytes: 5
ditto

518:22-518:38
Mon Nov 09 19:43:47 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 16e42a25_aff655b8
UUID: f6923665_5e27b4f5
Bytes: 4
Done

1101:0-1101:39
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b637de6a_41ab12dd
Bytes: 96
Maybe add a comment that we are going to use this HDeoptimize to refine the range of the length?

1101:0-1101:39
Mon Nov 09 19:43:47 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b637de6a_41ab12dd
UUID: 365a0ede_689cfbdb
Bytes: 4
Done

1122:6-1122:64
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 760c86c0_673bf27a
Bytes: 40
Explain why there are such restrictions.

1122:6-1122:64
Mon Nov 09 19:43:47 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 760c86c0_673bf27a
UUID: 365a0ede_e8dd4b94
Bytes: 4
Done

1123
Sat Nov 07 00:18:46 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d69a9277_a8a944b9
Bytes: 68
Is it done by licm? Maybe try bce before licm and get this for free?

1123
Mon Nov 09 19:43:47 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d69a9277_a8a944b9
UUID: 36712e54_b39900f0
Bytes: 182
No, this is very similar to licm, but a bit more powerful
licm will give up on the first exception throwing statement; this hoisting knows that the exception is already taken care of

1123
Tue Nov 10 01:09:27 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 36712e54_b39900f0
UUID: d6d7f27c_8d26c5f7
Bytes: 146
licm can still hoist non-throwing instruction after the first exception throwing instruction. HArrayGet is non-throwing (HBoundsCheck is instead).

1123
Tue Nov 10 18:13:54 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d6d7f27c_8d26c5f7
UUID: 16ac2a06_f5f74a7c
Bytes: 222
But the array get may be hoisted after the null check has been hoisted into the yes-block of the if-taken-structure. Pure LICM would hoist the instruction into the pre-header which is always executed, which would be wrong.

1123
Tue Nov 10 20:45:35 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 16ac2a06_f5f74a7c
UUID: 56cb02e2_d51206a1
Bytes: 756
Ok, so it's not the normal hoisting. Maybe can make it more explicit in the comment/naming.

There two cases I think should be considered here:
1) If the HArrayGet is in a branch (doesn't dominate all back edges), should we still always hoist it?
2) If the bounds check isn't eliminated due to the deopt inserted by loop, instead by the deopt-for-constant-index case, like straightline a[1], a[2], a[3] inside a loop, then it's not correct to hoist the HArrayGet out of loop (even if it's hoisted, it should be hoisted to the loop pre-header). I'm worried about this case since even if it's not done by bce here, if there is another licm phase after bce, this can happen since I don't see any dependency between the HArrayGet and the HDeoptimize currently.

1123
Wed Nov 11 21:15:44 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 56cb02e2_d51206a1
UUID: b6da7ea7_1572d72e
Bytes: 810
(1) I am not worried about this, since we can only hoist after null check has been eliminated, and we currently only do that statically if it is already executed, or dynamically if the null check and thus this load dominates all back edges
(2) this is a good observation, and something that worried me too; but not for the reasons you sketched; if we generate the taken structure, than we hoist it to the true path; this is okay since we won't execute the loop otherwise; so hoisting to preheader would be wrong! but what worries me is that we have gets in the loop-body without a null check, but no way to tell later phases that they cannot be hoisted to pure preheader, but must be hoisted to true block in taken structure; currently that does not happen, but I have no good solution on preventing it. Ideas?

1123
Thu Nov 12 00:25:37 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b6da7ea7_1572d72e
UUID: f6a6b626_aa1a7a4a
Bytes: 544
(1) it can still happen. e.g. we execute a arr[5] in the dominator, and later do arr[4] in a branch. The bounds check will be eliminated since the first arr[5] will prove a range. Then arr[4] will be attempted to be hoisted from the branch.

(2) One solution is licm after bce shouldn't try to move ArrayGet/Set. licm can take such a boolean parameter. It's too complicated for later phases to be aware of that ArrayGet/Set cannot be hoisted to pre-header. Even if it's hoisted to the taken branch, phi's need to be created. Just too much work.

1123
Thu Nov 12 18:18:00 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f6a6b626_aa1a7a4a
UUID: 16c50ace_01161dd6
Bytes: 169
Ah okay, in combination with the scalar based version. But even then we may preload something to eagerly, but it will never have side-effects that are unforeseen, right?

1206:27-1206:39
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 760c86c0_4738ee7b
Bytes: 7
const&?

1206:27-1206:39
Mon Nov 09 19:43:47 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 760c86c0_4738ee7b
UUID: b69d1e72_2ed1de20
Bytes: 160
Yes, that would be so nice. Unfortunately, if you chase deep into FitsIn defined above, due to the monotonic manipulations, the pointer cannot even be const :-(

1224:27-1224:60
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 760c86c0_2745faf3
Bytes: 76
isn't that the reverse? "Use analysis for static bce only if loop is finite"

1224:27-1224:60
Mon Nov 09 19:43:47 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 760c86c0_2745faf3
UUID: 36ef6e34_dde7eb61
Bytes: 4
Done

1226
Sat Nov 07 00:18:46 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b620be2e_e2d81ca7
Bytes: 107
Should we always set try_dynamic_bce's value? If it's not an induction variable, it should be set to false?

1226
Mon Nov 09 19:43:47 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b620be2e_e2d81ca7
UUID: 36ef6e34_5dd47b68
Bytes: 98
If we don't know anything, I does not matter either. If you prefer, I can set it do false at L1227

1226
Tue Nov 10 01:09:27 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 36ef6e34_5dd47b68
UUID: 76d4867d_aa156f1d
Bytes: 90
The caller seems to always set it to true if we don't set it here, if I read it correctly.

1226
Tue Nov 10 18:13:54 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 76d4867d_aa156f1d
UUID: f6a6b626_74d4fe11
Bytes: 178
Yes, because we may not know the exact range in terms of instruction +/- constant, but may be able to generate code for more complex cases (e.g. instruction + other_instruction).

1226
Tue Nov 10 20:45:35 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f6a6b626_74d4fe11
UUID: 369daed4_167ae2cc
Bytes: 161
My point is if it's not even an induction variable, the caller shouldn't even try to call TryDynamicBCE(). So it's better if we can return that information back.

1226
Wed Nov 11 21:15:44 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 369daed4_167ae2cc
UUID: b6da7ea7_b83ae517
Bytes: 345
Yes, I understand, but GetInductionRange() tries to get a range back in very simple terms only. So something can still be an induction but fail here. We don't have a good way to set this to false here. That's what is done by CanGenerateCode() later.

I see what you want to do here, but it seems a lot of work to avoid just a bit of tests later.

1231:66-1231:84
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d61d32f8_7adef92d
Bytes: 6
we try

1231:66-1231:84
Mon Nov 09 19:43:47 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d61d32f8_7adef92d
UUID: d683721b_2aef1471
Bytes: 4
Done

1232:34-1232:45
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 56030291_66588e09
Bytes: 10
by adding?

1232:34-1232:45
Mon Nov 09 19:43:47 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 56030291_66588e09
UUID: d66b7268_0da3156e
Bytes: 4
Done

1233:17-1233:20
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b6127ed6_69862584
Bytes: 5
will?

1233:17-1233:20
Mon Nov 09 19:43:47 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b6127ed6_69862584
UUID: b60c3eef_f9a8f79e
Bytes: 4
Done

1237:21-1237:33
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 16e42a25_6fe18ded
Bytes: 13
HBoundsCheck?

1237:21-1237:33
Mon Nov 09 19:43:47 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 16e42a25_6fe18ded
UUID: d66b7268_2da0595e
Bytes: 4
Done

1245:100-1245:102
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b637de6a_613bb67a
Bytes: 13
line too long

1245:100-1245:102
Mon Nov 09 19:43:47 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b637de6a_613bb67a
UUID: 568ea242_05e6b645
Bytes: 4
Done

1250
Sat Nov 07 00:18:46 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f6923665_e3ba8dfb
Bytes: 48
Can you make it clear it's unsigned comparisons?

1251:12-1251:28
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d60ff2af_aa5d2ffc
Bytes: 96
this sounds too generic. Maybe be more precise: "or ... if we know the the lower bound of upper.

1251:12-1251:28
Mon Nov 09 19:43:47 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d60ff2af_aa5d2ffc
UUID: b60c3eef_79d4e711
Bytes: 4
Done

1253
Sat Nov 07 00:18:46 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1698aa84_e18602ca
Bytes: 97
I think combining is still nice. Maybe we can find a way to combine the HDeoptimize instructions?

1253
Mon Nov 09 19:43:47 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1698aa84_e18602ca
UUID: 760646d1_f7a8009f
Bytes: 198
Yes, I agree. We already avoid some redundancy with subsequent unsigned comparison optimizations I added previously. However, proving when combining is valid would be nice to avoid runtime overhead!

1257:0-1260:90
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 36fe8ebd_8514a21d
Bytes: 101
Update the comment line 1250 that it's actually:
if (lower > upper) deopt;
if (upper >= length) deopt

1257:0-1260:90
Mon Nov 09 19:43:47 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 36fe8ebd_8514a21d
UUID: d66b7268_cd72ddc8
Bytes: 4
Done

1268
Tue Nov 10 20:45:35 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 16ac2a06_40993e3c
Bytes: 687
The reason in the old code about early-exit, dominate-all-back-edges, etc. is more about the co-relation between deoptimization and AIOOBE instead of profitability. We want to guarantee deoptimization happens if and only if AIOOBE is thrown. So those is done on the whole loop instead of each bounds check instruction.

If it's only done case by case for each bounds check instruction, that co-relation can be broken. deopt can be inserted before an early exit is detected later, for example.

In a jit world, we can definitely relax that restriction and profile the deopt at runtime and recompile if necessary. But for static compile, I think we still want to maintain that co-relation.

1268
Wed Nov 11 21:15:44 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 16ac2a06_40993e3c
UUID: 7b0e2f2a_6ba9e94f
Bytes: 284
Well I think we mean the same thing. I call it "profitable" because using dynamic bce too aggressively would fall back to interpreter, and thus be slow. Correctness is never an issue. So I think we mean the same thing, just call it differently. If not, we can discuss offline perhaps.

1268
Thu Nov 12 00:25:37 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7b0e2f2a_6ba9e94f
UUID: 96d1fa8e_12102929
Bytes: 89
Ok, I misunderstood the code below. After reading it more carefully I think it's correct.

1276
Thu Nov 12 00:25:37 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f6a6b626_2a27aa92
Bytes: 219
Can you put the early exit detection in its own method? And add some comments why it's necessary. Basically to make sure low and upper are really covered by the loop at runtime so as not to generate deopt unnecessarily.

1276
Thu Nov 12 18:18:00 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f6a6b626_2a27aa92
UUID: fb2e9f8f_6bf461f5
Bytes: 4
Done

1283:0-1284:88
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b6127ed6_49836172
Bytes: 39
How about doing this in a follow-up cl?

1283:0-1284:88
Mon Nov 09 19:43:47 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b6127ed6_49836172
UUID: 365a0ede_eb7465dc
Bytes: 74
Well, it does not seem overly complex right?
(compared to the rest :-) :-)

1283:0-1284:88
Tue Nov 10 23:06:12 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 365a0ede_eb7465dc
UUID: 56278298_263276ec
Bytes: 72
It sort of woke up my "premature optimizations" senses :) But your call.

1283:0-1284:88
Wed Nov 11 21:15:44 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 56278298_263276ec
UUID: 7b0e2f2a_2bfe515a
Bytes: 46
Donald Knuth would probably agree with you :-)

1287
Sat Nov 07 00:18:46 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f6923665_3ec6686f
Bytes: 106
Loop header can have successor outside the loop. Can deopt approach still benefit accesses in loop header?

1287
Mon Nov 09 19:43:47 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f6923665_3ec6686f
UUID: f6923665_20f3a607
Bytes: 88
Yes, but we have to be careful with these. For now, this heuristic avoids complications.

1317:0-1317:48
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 9609fab1_0b8441ed
Bytes: 4
why?

1317:0-1317:48
Mon Nov 09 19:43:47 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 9609fab1_0b8441ed
UUID: 9603babe_b81319a8
Bytes: 4
Done

1319:0-1319:75
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 16e42a25_0fe8c9ce
Bytes: 177
As a side effect, this will put the (obj == null) deopt instruction. You're doing the CanHandleLength line 1247 as the last check, so you're fine, but still, this looks brittle.

1319:0-1319:75
Mon Nov 09 19:43:47 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 16e42a25_0fe8c9ce
UUID: 760646d1_57d1ec1f
Bytes: 98
Sharp eye. It is however not that brittle, since worst case we would just hoisting the null check.

1335:0-1335:47
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d61d32f8_da1385a7
Bytes: 4
why?

1335:0-1335:47
Mon Nov 09 19:43:47 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d61d32f8_da1385a7
UUID: d66b7268_0d91d501
Bytes: 4
Done

1351:30-1351:43
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b6127ed6_097d6949
Bytes: 4
can?

1352:80-1352:90
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b637de6a_a1477ef7
Bytes: 4
why?

1352:80-1352:90
Mon Nov 09 19:43:47 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b637de6a_a1477ef7
UUID: 760646d1_17de542c
Bytes: 4
Done

1354:67-1354:69
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d60ff2af_6a585709
Bytes: 2
in

1354:67-1354:69
Mon Nov 09 19:43:47 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d60ff2af_6a585709
UUID: f6923665_200ac6a5
Bytes: 4
Done

1357:100-1357:101
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d60ff2af_4a5593cd
Bytes: 13
line too long

1357:100-1357:101
Mon Nov 09 19:43:47 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d60ff2af_4a5593cd
UUID: d683721b_ea3a5ca2
Bytes: 4
Done

1359:0-1362:7
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d6345268_62cdf6dd
Bytes: 110
Can a loop be somehow changed from finite to infinite? If not, we could put that flag in the HLoopInformation.

1359:0-1362:7
Mon Nov 09 19:43:47 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d6345268_62cdf6dd
UUID: d683721b_4a69a8a0
Bytes: 286
Yes, after we have done this, we could mark the loop as finite there, but since it currently does not have any knowledge of such things, I opted for the temporary data structure here. We may want to put more induction stuff in the loop structure in the future though, I would like that!

1389:0-1389:36
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d6345268_42d47268
Bytes: 52
I think it always has. Did you see cases it did not?

1389:0-1389:36
Mon Nov 09 19:43:47 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d6345268_42d47268
UUID: 760646d1_9718a4c5
Bytes: 59
I did. I made a note to find those cases and report to you.

1425
Sat Nov 07 00:18:46 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b69d1e72_fd65d260
Bytes: 312
The old code has an example of the transformation of some source code which is still helpful so it's better to be kept, including phi insertion and explanation of the strong guarantee that no deoptimization is triggered if the loop body itself doesn't throw AIOOBE.
The combining part can be modified/done later.

1425
Mon Nov 09 19:43:47 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b69d1e72_fd65d260
UUID: 1617cafd_3499d03d
Bytes: 4
Done

1425
Tue Nov 10 20:45:35 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1617cafd_3499d03d
UUID: 56cb02e2_7587d2f4
Bytes: 319
I don't see it yet. The source level example makes the transformation clear, and the explanation of the co-relation between deoptimization and throwing AIOOBE would still be nice. It makes it clear why we do early-exit detection, dominate-all-back-edges, etc. to make sure the loop really covers every index at runtime.

1425
Wed Nov 11 21:15:44 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 56cb02e2_7587d2f4
UUID: 56cb02e2_754512f3
Bytes: 47
Oh, it should be there now. Let me repo upload.

1465:0-1466:72
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d60ff2af_aa940fb6
Bytes: 71
Also explain why you ended up in that situation. An example might help.

1465:0-1466:72
Mon Nov 09 19:43:47 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d60ff2af_aa940fb6
UUID: 9603babe_38126971
Bytes: 4
Done

1506:2-1509:25
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d60ff2af_6a9f37d2
Bytes: 21
This looks misplaced.

1506:2-1509:25
Mon Nov 09 19:43:47 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d60ff2af_6a9f37d2
UUID: 365a0ede_0ba3016e
Bytes: 20
Moved to top method.

1544:2-1544:22
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 56030291_c68f42a1
Bytes: 7
const&?

1544:2-1544:22
Mon Nov 09 19:43:47 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 56030291_c68f42a1
UUID: 96b81a3f_3008c86e
Bytes: 4
Done

1582:5-1582:28
Fri Nov 06 11:44:05 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d60ff2af_ca762373
Bytes: 44
Add more explanations about what breaks SSA.

1582:5-1582:28
Mon Nov 09 19:43:47 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d60ff2af_ca762373
UUID: 9603babe_f8f7517c
Bytes: 4
Done

File: compiler/optimizing/optimizing_compiler.cc

498:82-498:87
Fri Nov 06 11:44:05 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 56030291_c6762273
Bytes: 65
`final` is not so expressive. `after_bce` is much more revealing.

498:82-498:87
Mon Nov 09 19:43:47 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 56030291_c6762273
UUID: 36892e3b_6cf84e6f
Bytes: 4
Done

556:6-556:11
Fri Nov 06 10:56:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d61d32f8_5a08d56e
Bytes: 49
Add a comment what you want to achieve with this?

556:6-556:11
Mon Nov 09 19:43:47 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d61d32f8_5a08d56e
UUID: 36712e54_8df621b9
Bytes: 4
Done

