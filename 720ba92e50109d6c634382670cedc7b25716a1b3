Revision: 720ba92e50109d6c634382670cedc7b25716a1b3
Patch-set: 1
File: runtime/mirror/array-inl.h

167:25-167:28
Thu Mar 27 09:08:51 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 19f8a337_00600867
Bytes: 63
// ... for T.
// count in in T sized units.
// copies are ... .

180:14-180:24
Thu Mar 27 09:08:51 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f904af03_dfb8bfa6
Bytes: 5
Ditto

205:2-206:63
Thu Mar 27 06:28:29 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 19f8a337_2009c4c0
Bytes: 156
I wonder about this comment. Do you expect that this Memmove/Memcpy can happen in parallel with access to this array resulting in reading part of the value?

205:2-206:63
Thu Mar 27 07:00:10 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 19f8a337_2009c4c0
UUID: f91d8f5d_ba74e911
Bytes: 49
Yes, its the tearing effect that must be avoided.

207:2-207:28
Thu Mar 27 06:28:29 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 99ec937b_64a24496
Bytes: 70
you can extend this check by " || std::abs(dst_pos - src_pos) >= count

207:2-207:28
Thu Mar 27 07:00:10 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 99ec937b_64a24496
UUID: 590f7b24_20330b25
Bytes: 100
I prefer to leave this covered by the copy forward logic below otherwise the code has to re-test it.

207:2-207:28
Thu Mar 27 07:05:56 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 590f7b24_20330b25
UUID: f904af03_df767f62
Bytes: 134
ok to me, my point was just you said memcpy is more efficient then memmove, so additional check could give one more chance for memcpy.

219
Thu Mar 27 09:10:39 2014 +0000
Author: Narayan Kamath <1014443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 99ec937b_c4deb0f4
Bytes: 10
const bool

