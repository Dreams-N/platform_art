Revision: c01952e3ebbfb4ccd8a62f0167285317c6ec2a3b
Patch-set: 1
File: runtime/interpreter/interpreter_switch_impl.cc

79:6-81:7
Thu Apr 07 21:07:11 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2ea720d3_0122ae7e
Bytes: 296
I assume this is for correctness, only? Somehow I'd guess all fast interpreters should not be one-stepping this? (Or is this how the chunked instrumentation works?)

Why is kDexNoIndex OK? What's the fast interpreter gonna do with this? Is this important for the bailout? A comment would be nice.

79:6-81:7
Thu Apr 07 21:33:28 2016 +0000
Author: Bill Buzbee <1001578@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2ea720d3_0122ae7e
UUID: 2ea720d3_24a7f8d0
Bytes: 651
I'll add a comment, but yes - once fast interpreters are fully implemented we won't be single-stepping.  Now that all targets are up, we just use this mode during debugging.  (That's why I didn't notice it before).  The kDexNoIndex represents no next dex pc to interpret in this method, which is the state we go to following a normal or exception return.  On return to mterp, this value tells us to exit to the caller.  In this case, OSR had previously taken control and completed the remainder of the method.  So, we just need to return.  This is the same pattern used in normal and exception returns.  Just missed it here when osr support was added.

79:6-81:7
Thu Apr 07 22:07:55 2016 +0000
Author: Bill Buzbee <1001578@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2ea720d3_24a7f8d0
UUID: 2ea720d3_a4d4286d
Bytes: 4
Done

