Revision: 529ac3ca9906fc1aee202ff86aad786da375d9b2
Patch-set: 2
File: runtime/utils.h

25:10-25:21
Tue Feb 17 23:54:30 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8ba1acbc_e0cda2ee
Bytes: 17
What is this for?

25:10-25:21
Wed Feb 18 00:00:52 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8ba1acbc_e0cda2ee
UUID: eb26a84e_136b2c03
Bytes: 83
The is_unsigned and make_unsigned. Those are template things that manipulate types.

25:10-25:21
Wed Feb 18 00:03:56 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8ba1acbc_e0cda2ee
UUID: cb81e44d_f54212d5
Bytes: 18
std::make_unsigned

121
Wed Feb 18 00:03:56 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: eb26a84e_f3a31014
Bytes: 94
This seems like it will underflow back to 0xFFFFF... for bits==0, you probably don't want that

131:6-131:73
Tue Feb 17 23:54:30 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: cb0e44b5_4a023333
Bytes: 67
Add a comment why you need this and the former check is not enough.

131:6-131:73
Wed Feb 18 00:00:52 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cb0e44b5_4a023333
UUID: eb26a84e_934dfcb6
Bytes: 13
Former check?

131:6-131:73
Wed Feb 18 00:03:56 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cb0e44b5_4a023333
UUID: eb26a84e_d6e92208
Bytes: 108
You can just use std::numeric_limits<T>::min() and max() instead of GetIntLimit, they are constexpr in C++11

131:6-131:73
Wed Feb 18 00:06:13 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: eb26a84e_934dfcb6
UUID: cb0e44b5_0a0c3b62
Bytes: 33
kBits == kBitsPerByte * sizeof(T)

137
Wed Feb 18 00:03:56 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 6b90f899_cf4dfd87
Bytes: 108
you may want an is_arithmetic check here to be symmetric with IsInt (which is implicit as part of is_signed)

145:9-145:18
Tue Feb 17 23:54:30 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8ba1acbc_c0d29e8e
Bytes: 29
Move this in the IsUint call?

145:9-145:18
Wed Feb 18 00:00:52 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8ba1acbc_c0d29e8e
UUID: cb81e44d_551c3e10
Bytes: 65
I don't think it's meant that way. I preserved old behavior here.

145:9-145:18
Wed Feb 18 00:06:13 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cb81e44d_551c3e10
UUID: cb0e44b5_ea37a70a
Bytes: 119
Meant which way? I'm just suggestion to write the shorter version:

return IsUint<kBits, T>(value < 0 ? -value : value)

145:9-145:18
Wed Feb 18 00:08:09 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cb81e44d_551c3e10
UUID: eb26a84e_96316a18
Bytes: 148
IIUC there's undefined behavior when value=0b100000...0 (std::numeric_limits<T>::min()) and it's signed because it will overflow after being negated

