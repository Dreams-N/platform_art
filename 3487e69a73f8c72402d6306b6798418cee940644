Revision: 3487e69a73f8c72402d6306b6798418cee940644
Patch-set: 24
File: /COMMIT_MSG

18:0-18:41
Wed Dec 16 11:23:57 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 25673634_772e2a3c
Bytes: 140
Why does it have to be slow? If I do:
invoke-super MyInterface.myDefaultMethod 

And that method exists, why can't you just use it directly?

18:0-18:41
Thu Dec 17 21:03:25 2015 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 25673634_772e2a3c
UUID: 850622ce_ba3dcd9f
Bytes: 136
No but we don't do that at the moment. We will add to the optimizing compiler support to compile them to a direct call (where possible).

18:0-18:41
Thu Dec 17 22:03:31 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 850622ce_ba3dcd9f
UUID: 651dae1a_968c2cb0
Bytes: 178
I am talking about the dispatch, not how we can make it a direct call in a compiler.

How is "invoke-super ThisInterfaceMethod" different than "invoke-super ThisSuperClassMethod"

18:0-18:41
Thu Dec 17 22:16:24 2015 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 651dae1a_968c2cb0
UUID: 8a5c6f37_a733aa31
Bytes: 901
First in interface super the class part does make a difference. The invoke is 'invoke-super {...}, LInterfaceClass;->methodName(...)LReturnValue;'

Two reasons:

1) We need to lookup the interface class. It is not simply the declaring class of the method like it is with normal invoke-super.

2) with normal invoke super we simply index into the vtable of the super class but with interface invoke-super we need to do a more complicated lookup procedure. Right now (in this ps) we do that by giving each interface an iftable which we perform lookup on. This is rather slow (we could also give interfaces an imt so it would be the same speed as an invoke-interface). Also we are actually going to not even do this since it adds too much memory overhead for what is (at the moment) a basically unused feature, especially given the compiler can often just turn it into a direct call or inline the method.

18:0-18:41
Thu Dec 17 23:21:09 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8a5c6f37_a733aa31
UUID: 05f952fe_9b960b6d
Bytes: 172
Could we make it like invokedirect (or actually use invokedirect)? So the method linked by the instruction is the actual method to call and we do not need to do any lookup?

18:0-18:41
Thu Dec 17 23:43:08 2015 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 05f952fe_9b960b6d
UUID: ca62e7ed_8902f98d
Bytes: 369
No (or at least probably not) b/c we need to throw ICCEs when the invoke has conflicting possible implementations. This means that sometimes there is no method in the dex file that can be said to be the target of the invoke. Note this is only possible when there are source-level incompatibilities in the dex, but needed for binary-compat/partial compilation/multi-dex.

18:0-18:41
Thu Jan 07 19:00:57 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ca62e7ed_8902f98d
UUID: 0a4ddf0f_da85c4c3
Bytes: 698
IIRC this is a straightforward optimization at the JIT compiler stage because by the time the class is loaded all (==before code is jitted, right?) of its superinterfaces/superclasses have also been loaded and therefore it knows the actual direct target (and we can make the same assumption for a class hierarchy within the same dex file).

However at source compiler stage it has no idea what classes will actually be loaded at runtime so it cannot put down an invoke-direct.

As Alex pointed out this isn't used at all right now so it's probably OK not to have a faster path until we see a need, since that was already the case for the class invoke-super (which is actually used in a few places).

18:0-18:41
Thu Jan 07 19:09:13 2016 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0a4ddf0f_da85c4c3
UUID: aa1773d7_df74cc66
Bytes: 232
@iam Correct.

Currently it will be quite slow for interpretation (since we don't add iftables or imt's to interfaces for memory usage) but when either jitting or dex2oating we can replace it with a direct call to the target method.

File: compiler/dex/quick/quick_compiler.cc

525
Tue Dec 15 23:07:33 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 25ead6c4_f18d0ae7
Bytes: 191
Make it more clear, like you said yourself in an earlier reply:


  // Always need to scan opcodes if we have default methods
  // since invoke-super for interface methods is never supported.

525
Thu Dec 17 21:03:25 2015 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 25ead6c4_f18d0ae7
UUID: a5d1668e_eb100d9b
Bytes: 4
Done

File: compiler/image_writer.cc

1228
Tue Dec 15 23:07:33 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 05e5d2f2_30c5ae65
Bytes: 4
Why?

1228
Thu Dec 17 21:03:25 2015 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 05e5d2f2_30c5ae65
UUID: 850622ce_7a3cd59b
Bytes: 44
It should be there. Moved to a different cl.

File: runtime/art_method.cc

151
Tue Dec 15 23:07:33 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c5b81ad7_2e247b5c
Bytes: 52
Why is it from the end now? Add explanatory comment.

151
Thu Dec 17 21:03:25 2015 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c5b81ad7_2e247b5c
UUID: c5dadaa8_4f66816f
Bytes: 24
I have no idea. Removed.

File: runtime/class_linker.cc

5411
Tue Dec 15 23:07:33 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e598be91_31075af8
Bytes: 8
Comment?

5411
Thu Dec 17 21:03:25 2015 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e598be91_31075af8
UUID: c5dadaa8_ec52e318
Bytes: 4
Done

5410:0-5413:3
Thu Dec 17 21:03:25 2015 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4518aa2c_f860edb8
Bytes: 219
Maybe add another experimental flag to control if we do this. It might in the future be worth it to give interfaces iftables (if this is really widely used) but for now we probably just want to do it an even slower way.

5526
Tue Dec 15 23:07:33 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 05e5d2f2_10d0b21a
Bytes: 22
Comment needs updating

5526
Thu Dec 17 21:03:25 2015 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 05e5d2f2_10d0b21a
UUID: c5dadaa8_acebcb63
Bytes: 4
Done

5717:34-5717:36
Tue Dec 15 23:07:33 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 05107294_4cd44edf
Bytes: 327
This is misleading, I would say it's more like it's 'accessible through the iftable' since IIUC this may actually require crawling each iftable's interface to get at the methods, as opposed to accessing the method directly.

See your comment on line 5700 which is less misleading and also uses "accessible through the iftable".

5717:34-5717:36
Thu Dec 17 21:03:25 2015 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 05107294_4cd44edf
UUID: a5b8863e_f3792aa9
Bytes: 4
Done

File: runtime/common_throws.cc

88:52-88:59
Tue Dec 15 23:07:33 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c5b81ad7_ee41a3eb
Bytes: 25
nit: /* parameter name */

88:52-88:59
Thu Dec 17 21:03:25 2015 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c5b81ad7_ee41a3eb
UUID: 4518aa2c_78a69d30
Bytes: 4
Done

90:65-90:69
Tue Dec 15 23:07:33 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 45db4a39_fc2ec0cd
Bytes: 25
nit: /* parameter name */

90:65-90:69
Thu Dec 17 21:03:25 2015 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 45db4a39_fc2ec0cd
UUID: 0512320e_9901fb22
Bytes: 4
Done

File: runtime/entrypoints/entrypoint_utils-inl.h

477
Tue Dec 15 23:07:33 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c5b81ad7_4e528fbb
Bytes: 43
Consider adding:

   // It is an interface.

477
Thu Dec 17 21:03:25 2015 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c5b81ad7_4e528fbb
UUID: a5b8863e_d357c606
Bytes: 4
Done

File: runtime/mirror/class.cc

551
Tue Dec 15 23:07:33 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 05107294_6cfcaa5f
Bytes: 303
I think I'm misunderstanding FindVirtualMethodForInterface, but since it filters to methods based on declaring class  while this one filters using name and signature..

Isn't it different lookup semantics?

I thought you would've just wanted to apply this FindVirtualMethodForInterfaceSuper recursively?

551
Thu Dec 17 21:03:25 2015 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 05107294_6cfcaa5f
UUID: 850622ce_fda57fc7
Bytes: 144
I did it this way since it works if we have a full iftable. If we don't we need to do it recursively (with some additional trickiness actually).

