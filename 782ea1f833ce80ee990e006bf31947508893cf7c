Revision: 782ea1f833ce80ee990e006bf31947508893cf7c
Patch-set: 3
File: compiler/optimizing/code_generator_arm.cc

1331:6-1331:92
Fri Nov 13 10:52:43 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 569062ca_219fa8d2
Bytes: 414
GenerateTestAndBranch() allows

    true_fallthrough == true
    true_target == nullptr
    false_falthrough == false
    false_target != null

and then we could call GenerateCompareTestAndBranch() with true_target == nullptr which is invalid.

This discrepancy seems to be at the API level, GenerateTestAndBranch() taking the true_fallthrough argument and GenerateCompareTestAndBranch() not having such parameter.

1331:6-1331:92
Fri Nov 13 11:06:55 2015 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 569062ca_219fa8d2
UUID: 569062ca_61a9b0fc
Bytes: 779
Well spotted, you have a keen eye for details, sir. This comes down to how HIf and HDeoptimize call the function and what conditions they might have. Hence the DCHECKs at the top of GenerateTestAndBranch and GenerateCompareTestAndBranch.

HIf will always provide non-null targets. So no problem there. HSelect will be the same story.

HDeoptimize always calls this with:
- true_branch != nullptr
- false_branch == nullptr
- true_fallthrough == false
- false_fallthrough == true

That passes the DCHECKs at the top of GenerateTestAndBranch but would fail it entered GenerateCompareTestAndBranch. However, it will never do that because the condition on HDeoptimize is either an integer comparison or a constant.

Do you have an API change in mind that would make this more obvious?

1331:6-1331:92
Fri Nov 13 11:42:31 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 569062ca_61a9b0fc
UUID: 36220e8b_48f3ff06
Bytes: 380
What about dropping the true_fallthrough and false_fallthrough parameters and just declaring that nullptr means fallthrough? If the function needs to branch to the fallthrough target, it can use a local Label.

And we should actually handle the "true fallthrough" case in GenerateCompareTestAndBranch(). That would make it future-proof and consistent with other cases around here.

1331:6-1331:92
Fri Nov 13 12:03:26 2015 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 36220e8b_48f3ff06
UUID: 36220e8b_081027d7
Bytes: 345
We cannot do that because CompareGenerateTestAndBranch generates a decision tree where it branches into the fallthrough branch (early exit). The false_fallthrough bool is there to prevent generating the very last jump.

I agree that that code could be refactored in the same manner, but that's a more complicated job beyond the scope of this CL.

1331:6-1331:92
Fri Nov 13 12:32:38 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 36220e8b_081027d7
UUID: 569062ca_61d7f06e
Bytes: 231
As I said, if you need to branch to the fallthrough, create a local Label.

    Label fallthrough;
    if (false_target == nullptr) { false_target = &fallthrough; }
    ...
    if (fallthrough.IsLinked()) { __ Bind(&fallthrough); }

1331:6-1331:92
Fri Nov 13 16:42:12 2015 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 569062ca_61d7f06e
UUID: 569062ca_41bbd400
Bytes: 142
Fair enough, check out PS4. It's actually quite neat, except for ARM64 but I don't want to extract the FP comparison to a separate function...

