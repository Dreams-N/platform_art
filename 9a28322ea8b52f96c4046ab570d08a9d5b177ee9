Revision: 9a28322ea8b52f96c4046ab570d08a9d5b177ee9
Patch-set: 5
File: compiler/utils/assembler_test.h

36:2-36:6
Thu May 01 00:18:32 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ea205093_15405466
Bytes: 4
Ass*

36:2-36:6
Thu May 01 02:26:54 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ea205093_15405466
UUID: 0a292485_d7b3f6ee
Bytes: 4
Done

File: compiler/utils/x86_64/assembler_x86_64.h

42:17-42:20
Thu May 01 07:47:32 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: aa1ad864_734d6081
Bytes: 41
Explain why, and should it be fixed then?

42:17-42:20
Thu May 01 15:31:07 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: aa1ad864_734d6081
UUID: ea205093_c9a7e130
Bytes: 407
This is for cross-compiling from 32b host to 64b target.

static inline bool IsInt(int N, word value) {
  CHECK_LT(0, N);
  CHECK_LT(N, kBitsPerWord);
  word limit = static_cast<word>(1) << (N - 1);
  return (-limit <= value) && (value < limit);
}

The second check fails, and correctly so. If N=32, then limit is -2........

Note: no other code in ART drives with N=32. So I think the local fix here is OK.

