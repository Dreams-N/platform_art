Revision: 1722968c1a5e55bca50361fec28e1291104fb6ab
Patch-set: 2
File: test/083-compiler-regressions/src/Main.java

41:8-41:21
Mon Sep 29 20:15:54 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 10ca3fde_7bf0636d
Bytes: 208
Would you mind writing the test in a self-contained run-test? The bigger this test grows, the more difficult it will be to diagnose things (plus if one test fails, we'll loose coverage on the ones following).

41:8-41:21
Tue Sep 30 10:46:19 2014 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 10ca3fde_7bf0636d
UUID: d0ec287c_447bc063
Bytes: 4
Done

41:8-41:21
Tue Sep 30 10:53:02 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d0ec287c_447bc063
UUID: 7029bc84_ae6ed79b
Bytes: 7
Thanks!

9850:2-9872:3
Mon Sep 29 18:30:03 2014 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 303103d2_9676f255
Bytes: 905
I believe this should be fine even without the synchronized blocks.  State is declared volatile and values is always accessed by one thread at a time.  The read into vs2 should be treated as a lock acquisition, which kills all available expressions.

If this is currently failing, there are in a sense two bugs:

1) Locks are not handled correctly, and

2) volatile reads are not handled correctly.

Both of these are probably caused by the same core issue now, but perhaps not in the future.

I would split this into two similar tests:  One is like this one without the synchronized blocks.  The other is like the first, except state is not volatile and instead all accesses to state are within a synchronized block.  It's also OK to leave this as a third test, but I would emphasize the ones that can fail in response to a single failure in the analysis.  This one seems to require two similar failures.

9850:2-9872:3
Mon Sep 29 18:38:38 2014 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 303103d2_9676f255
UUID: f0e76c92_059ed43d
Bytes: 161
I though volatile load/store doesn't affect the visibility of non-volatile fields. If it does, I'll also need to fix the processing of volatile IGET/IPUT in GVN.

9850:2-9872:3
Mon Sep 29 18:50:51 2014 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f0e76c92_059ed43d
UUID: 90f63048_df48bb27
Bytes: 536
They do.  They contribute to the "synchronization order" (http://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4.4) just like lock acquisitions and releases.  This changed with the 2005 memory model revision.

The basic principle is that any code that has races only on volatiles and locks (i.e. that disallows simultaneous access to any other variables unless they are all read accesses) has sequentially consistent, i.e. interleaving semantics.  Your test code without the synchronized blocks satisfies that constraint.

