Revision: 04a7bfaf9dd5b862bb72be4ada5c9994dfa88243
Patch-set: 5
File: compiler/optimizing/code_generator_arm.cc

4984:2-4993:3
Tue Oct 13 21:38:50 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 5fa8725b_33735217
Bytes: 120
Is this to optimize baseline? Otherwise I'd assume constant folding should have taken care of this. Maybe add a comment?

4984:2-4993:3
Tue Oct 13 21:40:45 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 5fa8725b_33735217
UUID: aadf6a22_a1e7b89c
Bytes: 70
fyi, baseline is going deprecated (debuggable doesn't use it anymore).

4984:2-4993:3
Tue Oct 13 22:02:50 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: aadf6a22_a1e7b89c
UUID: 1f30ba11_091cea34
Bytes: 302
I assumed so, but it was my only guess why there's still an AND with 0 or 0xFFFFFFFF. Otherwise somebody should check our constant folding.

(Or is this some lower opt mode thing for debuggability? In that case it still seems better to be explicit and replace the HIR with the HIntConstant or whatever)

4984:2-4993:3
Wed Oct 14 10:18:11 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1f30ba11_091cea34
UUID: 2a27faf5_2da119ed
Bytes: 253
Good point Andreas.

Actually constant folding handles the 0 case. We should add 0xffffffff case as well and remove this.

The only question is if other transformations between last fold and codegen can introduce this; which I don't think it's the case.

4984:2-4993:3
Wed Oct 14 10:37:42 2015 +0000
Author: Alexandre Rames <1052304@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2a27faf5_2da119ed
UUID: 9cfbd833_de2a0515
Bytes: 70
The `0xFF...` case is done in the simplifier, not in constant folding.

4984:2-4993:3
Wed Oct 14 11:22:11 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 9cfbd833_de2a0515
UUID: aadf6a22_6153f0c5
Bytes: 146
This still optimizes individual halfs of and-long where we do not do the simplification. I've even added the "disassembly (after)" tests for this.

4984:2-4993:3
Wed Oct 14 11:29:45 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: aadf6a22_6153f0c5
UUID: 2a27faf5_cd84bd4c
Bytes: 84
(See the checker tests with longs where I assert that there's only one and/orr/eor.)

5004:2-5013:3
Tue Oct 13 21:38:50 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 7fa9b65d_516cc7bb
Bytes: 6
Ditto.

5004:2-5013:3
Wed Oct 14 11:22:11 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7fa9b65d_516cc7bb
UUID: 2a27faf5_8d7ac5ef
Bytes: 6
Ditto.

