Revision: e432f9a1b4aee99697c7cc15bb0c749df45cc9e0
Patch-set: 9
File: compiler/optimizing/nodes.cc

2103:10-2103:12
Tue Nov 17 23:40:57 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 5b2a4b7b_053a56a2
Bytes: 169
you could let this fall into the code at L2114 if you set the HBoolean in another else, but perhaps the code size savings are not worth the extra complexity reading this

2103:10-2103:12
Wed Nov 18 01:11:47 2015 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 5b2a4b7b_053a56a2
UUID: 1b3453db_6735a285
Bytes: 62
Unless someone complains, I will leave as is, for readability.

2113:2-2113:3
Wed Nov 18 10:11:03 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b67fde4b_b5f4d8f4
Bytes: 6
else {

2113:2-2113:3
Wed Nov 18 20:16:42 2015 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b67fde4b_b5f4d8f4
UUID: 7b6aafda_4349490a
Bytes: 194
Actually, this is meant to fall through, as then HBooleanNot is generated.  Otherwise, any bogus Int value would be a problem.

Or do you want me to DCHECK(false) because the value isn't 0 or 1?

2113:2-2113:3
Wed Nov 18 21:37:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7b6aafda_4349490a
UUID: 96865a95_ef44cd9d
Bytes: 129
I don't understand. You're already DCHECKING it's either 0 and 1 and you return from all branches above. Where's the fallthrough?

File: compiler/optimizing/nodes.h

5749:14-5749:37
Tue Nov 17 23:40:57 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 3b2597a9_043edab6
Bytes: 8
like it!

5749:14-5749:37
Wed Nov 18 10:11:03 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 169a6aee_257df4c4
Bytes: 43
Please put this method on the HGraph class.

5749:14-5749:37
Wed Nov 18 20:16:42 2015 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 169a6aee_257df4c4
UUID: 5b2a4b7b_f1026c4c
Bytes: 4
Done

File: test/458-checker-instruction-simplification/src/Main.java

1250
Wed Nov 18 12:12:12 2015 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 3b4e7783_cb610917
Bytes: 464
I understand you're trying to test the same test case you saw in the benchmark but I'd much rather see simple unit tests here which exercise both NotEquals[x,0] and Equals[x,1] and the individual execution paths through InsertOppositeCondition.

My main rationale is that code like this heavily depends on the DEX code generated from Java which will be different when we switch to Jack, in which case we might end up exercising even less of the code you're adding.

1250
Wed Nov 18 20:16:42 2015 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 3b4e7783_cb610917
UUID: fb75bfb9_fc64b828
Bytes: 276
No, I actually wanted to test this with a simpler test case, but I was unable to create the necessary input HIR.  Note that this is the 'after_bce' version of the simplifier.  We don't get the matching HIR until well into the optimization.

I will work on a smaller test case.

