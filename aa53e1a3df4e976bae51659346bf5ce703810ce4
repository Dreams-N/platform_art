Revision: aa53e1a3df4e976bae51659346bf5ce703810ce4
Patch-set: 4
File: compiler/dex/verified_method.h

116:33-116:41
Wed Apr 29 09:54:29 2015 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 30375a6d_359408bb
Bytes: 16
Why this change?

116:33-116:41
Fri Jun 05 01:07:10 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 30375a6d_359408bb
UUID: 90fd66eb_1c3f9587
Bytes: 42
Fixes a warning about an initialized field

File: runtime/dex_instruction-inl.h

458:52-458:66
Tue Apr 28 16:49:40 2015 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 90e3a61e_b5e342ce
Bytes: 126
Your max is really 4 so you should use a separate constant. In the verifier, we'll need to check there is at most 4 arguments.

458:52-458:66
Tue Apr 28 18:58:31 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 90e3a61e_b5e342ce
UUID: d0d99e70_23a02719
Bytes: 774
I'm personally not a fan of how my code turned out either (I wrote the smali encoding much much before I saw any of this code here).

What if (in a future CL) I changed it to be more like 35x, always var-args up to 5, but change the verifier to say that it must be *at least 1* to encode the requirement that one of the registers is omnipresent?

I'm not sure about changing this constant for now, I am able to reuse most of the GetVarArgs calling code as well because they both take an array of the same size. If I add a new constant kMaxVarArgs = 4, I'd have to redo the rest of the code to handle different sized arrays.

Maybe this function name could be renamed instead to differentiate it from a regular var arg, like GetAllRegisters25x or something along those lines?

465:10-465:12
Tue Apr 28 16:49:40 2015 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 90e3a61e_95e846ab
Bytes: 214
I don't understand why you don't follow the format 35c here. For me, the difference is you have a closure/reference instead of a method index, right?

You could have vA=count, vB=closure register, {vC,...,vG}=args.

465:10-465:12
Tue Apr 28 18:58:31 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 90e3a61e_95e846ab
UUID: b0d42a38_491b4e2c
Bytes: 255
This one doesn't take a type ID like 35c does, and it also needs only 2 bytes to encode.

If you are saying I should include the type id -- then that's certainly a possibility, and I may want to include the type id here to make it easier for the verifier.

465:10-465:12
Wed Apr 29 09:54:29 2015 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b0d42a38_491b4e2c
UUID: 30375a6d_950cf4f0
Bytes: 864
My point is the only difference between an invoke-lambda and other invoke-XXX instructions is you have a closure register index instead of a method index. But yes, because of that difference, you should use a different format (35x?).

However, I still recommend having vA=args count, vB=closure register index and [vC,...,vG]=args because it also adheres to how the verifier checks invoke arguments (see line 864 of https://android.googlesource.com/platform/art/+/master/runtime/verifier/method_verifier.cc).

For the verification itself, you definitely need to know the method index. The create-lambda already has it so I wonder if we can rely on its existence right before the invoke-lambda? Otherwise, you'll need to add it in the invoke-lambda and the format would become vA=args count, vB=method index, [vC,...,VG]=args *always with* vC=closure register index

465:10-465:12
Fri Jun 05 01:07:10 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 30375a6d_950cf4f0
UUID: 300cbaed_39042fcf
Bytes: 510
Thanks for the recommendation, I will definitely go ahead and change the format as you suggested (not sure about whether it needs a method index yet). That is a very helpful insight.

Is it ok if I fix it in a later CL once I'm adding verification support, and for the time being leave in a TODO here with your suggestion? It's a bit of a large change to do it now because smali already has all the support, plus I'm not actually 100% sure if we'll need the method id (or for example a class id) at this point.

465:10-465:12
Fri Jun 05 09:39:04 2015 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 300cbaed_39042fcf
UUID: 39b828d4_1c637993
Bytes: 579
If you change that in a later CL, please mention it in the commit message so it's obvious this is only a first part.

I'd prefer we do not leave a "temp" DEX format in the code to avoid anyone from using it while the lambda support is not complete yet (at least interpreter and verifier). But if it makes your life easier then go for it.

I think we should have a flag (kEnableLambdaOpcodes?) saying whether lambda support is enabled. It would remain false until the support is complete. You would only set it to true locally (and never merge it) to continue your work. Opinions?

File: runtime/dex_instruction_list.h

265:92-265:103
Tue Apr 28 16:49:40 2015 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 90e3a61e_55b41ec0
Bytes: 79
This also needs kVerifyVarArgNonZero (or kVerifyVarArg if there may be no args)

268:10-268:73
Tue Apr 28 16:49:40 2015 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 30375a6d_f531c01e
Bytes: 26
I think they're fine here.

269:6-269:79
Tue Apr 28 16:49:40 2015 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 500f6eb1_d3aa5efc
Bytes: 64
If it is not used, we should remove it (in a separate CL though)

269:6-269:79
Tue Apr 28 18:58:31 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 500f6eb1_d3aa5efc
UUID: f0f222e5_47fa24f5
Bytes: 42
Ok, I'll try to remove this in a future CL

File: runtime/interpreter/interpreter.h

52:16-52:49
Tue Apr 28 16:49:40 2015 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 30375a6d_75fff0a7
Bytes: 157
It's defined in the interpreter.cc file. However, it seems it is still defined in art::interpreter namespace while we declare in the art namespace only here.

52:16-52:49
Tue Apr 28 18:58:31 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 30375a6d_75fff0a7
UUID: d0d99e70_638cef8c
Bytes: 190
Yep, eclipse had a trouble finding it because of the namespaces.

FWIW putting "extern "C"" inside a namespace doesn't seem to do anything, it just erases the namespace from the symbol name.

File: runtime/interpreter/interpreter_common.cc

511:63-511:69
Tue Apr 28 16:49:40 2015 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 500f6eb1_d305be97
Bytes: 12
DoCallCommon

657:9-657:85
Tue Apr 28 16:49:40 2015 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 90e3a61e_957a866f
Bytes: 333
It's an optimization for the interpreter. It contains the 1st 16-bits loaded to know the opcode (low 8 bits) so we don't need to reload them to access vA (number of args for invoke-XXX)

However, this used to be useful when this method was inlined. Because of stack space issue, it is no longer inlined so this may no longer be true.

657:9-657:85
Tue Apr 28 18:58:31 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 90e3a61e_957a866f
UUID: d0d99e70_c3684322
Bytes: 365
As far as I can tell you would still need to switch inside of the GetVarArgs function because inst_data could either be the 0th short or the 1st short 

Unless it always assumes its being passed in the 1st short, but then you won't get the 5th register...

Anyway since 5 registers can't be encoded in a single short for 35x, I just am not sure what the intent was.

File: runtime/interpreter/interpreter_common.h

140:75-141:37
Tue Apr 28 16:49:40 2015 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 90e3a61e_d5992e53
Bytes: 31
Should be wrapped to next line.

177:5-177:77
Wed Apr 29 10:21:05 2015 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 90e3a61e_a0754278
Bytes: 117
Beware https://android-review.googlesource.com/148090 where ArtMethod is no longer a Java object but a native object.

177:5-177:77
Fri Jun 05 01:07:10 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 90e3a61e_a0754278
UUID: 90fd66eb_bcc8212a
Bytes: 92
Yep, thanks for bringing that up. I think the unit tests will just fail at that point right?

177:5-177:77
Fri Jun 05 09:39:04 2015 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 90fd66eb_bcc8212a
UUID: 39b828d4_3c04bd1c
Bytes: 136
I believe so. You will have a *native* object in the shadow frame which has no sense. Plus the GC will crash when visiting that pointer.

177:5-177:77
Fri Jun 05 18:01:24 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 39b828d4_3c04bd1c
UUID: 99e914d2_96ecbc41
Bytes: 106
That's ok, the latest PS supports the native ArtMethods, I just store them as non-reference vregs instead.

File: runtime/interpreter/interpreter_goto_table_impl.cc

2405:4-2405:27
Tue Apr 28 16:49:40 2015 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 90e3a61e_75903a1a
Bytes: 173
Not sure this is needed here. This is used to interpret with instrumentation (especially when debugger is active). I don't think the instruction will impact instrumentation.

2405:4-2405:27
Tue Apr 28 18:58:31 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 90e3a61e_75903a1a
UUID: f0f222e5_07af7ce4
Bytes: 88
Is it safe to leave in or a correctness issue? What file should I look at to learn more?

2405:4-2405:27
Wed Apr 29 09:54:29 2015 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f0f222e5_07af7ce4
UUID: 30375a6d_55166cfc
Bytes: 639
The idea behind this "update" was to being able to attach a debugger at any time during app execution. So when returning from a method (after a debugger attached or detached), we would switch to interpret with the "alternative" instruction handlers that support debugging (if attached) or get back to "normal" handlers (that do not support debugging).

Can CREATE_LAMBDA cause method invocation? If yes, this probably needs to stay.

You can take a look at the definitions of these alternative handlers (below, at the end of this method) with macro INSTRUMENTATION_INSTRUCTION_HANDLER. And you can take a look at Instrumentation::IsActive.

2405:4-2405:27
Fri Jun 05 01:07:10 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 30375a6d_55166cfc
UUID: 90fd66eb_1c9795c2
Bytes: 124
Removed UPDATE_HANDLER_TABLE.

create-lambda cannot cause a method invocation. However invoke-lambda can so I left it there.

2405:4-2405:27
Fri Jun 05 09:39:04 2015 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 90fd66eb_1c9795c2
UUID: 19afe490_1b045f85
Bytes: 4
SGTM

File: runtime/stack.h

91:9-91:59
Tue Apr 28 16:49:40 2015 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 500f6eb1_331f7ae3
Bytes: 49
This is an artifact of Portable compiler removal.

324:9-324:94
Tue Apr 28 16:49:40 2015 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 90e3a61e_358ab2ec
Bytes: 72
Why micro-optimization? This avoids an indirection when accessing vregs.

324:9-324:94
Tue Apr 28 18:58:31 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 90e3a61e_358ab2ec
UUID: d0d99e70_06c899a4
Bytes: 87
That's why I was asking. It just makes the code harder to understand the way it is now.

File: test/run-test

0
Wed Apr 29 09:54:29 2015 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 500f6eb1_5edaf5eb
Bytes: 44
I think you should do that in a separate CL.

