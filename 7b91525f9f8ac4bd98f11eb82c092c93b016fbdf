Revision: 7b91525f9f8ac4bd98f11eb82c092c93b016fbdf
Patch-set: 1
File: compiler/optimizing/intrinsics_x86.cc

2388:0-2423:1
Tue Feb 02 11:10:23 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 9143cc4f_5225d252
Bytes: 114
Could we replace the call to actual HInstruction? We already do optimizations around long/float/double compares...

2388:0-2423:1
Tue Feb 02 17:17:00 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 9143cc4f_5225d252
UUID: 5116b490_85f8e22d
Bytes: 212
Replacing intrinsics with HIR has certain advantage (like better folding), but keeping the exact semantics of an intrinsic has certain advantages too. In this case probably the latter wins, at least for e.g. arm.

2388:0-2423:1
Tue Feb 02 18:07:20 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 5116b490_85f8e22d
UUID: d1b8e4d6_597ee38d
Bytes: 58
what advantages for the intrinsics? Which exact semantics?

2388:0-2423:1
Tue Feb 02 21:21:46 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d1b8e4d6_597ee38d
UUID: 11e51cf3_3b62f7ec
Bytes: 5
ping?

2388:0-2423:1
Tue Feb 02 21:35:34 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d1b8e4d6_597ee38d
UUID: 31fce07c_d240e43b
Bytes: 790
Well, unless you map the intrinsic to a very specific HIR node, something like signum allows us to do a single test followed by two conditional jumps on the same condition code. If you rewrite this into the HIR equivalent of (x == 0 ? 0 : (x > 0) ? 1 : -1)) you get two cmp instructions. Of course we can pattern match on this and avoid it, but hopefully you get my point.

Note that I tried to bring this up a few days back, but I don't think I made my email very clear. I was bringing up we have several paths (method call -> inlined -> codegen, method  call -> intrinsic -> HIR -> codegen and method call -> intrinsic  -> instrinsic codegen). All make certain things simpler, but ultimately all could in theory yield the same code. So I was asking for a preference, but did not hear any.

2388:0-2423:1
Tue Feb 02 21:43:17 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 31fce07c_d240e43b
UUID: f1cc087f_e26aa6bd
Bytes: 226
It's not signum I was interested about, but compare. I agree for most intrinsincs we don't want IR, but for compare we can easily map it to existing HInstructions. And where we already know when to not materialize the compare.

2388:0-2423:1
Tue Feb 02 21:52:11 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f1cc087f_e26aa6bd
UUID: 3115c084_e7db9c9a
Bytes: 255
Ah, you mean HCompare specifically? That would make sense yes. Not sure why I overlooked that particular case, but our codegen seems very similar indeed (although not all types are implemented in either case). Okay, I can unify that in a follow up CL yes.

2388:0-2423:1
Tue Feb 02 21:54:11 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 3115c084_e7db9c9a
UUID: d1b8e4d6_b921bf7d
Bytes: 14
Yes, thanks :)

2680:13-2680:45
Tue Feb 02 10:24:47 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 317b00b0_14e87430
Bytes: 186
This is valid for the long case as well.

And if you special-case this here, you should also special-case this in the CreateSignLocations() to avoid the unnecessary register allocations.

2680:13-2680:45
Tue Feb 02 17:17:00 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 317b00b0_14e87430
UUID: 31c3005d_147434ae
Bytes: 51
Yes, fair enough. This was a bit half-baked. Fixed.

