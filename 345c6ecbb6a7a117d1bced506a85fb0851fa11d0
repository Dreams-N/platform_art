Revision: 345c6ecbb6a7a117d1bced506a85fb0851fa11d0
Patch-set: 1
File: compiler/dex/quick/gen_invoke.cc

592:14-592:29
Tue Jul 29 19:37:03 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 7937e4c3_0343a278
Bytes: 27
Why not for x86 and x86_64?

592:14-592:29
Wed Jul 30 18:33:33 2014 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7937e4c3_0343a278
UUID: 1624f7a2_f3d16790
Bytes: 133
The x86 call instruction includes a load from the quick entry point from the method object, so there is no need to do this load here.

592:14-592:29
Thu Jul 31 03:18:49 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1624f7a2_f3d16790
UUID: 16295785_748c402a
Bytes: 147
I don't understand, aren't you optimizing the call sequence to load from the vtable instead? Why isn't the call sequence homogeneous between archs?

592:14-592:29
Thu Jul 31 17:58:17 2014 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 16295785_748c402a
UUID: 16295785_88fb0be0
Bytes: 241
It's true x86 can do the same thing. However that requires more code change since the final call instruction generation is shared by virtual call, static call, etc. and the improvement needs to be measured. I'll leave it to some future task.

