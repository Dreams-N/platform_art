Revision: 8bd43173c02355500e9b356f22461dad4cc70511
Patch-set: 5
File: compiler/optimizing/code_generator_arm64.cc

205
Mon Jan 19 12:09:56 2015 +0000
Author: Alexandre Rames <1052304@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: cbd63fdb_b423ae11
Bytes: 44
Maybe
   if (mem_op.IsImmediateOffset()) {
?

205
Tue Jan 20 22:57:20 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cbd63fdb_b423ae11
UUID: 6bf1d3a1_6eccaffa
Bytes: 4
Done

208
Mon Jan 19 12:09:56 2015 +0000
Author: Alexandre Rames <1052304@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: cbd63fdb_34d1fe8f
Bytes: 49
Change to
    DCHECK(mem_op.IsRegisterOffset();
?

208
Tue Jan 20 22:57:20 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cbd63fdb_34d1fe8f
UUID: 6bf1d3a1_4ed1f38e
Bytes: 4
Done

1025
Mon Jan 19 12:09:56 2015 +0000
Author: Alexandre Rames <1052304@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: cbd63fdb_74c786d9
Bytes: 96
What about using only one line?
    __ Add(temp_base, src.base(), OperandFromMemOperand(src));
?

1025
Tue Jan 20 22:57:20 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cbd63fdb_74c786d9
UUID: 6b6c7315_3cb81999
Bytes: 4
Done

File: compiler/optimizing/intrinsics_arm64.cc

87
Mon Jan 19 16:44:27 2015 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4b408f75_3d0acfc8
Bytes: 29
XRegisterFrom() DCHECKs this.

87
Mon Jan 19 19:36:40 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4b408f75_3d0acfc8
UUID: eb586371_602946ac
Bytes: 198
This was more in line with the style of the other helpers, and gives better error reporting (don't have to look at a trace to figure out what is actually wrong), but I'll change it for tighter code.

479
Mon Jan 19 16:44:27 2015 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4b408f75_fd798730
Bytes: 66
No temp needed from the register allocator - see my comment below.

488
Mon Jan 19 16:44:27 2015 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: cbd63fdb_f43ff6f3
Bytes: 308
I suggest we get this temp from VIXL (d/s31). Also we can rename this to temp (instead of temp1).

eg:

UseScratchRegisterScope temps(GetVIXLAssembler());
FPRegister temp = AcquireSameSizeAs(in_reg);


This way we will reuse VIXL's FP temp - D/S 31, instead of using asking the register allocator for a temp.

488
Mon Jan 19 19:36:40 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cbd63fdb_f43ff6f3
UUID: ab52eb4e_bb0d535e
Bytes: 81
Your choice. I'm not up to speed about how many registers are reserved by VIXL...

488
Tue Jan 20 10:58:01 2015 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ab52eb4e_bb0d535e
UUID: 4b408f75_60e02ca2
Bytes: 631
See code_generator_arm64.h. Currently we block 2 GP regs and 1 FP reg.

const vixl::CPURegList vixl_reserved_core_registers(vixl::ip0, vixl::ip1);
const vixl::CPURegList vixl_reserved_fp_registers(vixl::d31);

This will enable the VIXL MacroAssembler handle any sort of immediate field for most of the instructions. 

In both cases mentioned here it is safe to use the VIXL blocked registers. The instructions generated inside the scope do not need any extra temp registers.

In the cases where we get this wrong we should hit the VIXL_CHECK() in:
CPURegister UseScratchRegisterScope::AcquireNextAvailable(CPURegList* available) {}

488
Tue Jan 20 22:57:20 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4b408f75_60e02ca2
UUID: cb5d5f61_ff305706
Bytes: 4
Done

491
Mon Jan 19 16:44:27 2015 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4bc24f1f_133df4df
Bytes: 188
Both variants can be encoded in the immediate field.

Anyway a misuse will be caught in a debug version of ART. libvixld asserts when it tries to use a temp register and none is available.

491
Mon Jan 19 19:36:40 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4bc24f1f_133df4df
UUID: 8b57e740_fa306506
Bytes: 248
Vixl has this with double and float signature. Should I not make it obvious here (Quick says the encoding is the same and relies and this, though)? (It's somewhat contradicting with the "we don't want to allow encodings for stuff that has aliases")

491
Tue Jan 20 10:58:01 2015 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8b57e740_fa306506
UUID: 4bc24f1f_961d525a
Bytes: 310
I would leave it as it is.

I have mentioned the fact that they can be encoded in the immediate field since otherwise the macro assembler would place it in the literal pool. 

Other instructions like Fcmp() would use the extra FP temp - D/S31 if the immediate field cannot be encoded in the instruction stream.

624
Mon Jan 19 16:44:27 2015 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4bc24f1f_338590e6
Bytes: 127
Should this be a WRegister for kPrinNot too? (I guess that this should be the case if we decide to use 32bit regs "in flight").

624
Mon Jan 19 19:36:40 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4bc24f1f_338590e6
UUID: eb586371_c00db25d
Bytes: 56
Yes, I'll change all the occurrences of object pointers.

650
Mon Jan 19 16:44:27 2015 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4bc24f1f_d3b76cc6
Bytes: 136
This is the register that we use in LoadAcquire() - temp_base ?

We get that one from a different register poll (VIXL temps - IP0, IP1).

650
Mon Jan 19 19:36:40 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4bc24f1f_d3b76cc6
UUID: 8b57e740_da2da1ae
Bytes: 51
Stale comment, after I added code to LoadAcquire...

744
Mon Jan 19 16:44:27 2015 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4bc24f1f_338cb018
Bytes: 162
kUseAcquireRelease variant ?

I need to understand what is_ordered guarantees. We might need to enforce ordering through a DMB even for a acquire-release variant.

744
Mon Jan 19 19:36:40 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4bc24f1f_338cb018
UUID: eb586371_e0143666
Bytes: 112
Variant will be added. As ordered is weaker than volatile, I think it's easiest just to use the volatile code...

744
Tue Jan 20 22:57:20 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: eb586371_e0143666
UUID: 6b6c7315_1c1efdd1
Bytes: 4
Done

787
Mon Jan 19 16:44:27 2015 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: cbd63fdb_17239c98
Bytes: 33
Add a comment ? // Unused this* ?

787
Tue Jan 20 22:57:20 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cbd63fdb_17239c98
UUID: 6b6c7315_fcbfc12a
Bytes: 4
Done

795
Mon Jan 19 16:44:27 2015 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4b408f75_00ffa8bd
Bytes: 46
No need for temps here - see my comment below.

810
Mon Jan 19 16:44:27 2015 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4b408f75_a0019431
Bytes: 286
Here we can use VIXLs temps IP1, IP0. This should be perfectly safe and should put less pressure on the Optimizing Compiler register allocator. 

UseScratchRegisterScope temps(GetVIXLAssembler());
Register tmp_ptr = temps.AcquireX();
Register tmp_value = temps.AcquireSameSizeAs(value);

810
Tue Jan 20 22:57:20 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4b408f75_a0019431
UUID: 6b1ab3b5_260016f8
Bytes: 193
Not super-happy with all the (hidden) interactions. E.g., when writing this code, it is *not* obvious that MarkGCCard also wants temps. So this only works when moving the temp registers down...

812
Mon Jan 19 16:44:27 2015 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: cbd63fdb_37282070
Bytes: 68
no need. value is a W for kPrimNot, not like in Quick where it is X.

813
Mon Jan 19 16:44:27 2015 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4b408f75_5da35b0e
Bytes: 5
ditto

821
Mon Jan 19 16:44:27 2015 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: cbd63fdb_d73c34b4
Bytes: 121
Operand(offset) ?

One of the Operand constructors:
 Operand(Register reg, Shift shift = LSL, unsigned shift_amount = 0);

831
Mon Jan 19 16:44:27 2015 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4b408f75_80ebb805
Bytes: 11
tmp_value ?

835
Mon Jan 19 16:44:27 2015 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: cbd63fdb_57a4c498
Bytes: 6
value?

837
Mon Jan 19 16:44:27 2015 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4bc24f1f_13b89466
Bytes: 41
Cbnz(tmp_32, &loop_head);

Gblame me :-).

837
Mon Jan 19 19:36:40 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4bc24f1f_13b89466
UUID: ab52eb4e_3b430377
Bytes: 58
Micro-optimizations once stuff is done. Premature ...  ;-)

File: compiler/optimizing/intrinsics_arm64.h

75
Mon Jan 19 12:09:56 2015 +0000
Author: Alexandre Rames <1052304@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4bc24f1f_b0ae56f0
Bytes: 179
In the codegen we have GetAssembler() and GetVIXLAssembler(). Should we name this one GetVIXLAssembler() for coherency, or do you prefer this one to stay in line with other archs?

75
Mon Jan 19 19:36:40 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4bc24f1f_b0ae56f0
UUID: 8b57e740_3a6c9df7
Bytes: 37
Coherency is not a must. Will change.

75
Tue Jan 20 22:57:20 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8b57e740_3a6c9df7
UUID: cb5d5f61_5f2983ab
Bytes: 4
Done

