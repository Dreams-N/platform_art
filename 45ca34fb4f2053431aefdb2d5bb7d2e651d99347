Revision: 45ca34fb4f2053431aefdb2d5bb7d2e651d99347
Patch-set: 1
File: compiler/optimizing/code_generator_x86.cc

3772:0-3799:1
Tue Mar 31 21:18:40 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a315c284_93565eb1
Bytes: 103
Does this make sense? You haven't really improved things over the previous double-call of Exchange32...

3772:0-3799:1
Tue Mar 31 23:47:34 2015 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a315c284_93565eb1
UUID: 03d68e0c_43f8b84a
Bytes: 129
It is better because the scratch only is allocated once.  I have seen lots of push eax; moves; pop eax; push eax; moves; pop eax.

3772:0-3799:1
Wed Apr 01 00:08:50 2015 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 03d68e0c_43f8b84a
UUID: 63bd8ac9_c78f6ef8
Bytes: 117
Aren't the xchgl's implicitly locked and so operating as memory barriers too? Won't the memory barriers be expensive?

3772:0-3799:1
Wed Apr 01 01:33:29 2015 +0000
Author: Razvan A Lupusoru <1013855@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 63bd8ac9_c78f6ef8
UUID: a3da2233_5d57bb5f
Bytes: 158
This was my concern as well - we are checking this with some micros. I expect that this won't be a performance win since the xchg is microcoded on Silvermont.

