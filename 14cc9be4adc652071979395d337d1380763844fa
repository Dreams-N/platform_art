Revision: 14cc9be4adc652071979395d337d1380763844fa
Patch-set: 3
File: runtime/gc/heap-inl.h

58:9-58:20
Sat Jul 12 00:01:32 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1980a8c3_71c9af36
Bytes: 76
Move this declaration to the else block of the if statement where it's used?

65:4-65:7
Sat Jul 12 00:01:32 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1980a8c3_d161a388
Bytes: 117
Shouldn't be a problem as we checked the tlab size. But how about DCHECK(obj != nullptr) with a proper error message?

114:0-116:5
Sat Jul 12 00:01:32 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 79bfe48c_3ef8fd98
Bytes: 59
Do we want to have this check for the TLAB case above, too?

149:28-149:51
Sat Jul 12 00:01:32 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1980a8c3_91748b51
Bytes: 299
AllocatorTypeTLAB could be paired with a concurrent GC. When the TLAB path is taken above, new_num_bytes_allocated is zero here. Calling CheckConcurrentGC with with new_num_bytes_allocated == 0 seems odd. How about adding "&& new_num_bytes_allocated != 0" as the third component of the if condition?

234:21-234:46
Sat Jul 12 00:01:32 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 79bfe48c_9eb329ea
Bytes: 266
This means that we could throw an OOM a bit earlier with tlab allocator than before because we won't try to allocate into the fractional space at the end (in other words, we check OOM at the tlab granularity rather than at the individual object granularity) correct?

File: runtime/thread.h

784:19-784:35
Sat Jul 12 00:01:32 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 79bfe48c_deb681c4
Bytes: 66
Is this fixing an accounting bug? What's the significance of this?

