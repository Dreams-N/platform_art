Revision: bfb470d89b8f5d16581118a5b58f862b79496558
Patch-set: 4
File: /COMMIT_MSG

7:4-7:12
Wed Jul 08 14:58:57 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 782e1e92_eb0f3137
Bytes: 80
Explain what the HContext is in the commit comments and how it is gonna be used.

File: compiler/optimizing/context.h

10:52-10:79
Wed Jul 08 14:58:57 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 782e1e92_4b2ac588
Bytes: 176
this imply that nit HContext will traverse the graph for me which is not and should not be the case. It might be just a limitation of my language skills, but I'd rephrase this.

10:0-10:2
Wed Jul 08 14:58:57 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d829ca86_f4f030dc
Bytes: 52
style:
/*
 * docs...
 */

here, and everywhere else.

32:4-34:5
Wed Jul 08 14:58:57 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 782e1e92_4b908551
Bytes: 127
We should not eagerly allocate stuff. What if we decide to skip blocks?

We need a lazy solution for this and only when needed.

32:4-34:5
Wed Jul 08 17:07:18 2015 +0000
Author: Guillaume Sanchez <1068522@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 782e1e92_4b908551
UUID: 18f28255_26344267
Bytes: 100
I'm thinking about instantiating this lazily. Maybe this optimization should come in an upcoming CL?

32:4-34:5
Thu Jul 09 08:54:02 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 18f28255_26344267
UUID: d829ca86_b703ca42
Bytes: 222
Let's try to have it in this CL. Note that blocks may be delete along the way, which leaves you gaps in your storage (i.e. we might have graphs with non contiguos block ids) I can think of worst cases where we waste a lot.

32:4-34:5
Thu Jul 09 11:28:01 2015 +0000
Author: Guillaume Sanchez <1068522@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d829ca86_b703ca42
UUID: 18f28255_694e9d11
Bytes: 4
Done

46:11-46:13
Wed Jul 08 14:58:57 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 782e1e92_cb92355e
Bytes: 40
who is `ni`? i think you want `property`

46:11-46:13
Wed Jul 08 17:07:18 2015 +0000
Author: Guillaume Sanchez <1068522@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 782e1e92_cb92355e
UUID: 1840c241_16f61c89
Bytes: 4
Done

54:11-54:13
Wed Jul 08 14:58:57 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f8f4ce42_6296b8a0
Bytes: 5
ditto

54:11-54:13
Wed Jul 08 17:07:18 2015 +0000
Author: Guillaume Sanchez <1068522@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f8f4ce42_6296b8a0
UUID: f8f4ce42_a5ce0aa0
Bytes: 4
Done

59:39-59:42
Wed Jul 08 14:58:57 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 18f28255_e659bad1
Bytes: 45
what does res stand for? Maybe use old_value?

59:39-59:42
Wed Jul 08 17:07:18 2015 +0000
Author: Guillaume Sanchez <1068522@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 18f28255_e659bad1
UUID: f8f4ce42_65e2421a
Bytes: 4
Done

109:6-109:34
Wed Jul 08 14:58:57 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1840c241_d60c1445
Bytes: 76
resize will not give you the exact requested size. check the implementation.

109:6-109:34
Wed Jul 08 17:07:18 2015 +0000
Author: Guillaume Sanchez <1068522@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1840c241_d60c1445
UUID: 782e1e92_ebea919b
Bytes: 42
I know, it'll be bigger. Is that an issue?

109:6-109:34
Thu Jul 09 08:54:02 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 782e1e92_ebea919b
UUID: 782e1e92_0b903d9e
Bytes: 156
it is, cause the logic doesn't work as you want. Below you only initialize up to `idx+1` so the rest of the position up to the real size are not initialized

109:6-109:34
Thu Jul 09 11:28:01 2015 +0000
Author: Guillaume Sanchez <1068522@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 782e1e92_0b903d9e
UUID: 1840c241_b903c342
Bytes: 65
Oh right, GrowableArray has some unusual instantiation semantics.

109:6-109:34
Mon Jul 13 15:58:27 2015 +0000
Author: Guillaume Sanchez <1068522@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1840c241_b903c342
UUID: 1867e20f_58985d51
Bytes: 252
Actually, no. GrowableArray has a notion of "used" and "preallocated". Resize() reallocates the underlying container without changing the number of "used" cells, and Size() will return the number of used cells, not the size of the underlying container.

111:0-113:7
Wed Jul 08 14:58:57 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d829ca86_1415fc77
Bytes: 73
see my comment in the ctor of this function about wasting space for this.

111:0-113:7
Thu Jul 09 11:28:01 2015 +0000
Author: Guillaume Sanchez <1068522@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d829ca86_1415fc77
UUID: 782e1e92_8e6afbdf
Bytes: 4
Done

118:6-118:16
Wed Jul 08 14:58:57 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f8f4ce42_c2c584a0
Bytes: 210
What's the rationale for storing the current block?

I don't think it's ok to hold the state here. I can see a lot of confusion from this and imo is better to pass it as an argument when you set/get properties.

118:6-118:16
Wed Jul 08 17:07:18 2015 +0000
Author: Guillaume Sanchez <1068522@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f8f4ce42_c2c584a0
UUID: f8f4ce42_25155a78
Bytes: 162
It was about making the interface lighter since I was seeing the HContext in the context of a traversal, working on the current block. That might not be relevant.

File: compiler/optimizing/reference_type_propagation.cc

347:44-347:70
Wed Jul 08 14:58:57 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1840c241_d63534e3
Bytes: 10
IsStatic()

347:44-347:70
Wed Jul 08 17:07:18 2015 +0000
Author: Guillaume Sanchez <1068522@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1840c241_d63534e3
UUID: f8f4ce42_a5004a36
Bytes: 4
Done

348:4-348:47
Wed Jul 08 14:58:57 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d829ca86_345a3851
Bytes: 194
Hmm, is this correct?

a.foo() -> a can be null at this point
a.bar() -> a cannot be null at this point

yet after this call the context will think that a cannot be null during the entire block.

348:4-348:47
Wed Jul 08 17:07:18 2015 +0000
Author: Guillaume Sanchez <1068522@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d829ca86_345a3851
UUID: 782e1e92_0b527de0
Bytes: 286
At the moment we're inspecting a.foo(), a is marked as can be null. After this call, a is marked as cannot be null, and a.bar() has the correct info.

The fact is that I have a deeply dynamic vision of it, used during a traversal, while you're seeing as a static storage for properties.

348:4-348:47
Thu Jul 09 08:54:02 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 782e1e92_0b527de0
UUID: d829ca86_97e7ae22
Bytes: 200
As we discuss, if you go with the current approach you need to document it much better as it was not clear from the context. 
One thing to think about: how does this work with the fix point iteration?

348:4-348:47
Thu Jul 09 11:28:01 2015 +0000
Author: Guillaume Sanchez <1068522@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d829ca86_97e7ae22
UUID: 1867e20f_f8c4d185
Bytes: 164
During fix point iteration, since a loop is one of its own predecessor, so, by calling StartBlock() over and over again on the same block, it will work as expected.

File: compiler/optimizing/reference_type_propagation.h

30:43-30:48
Wed Jul 08 14:58:57 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1840c241_96168c4f
Bytes: 67
Shouldn't this be true? the default value should be the safe value.

30:43-30:48
Wed Jul 08 17:07:18 2015 +0000
Author: Guillaume Sanchez <1068522@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1840c241_96168c4f
UUID: 1840c241_566f04a8
Bytes: 132
No. The default value is the monoidal 0 wrt Merge. If you do not respect this, merging blocks is not a sound mathematical operation.

30:43-30:48
Thu Jul 09 08:54:02 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1840c241_566f04a8
UUID: 782e1e92_ab9ec9ae
Bytes: 341
What I think I'm missing from the big picture is:
- i would have imagine that Zero is the default value for what we don't know so it must be conservative. Am I'm wrong....?
- where is Zero actually used? I don't see anything. No use == No Need usually.
- to complement this: I don't see a few methods from HContext being used. Why have them?

30:43-30:48
Thu Jul 09 11:28:01 2015 +0000
Author: Guillaume Sanchez <1068522@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 782e1e92_ab9ec9ae
UUID: 18f28255_49bcf957
Bytes: 527
> i would have imagine that Zero is the default value for what we don't know so it must be conservative. Am I'm wrong....?

Yes. Zero is not a convenient default value. It is, as its name indicates, a Zero. It's called few times in the Context and guarantees that the datastructure and its operations are sound.

Some methods of the HContext are not used because they are not useful with a property beeing a boolean, but will be useful in other cases. MergeProperty() and SetProperty() are, in this case, strictly equivalent. I

30:43-30:48
Mon Jul 13 15:13:47 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 18f28255_49bcf957
UUID: 98e912d2_1f81a7d8
Bytes: 500
So right now you return Zero when you don't find the property in the context. I'm concerned that if that doesn't get updated this acts as an optimistic algorithm but which is not correct.

What happens for parameters? If you just use their values you will assume they cannot be null.

e.g.

void foo(Object a, Object b, boolean c) {
  Object x = null;
  if (c) {
    x = a;
  } else {
    x = b;
  }
  // I didn't run, but I think you will consider x to be not null here because of that.
  x.foo();
}

30:43-30:48
Mon Jul 13 15:58:27 2015 +0000
Author: Guillaume Sanchez <1068522@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 98e912d2_1f81a7d8
UUID: 38cf4674_e19e26b0
Bytes: 263
ParameterValue is an instruction. Then, it will be handled correctly by


    void RTPVisitor::VisitInstruction(HInstruction* instr) OVERRIDE {
      if (instr->GetType() == Primitive::kPrimNot) {
        ctx_.SetProperty(instr, instr->CanBeNull());
      }
    }

35:2-35:6
Wed Jul 08 14:58:57 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d829ca86_342918c2
Bytes: 5
const

35:2-35:6
Wed Jul 08 17:07:18 2015 +0000
Author: Guillaume Sanchez <1068522@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d829ca86_342918c2
UUID: f8f4ce42_455a9e51
Bytes: 4
Done

