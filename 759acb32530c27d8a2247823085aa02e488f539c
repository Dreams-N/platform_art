Revision: 759acb32530c27d8a2247823085aa02e488f539c
Patch-set: 5
File: compiler/optimizing/licm_test.cc

109:20-109:38
Wed Sep 30 21:51:04 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d55b5e6b_626e6cc5
Bytes: 102
I am personally okay with this layout, but I don't we have the one per line convention when broken up?

File: compiler/optimizing/load_store_elimination.cc

30:35-30:36
Wed Sep 30 21:51:04 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d55b5e6b_2208f4f3
Bytes: 31
this seems to fit on same line.

31:24-31:25
Wed Sep 30 21:51:04 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b5398a03_4686e6e4
Bytes: 56
why don't you put these in the initializer list as well?

38:4-38:7
Wed Sep 30 21:51:04 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 15a33681_69832193
Bytes: 144
Why don't you document the code a bit more, especially loops typically need explanation.

// Visit all uses to determine if this reference .....

72:24-72:30
Wed Sep 30 21:51:04 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b5398a03_e6a0da5d
Bytes: 81
First document what function means, then list possible implications like this one

112:47-112:48
Wed Sep 30 21:51:04 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 354d9aaf_62ab1274
Bytes: 13
class' (no s)

130:59-130:66
Wed Sep 30 21:51:04 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 15a33681_696c818d
Bytes: 152
typo: unknown

Is this the "bottom" value in a lattice of heap information? If so, perhaps that term is a bit more common than the very generic unknown?

149
Wed Sep 30 21:51:04 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 354d9aaf_e296023e
Bytes: 86
DCHECK(ref != nullptr) on entry perhaps
(since this is a general utility in this file)

165:46-165:47
Wed Sep 30 21:51:04 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b5398a03_2659222b
Bytes: 30
9 -> descriptive constant name

179:17-179:36
Wed Sep 30 21:51:04 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f5586271_a32d286f
Bytes: 209
this method makes me wonder if you should not choose something different for ref_info_array_ (hash table or so). Since you restrict the # anyway, having a slightly larger size for faster lookup may be worth it

238:18-238:19
Wed Sep 30 21:51:04 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d55b5e6b_c29138da
Bytes: 14
move decl down

254:50-254:57
Wed Sep 30 21:51:04 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 15a33681_e9a5d116
Bytes: 29
already and pre- is redundant

261:19-261:21
Wed Sep 30 21:51:04 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b5526a4f_1e8a6d0d
Bytes: 38
return .... >=
to make it more concise

271:4-271:5
Wed Sep 30 21:51:04 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1548969f_84d3ccf2
Bytes: 23
else if
else if
else if

288:93-288:94
Wed Sep 30 21:51:04 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 15a33681_6917a1e1
Bytes: 13
period at end

324:33-324:35
Wed Sep 30 21:51:04 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 75439281_070fbc69
Bytes: 66
I would phrase this the other way:

Different indices do not alias

365:8-365:31
Wed Sep 30 23:50:49 2015 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b5526a4f_21d8f45d
Bytes: 194
I don't think there's actually a reason to bail on volatile stores, if you just bail on loads.  It's perfectly OK to reuse a value that was stored or loaded before an intervening volatile store.

432:4-432:28
Wed Sep 30 23:50:49 2015 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1548969f_4f3d5da3
Bytes: 435
Ditto here.  Monitor entry is a problem.  Reusing results from before monitor entry amounts to moving operations out of the critical section, which is bad.  Reusing results from before monitor exit amounts to moving them in, which is OK.

This assumes you always eliminate the later load or store.
It also assumes you don't optimize volatile operations themselves.

And it ignores the Java memory model bugs that we customarily ignore.

754:24-754:36
Wed Sep 30 21:51:04 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 9555663b_fd817f35
Bytes: 47
here and all other visit method, add:

OVERRIDE

809:17-809:42
Wed Sep 30 21:51:04 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 9555663b_ddd0fb5b
Bytes: 160
this is a rather important constant

perhaps move it in the class, or to top of file, and document what the restriction does, and why this value has been chosen

814:54-814:58
Wed Sep 30 21:51:04 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f5586271_c31bfc36
Bytes: 127
can't you return here as soon as HasVolatile or HasMonitorOps is true to save wasted work in case you are going to bail anyway?

828:31-828:32
Wed Sep 30 21:51:04 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 75439281_84c0ea8d
Bytes: 211
For the future, would it be possible to cap the number of load/stores that are considered, rather than bailing out completely (i.e. the first 100 fields are analyzed, all others are assumed to be unoptimizable)?

File: compiler/optimizing/load_store_elimination.h

34
Wed Sep 30 21:51:04 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d55b5e6b_623caca5
Bytes: 135
typo in name Elimination (not Eliminiation)

also, isn't the convention to keep this field private, since it is passed to super anyway?

File: test/530-checker-lse/src/Main.java

539:29-539:31
Wed Sep 30 21:51:04 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 354d9aaf_622032d8
Bytes: 78
I would recommend

 = { 0.8f } ;

instead of the new/assignment construct (2x)

