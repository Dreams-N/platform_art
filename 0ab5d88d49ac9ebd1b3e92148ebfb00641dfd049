Revision: 0ab5d88d49ac9ebd1b3e92148ebfb00641dfd049
Patch-set: 1
File: compiler/dex/compiler_enums.h

538:2-538:9
Mon Jul 07 04:15:12 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c498e5f7_e2c782d9
Bytes: 144
Wide32 seems strange to me. I understand what you meant but it looks like wide is overloaded here. Can we do something like kNoneWide and KWide?

538:2-538:9
Mon Jul 07 05:04:17 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c498e5f7_e2c782d9
UUID: c4462542_4f8eb16b
Bytes: 186
I had that before and changed it. The issue is that ref registers are "wide" on 64b systems. So reading kNonWide in the code is ambiguous, too, without changing the name of the function.

538:2-538:9
Mon Jul 07 05:10:51 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c4462542_4f8eb16b
UUID: 043d9d9e_f15742fe
Bytes: 119
I guessed that this enum is not for refs. For refs we use TargetRefReg function without specifying wide kind, isn't it?

540
Sat Jul 05 10:19:28 2014 +0000
Author: Matteo Franchin <1037505@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 445eb5fe_5edba5f8
Bytes: 130
That's good. I disliked the true/false. Also, we may end up needing more than the 32 and 64 bit views (e.g. for vector registers).

File: compiler/dex/quick/gen_invoke.cc

302:33-302:77
Sat Jul 05 01:11:05 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4485d588_86b96e65
Bytes: 150
Note: this looks strange to me. That looks like on ARM we have a mixed soft-hard-float convention. arg0 is in farg0 if fp, but arg1 is always in arg1.

302
Sat Jul 05 10:19:28 2014 +0000
Author: Matteo Franchin <1037505@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4485d588_86b96e65
UUID: c498e5f7_a23f3a4d
Bytes: 890
The first time I looked at this function I could not make sense of it. I preferred to split out the Arm64 case, rather than trying to extend the old (and pretty entropic) logic. I suspect for Arm (32-bit) we may never happen to call the function in a way where the hard/soft float mix matters. In other words, parts of this function may turn out to be dead code. As a positive side, the function is now hugely improved. One thing that may further help to clean up the code, is introducing a TargetArgReg(int n, RegLocation rl) which returns the n-th argument having the same "type" of rl (and would have a trivial implementation for Arm64). Another thing - that affects the whole quick compiler - is the wide/non-wide variants of functions. The code is literally scattered with

  if (wide) UseWideVariant(); else UseNonWideVariant();

But, addressing this issue is a huge refactoring task.

302
Sat Jul 05 17:53:03 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c498e5f7_a23f3a4d
UUID: e4c6c9d8_278369b6
Bytes: 108
I totally agree with you here and had the same thoughts, but this was a small and contained refactoring. :-)

File: compiler/dex/quick/mir_to_lir.h

1203:8-1203:81
Mon Jul 07 04:15:12 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 043d9d9e_d1524611
Bytes: 91
Could you please update a doc indicating that for wide case reg is expected to be only arg?

1203:8-1203:81
Mon Jul 07 05:04:17 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 043d9d9e_d1524611
UUID: 04cafddd_41b5b1b8
Bytes: 449
The main question here is: when can you expect to get a correct result on a 32b system? My first attempt here was "when wide registers are a pair of consecutive registers," for which the arg regs made sense. I would have thought we need ret, too, for long returns, but I did not find such a use case in the code.

So my try at documentation would be: must be k(F)Arg0-6 when on a 32b system, or any abstract register when on 64b.

What do you think?

1203:8-1203:81
Mon Jul 07 05:10:51 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 04cafddd_41b5b1b8
UUID: c498e5f7_22b24a84
Bytes: 142
I want doc is aligned with specification here. So if you allow only args for both fp and core and you have doc, doc should reflect this check.

