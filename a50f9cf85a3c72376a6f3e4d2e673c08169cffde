Revision: a50f9cf85a3c72376a6f3e4d2e673c08169cffde
Patch-set: 2
File: runtime/jit/jit_instrumentation.cc

131:0-131:19
Mon Sep 28 09:29:14 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 6ec3bd5a_b8e45518
Bytes: 29
Why the need for the barrier?

131:0-131:19
Mon Sep 28 20:22:37 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6ec3bd5a_b8e45518
UUID: ee86cdd4_632571ec
Bytes: 4
Done

136:0-138:19
Mon Sep 28 09:29:14 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2ebd45ca_567cf2b0
Bytes: 86
What if the thread pool is more than just one, and this task gets done before another?

136:0-138:19
Mon Sep 28 20:22:37 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2ebd45ca_567cf2b0
UUID: 6e4d7d85_f37273d8
Bytes: 60
I think I can use ThreadPool::Wait, I forgot about that API.

File: test/141-class-unload/src/Main.java

142:25-142:31
Mon Sep 28 18:48:29 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8e52b121_f05a6d8d
Bytes: 64
Is there a chance that new JIT work will be added after we wait?

142:25-142:31
Mon Sep 28 20:22:37 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8e52b121_f05a6d8d
UUID: ee616dea_37c0fb87
Bytes: 162
Depends on what code is run after the call, for the class unloading test I just wanted to make sure the JIT wouldn't keep the class loader we want to unload live.

