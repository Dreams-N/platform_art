Revision: d660ea0f70fa9e2cbf234f039902f0092eb4f0af
Patch-set: 1
File: compiler/optimizing/intrinsics_x86_64.cc

2447
Thu Jan 28 02:46:13 2016 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f49a3677_72702de0
Bytes: 21
Allow src2 to be Any?

2448:0-2448:63
Thu Jan 28 01:21:41 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 94b2daf4_b4a619dc
Bytes: 1533
Note that this does not have a constant folding section (yet; I wonder if we really should do this every time rather than just folding this in the HIR).

Also note that low level testing allows us to do a single compare and short branches. So we get


      0x00002094:                   3BF2               cmp esi, edx
      0x00002096:                   7C06               jl/nge +6 (0x0000209e)
      0x00002098:                   7F0B               jnle/g +11 (0x000020a5)
      0x0000209a:                   33C0               xor eax, eax
      0x0000209c:                   EB0C               jmp +12 (0x000020aa)
      0x0000209e:             B8FFFFFFFF               mov eax, -1
      0x000020a3:                   EB05               jmp +5 (0x000020aa)
      0x000020a5:             B801000000               mov eax, 1


while the reference implementation can do no better than

      0x000020cc:                   3BF2               cmp esi, edx
      0x000020ce:           0F8D0A000000               jnl/ge +10 (0x000020de)
      0x000020d4:             B8FFFFFFFF               mov eax, -1
      0x000020d9:             E914000000               jmp +20 (0x000020f2)
      0x000020de:                   3BF2               cmp esi, edx
      0x000020e0:           0F8507000000               jnz/ne +7 (0x000020ed)
      0x000020e6:                   33C0               xor eax, eax
      0x000020e8:             E905000000               jmp +5 (0x000020f2)
      0x000020ed:             B801000000               mov eax, 1

2448:0-2448:63
Thu Jan 28 15:31:49 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 94b2daf4_b4a619dc
UUID: 34520eae_9f0bb773
Bytes: 361
Since you allow the default kOutputOverlap for the "out", why don't you set it to 0 first and save code size on jumps (three instead of 4)? You can then also save code size on movs by using smaller inc/dec, assuming it doesn't impact the performance:

    xor eax, eax
    cmp esi, edx
    je end
    jl lower
    inc eax
    jmp end
  lower:
    dec eax
  end:

2448:0-2448:63
Thu Jan 28 15:42:27 2016 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 34520eae_9f0bb773
UUID: 14beeac6_a1e095b9
Bytes: 171
inc/dec have some slight performance issues compared to add/sub, but I am sure that they are irrelevant here.  I would go for the smaller code like Vladimir is suggesting.

2510:6-2514:7
Thu Jan 28 02:46:13 2016 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f49a3677_32d145f2
Bytes: 55
Can just use xorl.  That will clear the upper bits too.

2526
Thu Jan 28 02:46:13 2016 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f49a3677_b2e455cd
Bytes: 69
movq only handles 32 bit values! You can use codegen_->Load64BitValue

2526
Thu Jan 28 03:46:18 2016 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f49a3677_b2e455cd
UUID: f4b5d6da_3a7e76f8
Bytes: 110
No, movq handles all values.  It is inefficient for ones that fit in int32_t.  Load64BitValue is still better.

2553:0-2559:5
Thu Jan 28 15:31:49 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b4bb5ef1_bb1353e8
Bytes: 39
Use movl() and pull it out of the `if`.

2562:4-2566:5
Thu Jan 28 02:46:13 2016 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 94b2daf4_2f90f4fd
Bytes: 4
xorl

2785:0-2785:51
Thu Jan 28 14:26:58 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d4c4527f_1c69193a
Bytes: 107
Add a comment that you need a writable register, so you are going to move the input into the temp register.

2785:0-2785:51
Thu Jan 28 14:32:52 2016 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d4c4527f_1c69193a
UUID: 34c3ee5c_f56c00de
Bytes: 144
Could there be some way of asking if the input goes dead, so it could be used as the temp instead?  In other words it could be safely clobbered?

2785:0-2785:51
Thu Jan 28 15:21:20 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 34c3ee5c_f56c00de
UUID: 34b68e05_4207b6fa
Bytes: 86
that's not supported right now, but could be an improvement of the register allocator.

2822:44-2822:46
Thu Jan 28 02:46:13 2016 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 542ce22d_78591ddd
Bytes: 30
31/63 to handle int/long cases

