Revision: be20ca0db2aff7c4b076ded6ab3ae5257758d577
Patch-set: 2
File: runtime/jni_env_ext.cc

121:4-123:78
Tue Sep 29 05:05:54 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ee86cdd4_991586d4
Bytes: 192
Note: I don't think this actually happens, as the JNI transition frame is a quick frame (even the Generic JNI one looks like one). But just for completeness it's better to have something here.

137:2-137:24
Tue Sep 29 05:05:54 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ae5bf53d_ce9b412f
Bytes: 66
Yuck, cruft, will remove tomorrow. Wonder why it didn't warn me...

146:30-146:36
Tue Sep 29 12:13:15 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4ec27958_773baa60
Bytes: 4
typo

164:4-166:66
Tue Sep 29 05:05:54 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2e2e2591_998116ca
Bytes: 110
It's obviously not a great implementation, but then this is on abort, so I felt this was nicely declarative...

164:4-166:66
Tue Sep 29 12:13:15 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2e2e2591_998116ca
UUID: 6ec3bd5a_d85031f6
Bytes: 526
You essentially want

  auto kept_end = std::remove_if(locked_objects->begin(),
                                 locked_objects->end(),
                                 [self](const std::pair<uintptr_t, jobject>& pair) {
    if (frame == pair.first) {
      mirror::Object* o = self->DecodeJObject(jobj);
      monitors->Remove(o);
      return true;
    }
    return false;
  });
  locked_objects->erase(kept_end, locked_objects->end());

However, I'd still prefer the remove_if() loop written explicitly to avoid the lambda.

164:4-166:66
Tue Sep 29 16:08:00 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6ec3bd5a_d85031f6
UUID: 2e2e2591_19a64629
Bytes: 333
Sorry, do I understand you correctly and you really want me to implement remove_if? I disagree with that. Either we should accept the lambda, or we should have a simple implementation. Something that is juggling elements around explicitly (and still needs the erase call to cut off the unused end) is IMHO neither simple nor elegant.

164:4-166:66
Tue Sep 29 16:20:14 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2e2e2591_19a64629
UUID: eeb7ade1_dc574163
Bytes: 210
After reading our style guide again, I'm actually OK with a lambda. I guess I should use a lambda at https://android-review.googlesource.com/#/c/172203/2/compiler/optimizing/register_allocator.cc@618 after all.

164:4-166:66
Tue Sep 29 16:39:52 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: eeb7ade1_dc574163
UUID: 0e5fa128_be04c3e0
Bytes: 35
I'm fine with the lambda version...

File: runtime/jni_env_ext.h

118:0-118:61
Tue Sep 29 08:32:56 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: eececd75_44b7e055
Bytes: 200
Won't it simplify a lot of things if this was thread specific and created at JNI entry? The need to have a uintptr_t from the frame (?) also doesn't seem right when you know that the calls are scoped.

118:0-118:61
Tue Sep 29 16:08:00 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: eececd75_44b7e055
UUID: 2e2e2591_39b1025f
Bytes: 469
This *is* thread-specific, as JNIEnv is. That's why there's no lock around this.

Mathieu and I derived this encoding to minimize the overhead in non-CheckJNI situations. The only thing you always pay is the CheckJNI-check on exit of a JNI function. And even if CheckJNI is on, only MonitorEnter and Exit operations pay any price. Any stack of vectors to scope things requires entry instrumentation that we wanted to avoid (as bdc really only wanted CheckJNI impacted).

118:0-118:61
Tue Sep 29 16:19:20 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2e2e2591_39b1025f
UUID: 0e9a4178_3bb20b1e
Bytes: 278
Oh, didn't nee the vector wasn't locked. My question then is around the "sessions" you talk about in the implementation. Why do you need them when calls are scoped? Is that the stack of vectors you wanted to avoid? But if no check-jni, that stack of vector will always be empty.

118:0-118:61
Tue Sep 29 16:39:52 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0e9a4178_3bb20b1e
UUID: 0e5fa128_def7774e
Bytes: 861
"Sessions" or "segments" or "native frames," I don't have a good name. It's the native frames of the current JNI call.

The issue is exactly that you try to simulate the stack without the overhead, saving something specific to the native Java method call. It's fine to lock in JNI, make a Java call, which goes into another JNI call, which locks and unlocks, ...

JNI is slow enough and Mathieu yelled at me with the first design (the stack). So I'm trying to avoid all overhead where possible - which means *nothing* in the JNI entry and a simple check for "Is CheckJNI on" at JNI exit. (Also note that the stack design allocates and deletes in each JNI session, but this implementation only mutates the vector whenever there's a MonitorEnter or Exit, which is rare [a quick search only shows occurrences in android.view.Surface and android.media.MediaCodec]).

118:0-118:61
Tue Sep 29 17:04:28 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0e5fa128_def7774e
UUID: ceae6993_81b1e060
Bytes: 87
If you could do a checkJni check at JNI entry, could you then scope the locked_objects?

