Revision: 522a1d19aab21c3aff3795ae38e43d15ea570a8c
Patch-set: 5
File: compiler/dex/quick/codegen_util.cc

1097:6-1097:44
Wed Mar 25 21:35:51 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2362b2ee_f7d9431f
Bytes: 190
You'll always push a vector, and so you need both a nullptr and that ugly size() > 0 check in the elf writer. Consider a ternary here, maybe, or rewrite how cfi is handled in CompiledMethod.

1097:6-1097:44
Wed Mar 25 22:31:24 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2362b2ee_f7d9431f
UUID: 63002af0_61d5926f
Bytes: 238
I don't understand.

In my opinion this is perfectly OK. If the patch is empty, this will create an empty ArrayRef<> which will be nicely forwarded to the CompiledMethod ctor where we shall see it's empty and we will not touch its data().

1097:6-1097:44
Wed Mar 25 22:38:42 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 63002af0_61d5926f
UUID: 2362b2ee_1a13dbe1
Bytes: 218
Ah, yes, I had forgotten that we actually checked against the size, which is weirdly 0 for an arrayref without backing data. That just means the elf-writer should be updated, as you'll never so non-nullptr with size 0.

1097:6-1097:44
Thu Mar 26 11:36:44 2015 +0000
Author: David Srbecky <1065473@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2362b2ee_1a13dbe1
UUID: 438406cc_621b3675
Bytes: 4
Done

File: compiler/elf_writer_quick.cc

604:46-604:48
Thu Mar 26 07:06:20 2015 +0000
Author: Yevgeny Y Rouban <1037563@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 438406cc_a2d7fe42
Bytes: 189
I think it make sense to add rows with the same line but incremented discriminant? This way would keep a finer grained debug line info.
Discriminant seems needed in case first_line == line.

604:46-604:48
Thu Mar 26 11:36:44 2015 +0000
Author: David Srbecky <1065473@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 438406cc_a2d7fe42
UUID: 43116641_e35400e2
Bytes: 363
What would be the benefit of adding the discriminators?
My understanding is that they are only useful for profile-based opimizations in cases where multiple basic-blocks map to single source line.
Adding them here would result in new row per every dex bytecode.  This would significantly increase the size of .debug_line, and I do not see immediate benefit of it.

604:46-604:48
Thu Mar 26 12:01:11 2015 +0000
Author: Yevgeny Y Rouban <1037563@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 43116641_e35400e2
UUID: 43116641_63cfd02e
Bytes: 584
1. I think you agree that the discriminator is needed where first_line == line (in the first cycle)
2. I agree that discriminators will increase the size and I just wanted to pin this decision here in comments. But one doubt I still have: imagine a branch, that jumps inside the block of instructions mapped to the same line. A debugger will be unable to set a breakpoint by source line number at the jump target address. To cope with this, it seems, we have to keep track basic block numbers. Essentially they could be the discriminators... I suggest to go ahead and put a TODO here.

604:46-604:48
Thu Mar 26 12:30:31 2015 +0000
Author: David Srbecky <1065473@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 43116641_63cfd02e
UUID: 438406cc_a2613eba
Bytes: 666
1. Why is the discriminator needed if first_line == line?  I am afraid I do not follow.  The intention of code above is to attribute the prologue to some source line, but to tell the debugger it should not put a breakpoint there.
2. I am not sure I follow, but if I understand, I do not think this can be represented in DWARF line table - using discriminators or otherwise.  I do not think that discriminators have any effect on how branching and breakpoints are handled.  I would argue that the backend should do best effort to ensure that target of branch is start of statement, and the debugger should do best effort to handle situations where it is not the case.

604:46-604:48
Thu Mar 26 13:02:05 2015 +0000
Author: Yevgeny Y Rouban <1037563@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 438406cc_a2613eba
UUID: 438406cc_a2e7feac
Bytes: 396
AFAIU: The spec reads: "Discriminator values are assigned arbitrarily by the DWARF producer and serve to distinguish among multiple blocks that may all be associated with the same source file, line, and column." If first_line == line and pc > 0 then we end up with two blocks with the same line.
Formally we have to set a new discriminator for every row with a line number that is used elsewhere.

