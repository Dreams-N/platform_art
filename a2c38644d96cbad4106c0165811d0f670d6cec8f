Revision: a2c38644d96cbad4106c0165811d0f670d6cec8f
Patch-set: 2
File: runtime/base/mutex.cc

998:0-998:123
Fri Sep 18 07:26:00 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c9ef43fe_50bf8ce3
Bytes: 13
Line too long

File: runtime/interpreter/interpreter_common.cc

707:4-707:46
Fri Sep 18 09:18:37 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c9ef43fe_90d5f423
Bytes: 1023
This should be done with the mutex held, otherwise you're relying on subtle properties of the container. I would prefer

    SafeMap<uint32_t, std::set<uint32_t>>* string_init_map_ptr = nullptr;
    {
      MutexLock mu(self, *Locks::interpreter_string_init_map_lock_);
      it = method_to_string_init_map.find(method_ref);
      if (it != method_to_string_init_map.end()) {
        string_init_map_ptr = &it->second;
      }
    }
    if (string_init_map_ptr == nullptr) {
      SafeMap<uint32_t, std::set<uint32_t>> string_init_map =
          verifier::MethodVerifier::FindStringInitMap(method);
      MutexLock mu(self, *Locks::interpreter_string_init_map_lock_);
      // For efficiency you should add an overload of Overwrite() that takes
      // the value as an rvalue reference and have both overloads return
      // the iterator to the inserted/replaced entry.
      auto it = method_to_string_init_map.Overwrite(
          method_ref, std::move(string_init_map));
      string_init_map_ptr = &it->second;
    }

707:4-707:46
Fri Sep 18 20:05:20 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c9ef43fe_90d5f423
UUID: 099a3b78_c673e26e
Bytes: 282
How can thee existing code in PS2 be thread-safe? It's reading from iterator without a lock, but it looks like that same value can be overwritten on line 711 from another thread.

I don't know about SafeMap guarantees, but std::map the iterator will be invalid if the key is erased.

707:4-707:46
Fri Sep 18 20:10:33 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 099a3b78_c673e26e
UUID: c91663dc_3b27237a
Bytes: 309
The map is strictly growing. So this uses, as vmarko says, some conclusions from internals, namely that on insert iterators aren't invalidated, so end() must always be the same. (It's still not explicitly race-free, as there are no guarantees given for that, but if there were, it would be somewhat insane...)

708:24-708:33
Fri Sep 18 09:18:37 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8902ab8b_86d5ca23
Bytes: 24
Unnecessary std::move().

713:6-713:45
Fri Sep 18 09:18:37 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 89762b11_86180ab1
Bytes: 112
This may be correct as it is but it looks odd, you're using a copy that's outside the method_to_string_init_map.

