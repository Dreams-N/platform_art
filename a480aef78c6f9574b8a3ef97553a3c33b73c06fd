Revision: a480aef78c6f9574b8a3ef97553a3c33b73c06fd
Patch-set: 1
File: runtime/interpreter/interpreter_common.cc

701:4-701:66
Fri Sep 18 00:39:19 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 89df0b23_411274d5
Bytes: 25
Isn't a MutexLock enough?

701:4-701:66
Fri Sep 18 00:47:08 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 89df0b23_411274d5
UUID: 89df0b23_e1cf00b3
Bytes: 2
+1

705:6-707:68
Fri Sep 18 00:39:19 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e9b7a7e1_dcfae1e1
Bytes: 37
Looks like Mathieu's scoped unlock...

705:6-707:68
Fri Sep 18 00:47:08 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e9b7a7e1_dcfae1e1
UUID: e99c0776_9743cc32
Bytes: 42
I need to get around to implementing that.

708:6-708:71
Fri Sep 18 00:50:32 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e99c0776_373ea0a4
Bytes: 205
I think it's enough to just put this under the lock. Worst case you do double work, but iterators aren't invalidated in a std::map, so it will stay valid even if somebody else modifies the underlying tree.

708:6-708:71
Fri Sep 18 00:55:17 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e99c0776_373ea0a4
UUID: c9a3c3b1_d39726c6
Bytes: 102
If you overwrite somebody else's map, wouldn't that cause problems since they might access stale data?

