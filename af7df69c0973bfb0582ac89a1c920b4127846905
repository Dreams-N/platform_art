Revision: af7df69c0973bfb0582ac89a1c920b4127846905
Patch-set: 3
File: compiler/optimizing/code_generator_arm.cc

5402:4-5402:16
Fri Oct 23 12:35:54 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 76c00516_4d75198a
Bytes: 17
Obsolete comment?

5402:4-5402:16
Fri Oct 23 18:54:20 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 76c00516_4d75198a
UUID: d6d53101_40634ed0
Bytes: 4
Done

File: compiler/utils/arm/assembler_arm.h

83:88-83:94
Fri Oct 23 12:35:54 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 76c00516_6d7a557b
Bytes: 96
Still needs a std::move(), named parameter "labels" is considered an lvalue here despite the &&.

83:88-83:94
Fri Oct 23 18:54:20 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 76c00516_6d7a557b
UUID: 36e4cdf6_9bd6abd6
Bytes: 4
Done

File: compiler/utils/arm/assembler_arm32.cc

1397:4-1397:58
Fri Oct 23 12:35:54 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d6db7104_502dacca
Bytes: 44
This should precede the current else branch.

1397:4-1397:58
Fri Oct 23 18:54:20 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d6db7104_502dacca
UUID: f6b795e1_99895b2a
Bytes: 4
Done

1398:10-1398:12
Fri Oct 23 12:35:54 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b6b7ddb4_a705ca53
Bytes: 2
rn

1398:10-1398:12
Fri Oct 23 18:54:20 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b6b7ddb4_a705ca53
UUID: 36e4cdf6_fbcdef41
Bytes: 4
Done

File: compiler/utils/arm/assembler_thumb2.cc

259:29-259:43
Fri Oct 23 12:35:54 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 56cf8147_6c325b2c
Bytes: 9
orig_size

259:29-259:43
Fri Oct 23 18:54:20 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 56cf8147_6c325b2c
UUID: d6d53101_606852aa
Bytes: 4
Done

1921
Fri Oct 23 12:35:54 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b6defdf4_0f4e25ab
Bytes: 55
LOG(FATAL) + UNREACHABLE()? Or do we actually get here?

1921
Fri Oct 23 18:54:20 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b6defdf4_0f4e25ab
UUID: 76dac536_7d31d7ba
Bytes: 33
Yeah, this should be unreachable.

3435:28-3435:30
Fri Oct 23 12:35:54 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 96c57926_0ea06b99
Bytes: 95
This should be kNoRegister. Or we could use the ShifterOperandCanAlwaysHold() added by Nicolas.

3435:28-3435:30
Fri Oct 23 18:54:20 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 96c57926_0ea06b99
UUID: 76dac536_dd1f4b27
Bytes: 86
I'd rather keep this in line with AddConstant. Changed the (unused) rd to kNoRegister.

3439:4-3439:66
Fri Oct 23 12:35:54 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d6b451b2_e89cf336
Bytes: 44
This should precede the current else branch.

3439:4-3439:66
Fri Oct 23 18:54:20 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d6b451b2_e89cf336
UUID: f6ceb575_0136aaa8
Bytes: 4
Done

3440:10-3440:12
Fri Oct 23 12:35:54 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d6b451b2_88a9b753
Bytes: 2
rn

3440:10-3440:12
Fri Oct 23 18:54:20 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d6b451b2_88a9b753
UUID: f6b795e1_39edafbb
Bytes: 4
Done

3669:28-3669:69
Fri Oct 23 12:35:54 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b6defdf4_cf57bd3a
Bytes: 17
std::move(labels)

3669:28-3669:69
Fri Oct 23 18:54:20 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b6defdf4_cf57bd3a
UUID: f6b795e1_1911cb6a
Bytes: 4
Done

3688
Fri Oct 23 12:35:54 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 96c57926_ae903748
Bytes: 149
The 32-bit ADD does not permit PC as input, only as output, so this would have to use

    SUB ip, pc, #0  # special case of ADR
    ADD pc, ip, reg.

3688
Fri Oct 23 18:54:20 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 96c57926_ae903748
UUID: 36e4cdf6_9b3eab81
Bytes: 158
Yes, which is pretty annoying, which is why it's not implemented until we need it. I added your code sequence as a comment.

Do you want me to implement this?

3696
Fri Oct 23 12:35:54 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 96ae5964_0627faec
Bytes: 32
and another Emit32(), see above.

3696
Fri Oct 23 18:54:20 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 96ae5964_0627faec
UUID: 16b509da_da5bc512
Bytes: 4
Done

File: compiler/utils/arm/assembler_thumb2.h

653:20-653:61
Fri Oct 23 12:35:54 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d6b451b2_28c9ab40
Bytes: 200
This is creating an extra temporary. You could add the && as in std::forward<std::vector<Label*>&&>(labels) but I'd prefer simply std::move(labels). (And that will take care of the line length limit.)

653:20-653:61
Fri Oct 23 18:54:20 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d6b451b2_28c9ab40
UUID: 36e4cdf6_db359376
Bytes: 58
+iam. I thought this was the correct usage for forwarding.

653:20-653:61
Sat Oct 24 01:12:18 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 36e4cdf6_db359376
UUID: d6ae1193_217f349c
Bytes: 707
std::forward should only be used with forwarding references (templated references that "look like" T&&)

when it's not templated like this, std::move is strongly preferred

   JumpTable(std::move(labels), ...

the reason we don't need the && for forward inside of templated code is because the T already has it

   foo( 0 + 1 );

   template<typename T>
   void foo(T&& bar) {
     // T == int&& already
     // but bar is an lvalue to an rvalue reference
     // int&& && bar == int&& bar
   }

In fact using std::forward should only be necessary when we know for sure the function being forwarded to can take a multitude of lvalue and rvalue references overloads, otherwise it's just obscuring the intent.

