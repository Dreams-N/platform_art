Revision: 8baf0d9263f914aee8ca91df92660342ace9e671
Patch-set: 1
File: compiler/utils/assembler_thumb_test.cc

46
Mon Jul 21 13:44:51 2014 +0000
Author: Narayan Kamath <1014443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f95af4db_4edee7f2
Bytes: 240
or you could have made this "static const char[] kToolPrefix" where sizeof( ) would work. You're right that it's more brittle, but I believe the google3 style guide recommends using char[] instead of "char*" for such compile time constants.

46
Mon Jul 21 13:49:03 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f95af4db_4edee7f2
UUID: f95af4db_2eeccb96
Bytes: 68
Thanks for the nit. I'll think about incorporating it in another CL.

119:48-119:54
Mon Jul 21 12:29:01 2014 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 195ee8cf_8cfaab52
Bytes: 438
I already saw the use of sizeof to count the number of characters of a string elsewhere in ART. I suppose this is not working here because TOOL_PREFIX is a char* so sizeof would return 4 (or 8 on 64bit), right?

Still I wonder if there is not a difference of 1 in the count. If TOOL_PREFIX was a char[], sizeof would return the number of characters + 1 for the '\0'. Shouldn't we add 1 to strlen *or* was sizeof wrong from the start here?

119:48-119:54
Mon Jul 21 12:40:17 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 195ee8cf_8cfaab52
UUID: f95af4db_0edd4f1a
Bytes: 280
You're right. Before, it used to be sizeof("arm-eabi-"), which would count the '\0'. So that was broken, I changed it to a constant because it is used in other places, which broke it in a different way (now it would return 4/8).

We should stay with strlen. sizeof is too brittle.

