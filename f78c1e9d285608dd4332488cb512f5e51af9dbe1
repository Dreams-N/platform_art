Revision: f78c1e9d285608dd4332488cb512f5e51af9dbe1
Patch-set: 1
File: compiler/optimizing/builder.cc

404:24-404:29
Tue Jun 17 08:11:50 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 6463b9f2_2949cd75
Bytes: 85
I think we should have a version of LoadLocal that just does not care about the type.

404:24-404:29
Tue Jun 17 16:56:00 2014 +0000
Author: Dave Allison <1036486@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6463b9f2_2949cd75
UUID: e44ec981_4b219992
Bytes: 2
OK

File: compiler/optimizing/code_generator_x86.cc

429:24-429:32
Tue Jun 17 08:11:50 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 6463b9f2_c93fd1d0
Bytes: 44
I think you want one input to be a register.

429:24-429:32
Tue Jun 17 16:56:00 2014 +0000
Author: Dave Allison <1036486@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6463b9f2_c93fd1d0
UUID: 0452fd22_a97ed9ba
Bytes: 18
Yeah, you're right

447:49-447:58
Tue Jun 17 08:11:50 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 6463b9f2_094e097e
Bytes: 20
Why is that not rhs?

447:49-447:58
Tue Jun 17 16:56:00 2014 +0000
Author: Dave Allison <1036486@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6463b9f2_094e097e
UUID: e44ec981_6b45752c
Bytes: 6
Indeed

File: compiler/optimizing/nodes.h

411:4-411:14
Tue Jun 17 08:11:50 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 245d4132_e719a292
Bytes: 154
What is this instruction for? The non SSA-from will just update the local and the SSA form will just get rid of the local, so I don't see the need for it.

411:4-411:14
Tue Jun 17 16:56:00 2014 +0000
Author: Dave Allison <1036486@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 245d4132_e719a292
UUID: 0452fd22_2cde7775
Bytes: 785
The MOVE_RESULT dex instruction has an implicit input - the result of the last call.  This needs to be put into a local so it needs to be read from somewhere.  On ARM, the result is in R0 so this instruction simply has R0 an input and a register as output.  This register is then used as input to store to a local.  The original code in the builder for MOVE_RESULT assumed the result  of the last call was the last instruction's output, which is was no necessarily true.

If we don't have this instruction we would have keep R0 alive from the point of the last call to the point where the value is used, across all intervening instructions.

This is all my understanding and is subject to correction as I get more familiar with this code.  In other words, I might be missing something.

753:6-753:17
Tue Jun 17 08:11:50 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 6463b9f2_e9197592
Bytes: 71
Why did you want an HExpression? To add a type to HTemplateInstruction>

753:6-753:17
Tue Jun 17 16:56:00 2014 +0000
Author: Dave Allison <1036486@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6463b9f2_e9197592
UUID: 44587541_cb98e9ee
Bytes: 189
It's an HInstruction with type.  I saw that there was a pattern of adding a type to various instructions and wanted to consolidate it into a node that is an instruction and provides a type.

764:15-764:28
Tue Jun 17 08:11:50 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c44b8572_a423a2c6
Bytes: 39
That's already in HTemplateInstruction.

764:15-764:28
Tue Jun 17 16:56:00 2014 +0000
Author: Dave Allison <1036486@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c44b8572_a423a2c6
UUID: 44587541_6b71fdf1
Bytes: 22
Yeah, should remove it

769:34-769:41
Tue Jun 17 08:11:50 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 245d4132_a723aac6
Bytes: 6
ditto.

769:34-769:41
Tue Jun 17 16:56:00 2014 +0000
Author: Dave Allison <1036486@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 245d4132_a723aac6
UUID: e44ec981_abaecd84
Bytes: 5
ditto

852:11-852:14
Tue Jun 17 08:11:50 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 6463b9f2_694fc57d
Bytes: 625
I gave the boolean value directly to the if instruction to make it a bit more flexible for optimization passes (things like predicate simplifications, or GVN will prefer reasoning on individual instructions). While this change makes the codegen simpler, I think I'd prefer keeping the explicit condition, and optimize codegen to recognize that the condition does not need materialization. Initially something as simple as:

NeedsMaterialization(HInstruction* instruction) {
  if (instruction->number_of_uses == 1 && instruction->user isa HIf && instruction->next == instruction->user) {
    return false;
  }
  return true;
}

852:11-852:14
Tue Jun 17 16:56:00 2014 +0000
Author: Dave Allison <1036486@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6463b9f2_694fc57d
UUID: e44ec981_6b1fb5f3
Bytes: 389
I'll have to think some more about this.  The existence of the instruction that simply does a comparison and puts the 1 or 0 into a register is at odds with the DEX instruction sequence which has already coded it into the IF_XX.  Admittedly I am not yet familiar with the implementation details of all the optimizations we want to do and you are most likely right but I want to understand.

