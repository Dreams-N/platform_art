Revision: 8ebf8adca887c00f4c8b6c7b45f21f84a9ffa2bc
Patch-set: 1
File: /COMMIT_MSG

7:0-7:4
Thu Oct 08 18:11:18 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 5061411e_f537cba8
Bytes: 14
"Fix race..."?

11:0-12:68
Thu Oct 08 18:11:18 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 105c2963_8e9ac768
Bytes: 1030
I think if we see "freeNativeStorage: 101" in the output as expected and just miss the "intr" message, it's possible that we called interrupt() right after the watcher called freeNativeStorage() for dataB but right before the watcher blocks on remove() in the next iteration of the loop. 

That may be an OK case because the watcher did what it needed to do but just exited without blocking, though it suggests things were slower than expected. In this case, just removing the "intr" print code may be an OK fix.

If we don't see "freeNativeStorage: 101" in the output, then it was just too slow and should be seen as a failure as the watcher didn't do all it intended to do. I'm not sure how to fix that. Maybe just increase the sleep time?

I don't think we've seen this sort of failure cases. Maybe just decrease the parallelism (the -j value) when running the test?

In any case, the test is inherently timing-dependent as there's no timing guarantee on when the phantom reference gets enqueued in this queue after the GC run.

9:1-18:74
Thu Oct 08 10:53:45 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 70700519_84b3a678
Bytes: 19
some lines too long

18:12-18:18
Thu Oct 08 10:53:45 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 70664538_b7e7220b
Bytes: 5
mQuit

18:58-18:73
Thu Oct 08 10:53:45 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b06c3d16_b640c8f7
Bytes: 11
is printed.

File: test/079-phantom/src/Bitmap.java

150:8-150:17
Thu Oct 08 18:11:18 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b0435d80_088b4818
Bytes: 224
I think if the watcher isn't blocking in remove when this interrupt is called, it may not get an InterruptedException, in which case the watcher could infinite-loop and never terminate. So, mQuit seems to be still necessary.

