Revision: 8ebf8adca887c00f4c8b6c7b45f21f84a9ffa2bc
Patch-set: 1
File: /COMMIT_MSG

7:0-7:4
Thu Oct 08 18:11:18 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 5061411e_f537cba8
Bytes: 14
"Fix race..."?

11:0-12:68
Thu Oct 08 18:11:18 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 105c2963_8e9ac768
Bytes: 1030
I think if we see "freeNativeStorage: 101" in the output as expected and just miss the "intr" message, it's possible that we called interrupt() right after the watcher called freeNativeStorage() for dataB but right before the watcher blocks on remove() in the next iteration of the loop. 

That may be an OK case because the watcher did what it needed to do but just exited without blocking, though it suggests things were slower than expected. In this case, just removing the "intr" print code may be an OK fix.

If we don't see "freeNativeStorage: 101" in the output, then it was just too slow and should be seen as a failure as the watcher didn't do all it intended to do. I'm not sure how to fix that. Maybe just increase the sleep time?

I don't think we've seen this sort of failure cases. Maybe just decrease the parallelism (the -j value) when running the test?

In any case, the test is inherently timing-dependent as there's no timing guarantee on when the phantom reference gets enqueued in this queue after the GC run.

11:0-12:68
Thu Oct 08 20:39:41 2015 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 105c2963_8e9ac768
UUID: d03c51f4_283baa97
Bytes: 360
I agree, but I think this CL is a small improvement.  It removes one unlikely source of nondeterminism.

Clearly there's still no guarantee that references are enqueued when expected.  And there are other timing assumptions that may fail under heavy load. Perhaps add a comment to that effect, and we can deal with it if we actually see such spurious failures?

9:1-18:74
Thu Oct 08 10:53:45 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 70700519_84b3a678
Bytes: 19
some lines too long

18:12-18:18
Thu Oct 08 10:53:45 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 70664538_b7e7220b
Bytes: 5
mQuit

18:58-18:73
Thu Oct 08 10:53:45 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b06c3d16_b640c8f7
Bytes: 11
is printed.

File: test/079-phantom/src/Bitmap.java

150:8-150:17
Thu Oct 08 18:11:18 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b0435d80_088b4818
Bytes: 224
I think if the watcher isn't blocking in remove when this interrupt is called, it may not get an InterruptedException, in which case the watcher could infinite-loop and never terminate. So, mQuit seems to be still necessary.

150:8-150:17
Thu Oct 08 20:39:41 2015 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b0435d80_088b4818
UUID: 704d65ae_66e5dfbe
Bytes: 346
This looks OK to me.  If we interrupt while the thread is not waiting, we should get the interrupt the next time around.

Hiroshi points out that the fixed failure scenario is unlikely unless we're seeing an overloaded machine. The test driver should ensure that we are in remove() when we are interrupted.  Thus it's not clear this really helps.

150:8-150:17
Thu Oct 08 21:54:54 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 704d65ae_66e5dfbe
UUID: 8521b987_85a402e5
Bytes: 254
Agree with Hans. The spec is that the interrupted flag is set, and the next wait should react to that (again by spec):

 InterruptedException - if any thread interrupted the current thread before or while the current thread was waiting for a notification

150:8-150:17
Thu Oct 08 23:50:16 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8521b987_85a402e5
UUID: eaf16251_c03c5e8e
Bytes: 6
Right.

