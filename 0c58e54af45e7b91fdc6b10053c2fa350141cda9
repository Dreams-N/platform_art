Revision: 0c58e54af45e7b91fdc6b10053c2fa350141cda9
Patch-set: 1
File: compiler/optimizing/bounds_check_elimination.cc

1240:8-1243:9
Thu Dec 03 22:30:02 2015 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 009dc025_9ef2598f
Bytes: 574
Do you need to continue looping once try_dynamic_bce becomes false?

It seems like a better loop might be

    do {
      if (...) {
        if (index_range.GetLower()...) {
          *try_dynamic_bce = false;
        }
        if (!needs_finite_test && ...) {
          return true;
        } else if (!*try_dynamic_bce) {
          return false;
        }
      }
    } while (induction_range_.RefineOuter(...));

If it is just that the loop is guaranteed to end when both *try_dynamic_bce and (!needs_finite_test && ...) are false then you should mention it in a comment.

1240:8-1243:9
Thu Dec 03 23:10:05 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 009dc025_9ef2598f
UUID: 204d6487_071dd8ef
Bytes: 167
Probably not, but I think we can even directly return false when we set try_dynamic_bce to false (since a certain OOB implies we can never get a proper FitsIn anyway).

File: compiler/optimizing/induction_var_range.cc

420:100-420:105
Thu Dec 03 22:30:02 2015 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 404ed883_28df83fb
Bytes: 23
Nit: Style: line length

420:100-420:105
Thu Dec 03 23:10:05 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 404ed883_28df83fb
UUID: 009dc025_1e496946
Bytes: 4
Done

File: compiler/optimizing/induction_var_range.h

154:59-154:87
Thu Dec 03 22:30:02 2015 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 204d6487_47f2b056
Bytes: 135
Nit: I find this wording somewhat confusing. maybe:

    Returns refined value or the input value if no further refinement is possible.

154:59-154:87
Thu Dec 03 23:10:05 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 204d6487_47f2b056
UUID: 009dc025_7e442d2f
Bytes: 4
Done

File: test/530-checker-loops/src/Main.java

437:26-437:27
Thu Dec 03 22:30:02 2015 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 20a2c463_6239f221
Bytes: 17
why not b.length?

437:26-437:27
Thu Dec 03 23:10:05 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 20a2c463_6239f221
UUID: 40933818_c3a1ea65
Bytes: 121
it has been made deliberately obscure to see if the range analysis still finds it; Using b.length would be too simple :-)

437:26-437:27
Thu Dec 03 23:22:53 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 40933818_c3a1ea65
UUID: c08728d0_67258657
Bytes: 238
Perhaps you meant to say that when using b.length we should *also* be able to remove bounds check on a (since on b is straightforward in that case).

That is an interesting new test case (I tried it, and it does not work out of the box :(

437:26-437:27
Fri Dec 04 00:23:14 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c08728d0_67258657
UUID: 00486077_69db41a0
Bytes: 150
Why isn't b.length replaced with i already by instruction simplifier? It seems InstructionSimplifierVisitor::VisitArrayLength() should have done that.

437:26-437:27
Fri Dec 04 00:44:56 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 00486077_69db41a0
UUID: 404ed883_2b49bd46
Bytes: 197
Because in the simplifier, this rewriting is only done for constants, not symbolics like here (not sure why). In any case, it is good to make range analysis robust against subtle input differences.

