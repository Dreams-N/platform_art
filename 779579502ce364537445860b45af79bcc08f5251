Revision: 779579502ce364537445860b45af79bcc08f5251
Patch-set: 3
File: runtime/arch/arm/quick_entrypoints_arm.S

909:0-918:21
Tue Oct 13 18:00:49 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ff13e649_1c7bd9af
Bytes: 212
This will prevent reordering of memory accesses from the current CPU. But is this really enough? Or, could the CPU still use stale flags from its own L1 data cache after fetching a new status from the actual RAM?

909:0-918:21
Tue Oct 13 19:53:03 2015 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ff13e649_1c7bd9af
UUID: dfb462b2_4fd41e79
Bytes: 750
This is fine.  The ARM v8 manual I have says:

B2.7.2:

If an address dependency exists between two reads or between a read and a write, then those memory
accesses are observed in program order by all observers within the shareability domain of the memory
address being accessed.
The ARMv8 architecture relaxes this rule for execution where the second read is generated by a Load
Non-Temporal Pair instruction. See Load/Store Non-temporal Pair on page C2-132 and Load/Store
SIMD and Floating-point Non-temporal pair on page C2-136.


This is followed by a section on "Address dependencies and order", which clearly includes this case.

I believe this rule has been there since the beginning of time.  And it's required to make Java final fields work.

909:0-918:21
Tue Oct 13 20:05:38 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dfb462b2_4fd41e79
UUID: 7fa9b65d_8ed8dae0
Bytes: 449
Another way to reason about this: The access flag had been set before the class status is set to initialized. The class status store is a store release (StoreSequentiallyConsistent) and there are multiple status stores as the status changes through loaded->resolved->initialized. If we see the status initialized in this status load here, we shouldn't see the stale access flags value in the second load that won't be reordered above the first load.

909:0-918:21
Wed Oct 14 10:31:55 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7fa9b65d_8ed8dae0
UUID: ff8686d4_44564043
Bytes: 167
I'll take the ARMv8 manual answer as satisfactory. (I'm not taking the reasoning about StoreSequentiallyConsistent because we're not doing LoadSequentiallyConsistent.)

960:65-960:73
Tue Oct 13 18:00:49 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: aadf6a22_a14df859
Bytes: 179
I think the assertion should be right here:

    #if ROSALLOC_SLOT_NEXT_OFFSET != MIRROR_OBJECT_CLASS_OFFSET
    #error "Class pointer needs to overwrite next pointer."
    #endif

960:65-960:73
Tue Oct 13 20:05:38 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: aadf6a22_a14df859
UUID: df39c202_ba86e1db
Bytes: 4
Done

