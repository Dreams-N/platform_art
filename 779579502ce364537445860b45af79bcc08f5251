Revision: 779579502ce364537445860b45af79bcc08f5251
Patch-set: 3
File: runtime/arch/arm/quick_entrypoints_arm.S

909:0-918:21
Tue Oct 13 18:00:49 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ff13e649_1c7bd9af
Bytes: 212
This will prevent reordering of memory accesses from the current CPU. But is this really enough? Or, could the CPU still use stale flags from its own L1 data cache after fetching a new status from the actual RAM?

909:0-918:21
Tue Oct 13 19:53:03 2015 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ff13e649_1c7bd9af
UUID: dfb462b2_4fd41e79
Bytes: 750
This is fine.  The ARM v8 manual I have says:

B2.7.2:

If an address dependency exists between two reads or between a read and a write, then those memory
accesses are observed in program order by all observers within the shareability domain of the memory
address being accessed.
The ARMv8 architecture relaxes this rule for execution where the second read is generated by a Load
Non-Temporal Pair instruction. See Load/Store Non-temporal Pair on page C2-132 and Load/Store
SIMD and Floating-point Non-temporal pair on page C2-136.


This is followed by a section on "Address dependencies and order", which clearly includes this case.

I believe this rule has been there since the beginning of time.  And it's required to make Java final fields work.

960:65-960:73
Tue Oct 13 18:00:49 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: aadf6a22_a14df859
Bytes: 179
I think the assertion should be right here:

    #if ROSALLOC_SLOT_NEXT_OFFSET != MIRROR_OBJECT_CLASS_OFFSET
    #error "Class pointer needs to overwrite next pointer."
    #endif

