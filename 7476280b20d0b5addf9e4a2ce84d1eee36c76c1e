Revision: 7476280b20d0b5addf9e4a2ce84d1eee36c76c1e
Patch-set: 2
File: runtime/gc/heap.cc

2187:50-2187:69
Fri Jan 24 22:16:33 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b2fdee74_f2ca4888
Bytes: 559
Was what happened that the gc duration got longer with the heap verification turned on, which caused remaining_bytes to get larger and concurrent_start_bytes_ to get smaller, which caused more frequent GC invocations?

Assuming that, in the normal case (ie. with the heap verification turned off), if there's an app that either allocates fast (higher allocation rate) or causes long GC durations (due to a large heap size, etc.), then could this change increase the chance that the concurrent GC starts too late (ie. can't keep up with the mutator) in theory?

2187
Fri Jan 24 22:23:00 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b2fdee74_f2ca4888
UUID: 7239b600_4687068f
Bytes: 382
Yes, that was the main reason that the tests were running so slow. Since the remaining_bytes was > min_free we would always run sticky GC back to back. This was especially bad since the heap verification runs with all mutators paused. Regarding heap size.

If the GC starts later it will still keep up, just the heap will grow to a slightly larger size then it otherwise would have.

