Revision: 00db8f5e521e4b0fc7454c7e43d2c910ac30e441
Patch-set: 5
File: runtime/entrypoints/quick/quick_jni_entrypoints.cc

68:7-68:28
Tue Sep 29 23:46:51 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2e2e2591_23a31019
Bytes: 35
Only run if env->check_jni is true?

68:7-68:28
Wed Sep 30 16:05:34 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2e2e2591_23a31019
UUID: 0e5fa128_0747fe18
Bytes: 130
The implementation checks that (difference between this and the Impl). As it's in the .h file, I'd expect that to be inlined here.

File: runtime/jni_env_ext.cc

116:0-128:3
Wed Sep 30 08:24:30 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 55712e1a_c5e03aff
Bytes: 29
Why don't you use the height?

116:0-128:3
Wed Sep 30 16:05:34 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 55712e1a_c5e03aff
UUID: 9555663b_b7444818
Bytes: 140
This one's faster, I only need to find the immediate caller and not traverse the complete stack (you need to pass over all transitions etc).

202:63-204:64
Wed Sep 30 08:24:30 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b57c2af2_e8c4337e
Bytes: 55
Well wouldn't that also just optimize the failing case?

202:63-204:64
Wed Sep 30 16:05:34 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b57c2af2_e8c4337e
UUID: b5398a03_e098c2fa
Bytes: 199
These are ordered. So the current frame entries are at the end, and you can detect when you go to the next frame. In the passing case, you'll immediately find something != current_frame and can stop.

202:63-204:64
Wed Sep 30 16:14:46 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b5398a03_e098c2fa
UUID: 55712e1a_45fd2a29
Bytes: 43
How do you detect you go to the next frame?

202:63-204:64
Wed Sep 30 16:44:16 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 55712e1a_45fd2a29
UUID: d55b5e6b_bca38d7a
Bytes: 497
The first time you find pair.first != current_frame.

If things are locked according to the rules, the vector forms a stack wrt/ frames. You may freely lock and unlock in a frame, but you need to unlock all monitors in the current frame when unlocking. So you get something like:

 [<0,mon1>,<0,mon2>,<#1,mon1>,<#1,mon3>,<#2,monX>,<#3,monY>,...]

If you go backwards, you either have #X == current_frame and have some locked but not unlocked monitors, or it's different (and should be the parent).

202:63-204:64
Wed Sep 30 16:50:46 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d55b5e6b_bca38d7a
UUID: 35703a18_2474b297
Bytes: 143
I see. At this point of the discussion, may be we would have saved us some time if you did actually start from the end. How hard is that to do?

202:63-204:64
Wed Sep 30 16:56:04 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 35703a18_2474b297
UUID: 9555663b_1789b460
Bytes: 123
The change is in the foreach loop (which has to be replaced with an explicit iterator walk). Will implement in the next PS.

File: runtime/jni_env_ext.h

115:78-117:30
Wed Sep 30 08:24:30 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 55712e1a_a5e33e09
Bytes: 47
Also explain why it's a vector and not a stack.

File: runtime/jni_internal_test.cc

610:20-611:37
Wed Sep 30 08:24:30 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 75ab929e_be01f94a
Bytes: 17
nit: one per line

