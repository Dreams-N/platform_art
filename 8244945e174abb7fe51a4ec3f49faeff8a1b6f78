Revision: 8244945e174abb7fe51a4ec3f49faeff8a1b6f78
Patch-set: 5
File: runtime/arch/arm64/quick_entrypoints_arm64.S

1853
Thu Jun 26 20:42:19 2014 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a4f851d3_8934bd00
Bytes: 673
My only worry here is that future c or assembly versions of memcmp16 might use x14, x15. I have used a more conservative approach in my tree:


1852 .Ldo_memcmp16:
1853     /* save lr, and return value if comparison equal */
1854     stp x0, x30, [sp, #-16]!
1855 
1856     /* set-up args for __memcmp16 */
1857     mov x0, x2
1858     uxtw x2, w3
1859 
1860     bl __memcmp16
1861 
1862     /* restore lr, and return value if comparison equal */
1863     ldp x1, x30, [sp], #16
1864 
1865     /* if the strings are equal (i.e. x0 == 0) then return length comparison */
1866     cmp x0, #0
1867     csel x0, x1, x0, eq
1868 
1869     ret
1870 END art_quick_string_compareto

1853
Thu Jun 26 21:16:26 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a4f851d3_8934bd00
UUID: c4fb85cc_2a249bcd
Bytes: 152
That's why I put a WARNING into memcmp16_arm64.S. :-) I'll discuss with Ian whether we should include this optimization (which I think is nice to have).

