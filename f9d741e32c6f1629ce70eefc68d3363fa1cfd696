Revision: f9d741e32c6f1629ce70eefc68d3363fa1cfd696
Patch-set: 1
File: /COMMIT_MSG

18:36-18:39
Fri Nov 20 17:28:43 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 169a6aee_f0a3c8d6
Bytes: 94
x86 doesn't special handle the shifts by 1. So I don't think this mention is appropriate here.

File: compiler/optimizing/instruction_simplifier.cc

171
Fri Nov 20 16:56:59 2015 +0000
Author: Serban Constantinescu <1072549@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 5bfc0b2b_47f624bd
Bytes: 109
Vladimir, is there any example in particular that you have in mind when you mention that this is not helping?

171
Fri Nov 20 17:01:39 2015 +0000
Author: Alexandre Rames <1052304@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 5bfc0b2b_47f624bd
UUID: 7b5c6f36_d339b7ae
Bytes: 55
For example the merge of shifts into binary operations!

171
Fri Nov 20 17:26:27 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7b5c6f36_d339b7ae
UUID: d67c5259_968efcde
Bytes: 395
I'm just saying that I'm not aware of any place where it would help.

Btw., I see code size increase (Nexus 5: boot.oat +4KiB) but I believe it's due to register allocation as add-long declares kNoOutputOverlap while shl-long conservatively says kOutputOverlap even for constant shifts. Since the current register allocator never generates partial overlap, we could use kNoOutputOverlap instead.

