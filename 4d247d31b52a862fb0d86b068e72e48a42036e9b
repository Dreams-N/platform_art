Revision: 4d247d31b52a862fb0d86b068e72e48a42036e9b
Patch-set: 1
File: runtime/mirror/class-inl.h

513
Tue May 20 21:07:43 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 9f1ab865_06d7ff7e
Bytes: 30
Nice, this looks much cleaner.

File: runtime/mirror/class.h

378
Tue May 20 21:07:43 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 9f1ab865_a6896baa
Bytes: 75
Shouldn't these have a SHARED_LOCKS_REQUIRED(Locks::mutator_lock_) on them?

378
Tue May 20 21:56:26 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 9f1ab865_a6896baa
UUID: 9f1ab865_21b30588
Bytes: 226
I think it was there for the GetInstanceField() call and GetClass() call in the old version of this function and the new version does not access the heap. And, it does not fail the thread safety analysis. So, looks fine to me.

378
Tue May 20 22:05:27 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 9f1ab865_21b30588
UUID: 1f440856_a964915d
Bytes: 134
What if the GC is moving the roots and another thread reading java_lang_reflect_ArtField_ without the mutator lock? Sounds racy to me.

378
Wed May 21 00:36:44 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1f440856_a964915d
UUID: 9f2f188c_d14b0493
Bytes: 494
Added the annotations back.

So, my original thinking was that since those fields aren't part of the heap and are roots, we don't need a mutator lock when accessing those fields.

But, it's right that even when GC has an exclusive lock on the mutator lock (and the heap), a mutator thread in the native mode could could call JNI routines, which in theory might accidentally lead to these functions. In that case, there's nothing that prevents accessing the fields while GC might be moving them.

