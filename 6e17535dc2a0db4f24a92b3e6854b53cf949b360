Revision: 6e17535dc2a0db4f24a92b3e6854b53cf949b360
Patch-set: 3
File: compiler/dex/quick/x86/utility_x86.cc

576:0-576:44
Thu Jul 24 16:45:23 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f93914b5_6ce7eef4
Bytes: 168
Is the bug that this is never true? Well it looks currently that it could be true, but that's a bug in that we should generating PC relative loads using RIP addressing.

576:0-576:44
Thu Jul 24 17:31:35 2014 +0000
Author: Alexei Zavjalov <1039893@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f93914b5_6ce7eef4
UUID: 9932d8d1_4d5b0d68
Bytes: 682
Seems like there is no bug here. I've checked it on a simple test like:

public static double foo(double a) {
   return a / 500000000000.0d;
}

Compiler generated loading through const pool in both x86 and x86_64 cases (without this patch). The problem was in my test, I made it based on my Min/Max patch which was not enabled in AnalyzeInvokeStatic, and after I checked the generated code, I found out that it used 2 core regs. So that was my mistake.

Seems like this (loading through const pool) is not the optimal method for x86_64, because compiler generates an additional call/pop in a beginning of the function and use the memory access to const pool, which can be expensive.

576:0-576:44
Thu Jul 24 17:39:58 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 9932d8d1_4d5b0d68
UUID: d9461042_a7be5198
Bytes: 682
The reason the call-pop is generated is that x86 doesn't have RIP addressing, while x86-64 does. The codegen choices are:

mov rX, #value
movd xmmY, rX

or

movd xmmY, rip:[literal pool offset to #value]

my experience has been the latter is better in that it at least uses 1 fewer register.

I'm happy to have the two implementation choices be available under an instruction set features flag. I'd like if we could fix the non-use of RIP addressing as that also impacts the switch implementation.

I'm happy to take this code relatively as-is and follow up on the other issues, but I'd like the structure of the float code to match that of the int code below. As I commented below.

576:0-576:44
Thu Jul 24 17:47:20 2014 +0000
Author: Alexei Zavjalov <1039893@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d9461042_a7be5198
UUID: 7937e4c3_8cb8a766
Bytes: 24
I agree, will rework it.

602:0-612:9
Thu Jul 24 16:45:23 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f93914b5_cc14621d
Bytes: 229
which means we always come in here, and this code is 32-bit specific?
Should this code do what the code below does and do:
if (r_dest.IsPair()) {
  ... what we have 32-bit code
} else {
  ... the code you added above for 64-bit
}

