Revision: 3c449228324890b10b43d08738a17e950a6f2ba6
Patch-set: 3
File: compiler/optimizing/code_generator.h

193:20-193:67
Fri Jan 22 09:55:33 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b48efeed_20fd2ad1
Bytes: 81
Can we avoid this? It's pretty bizarre to move something to a void destination...

193:20-193:67
Fri Jan 22 16:19:35 2016 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b48efeed_20fd2ad1
UUID: 142fca8d_aee2571c
Bytes: 158
I was gonna get rid of it entirely but ARM64 and MIPS64 do sanity checks on it (if not kPrimVoid). So comes down to whether we want to preserve those DCHECKs.

193:20-193:67
Mon Jan 25 09:26:35 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 142fca8d_aee2571c
UUID: b408be64_50118c9d
Bytes: 149
Looking at the code in arm64, it's not just a sanity check is it? It actually affects what you're going to generate. So the method might get void in.

193:20-193:67
Mon Jan 25 09:35:24 2016 +0000
Author: Alexandre Rames <1052304@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b408be64_50118c9d
UUID: 3415ae84_84baa684
Bytes: 89
The default argument could be removed here and only apply to the overridden arm64 helper.

193:20-193:67
Mon Jan 25 12:36:09 2016 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 3415ae84_84baa684
UUID: 940bba60_4f4c4dca
Bytes: 293
Yea, the argument is used to force the operation on a number of bits.
 
I stumbled across it when I added the other locations helpers ... and I think it's not very intuitive.

Since you're refactoring this, could we replace it with a boolean or enum to force the move to use 32 or 64bit types?

193:20-193:67
Mon Jan 25 13:53:45 2016 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 940bba60_4f4c4dca
UUID: f4feb66e_d203c4eb
Bytes: 162
So when exactly would we need to specify the width? Because arm64 and mips64 infer it from the locations if kPrimVoid and x86_64 never used it in the first place.

File: compiler/optimizing/code_generator_x86.cc

1021:5-1021:72
Fri Jan 22 09:55:33 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 3434cedb_cf66c12b
Bytes: 75
Isn't that the other way around? The ParallelMoveResolver may request temp?

1021:5-1021:72
Fri Jan 22 16:19:35 2016 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 3434cedb_cf66c12b
UUID: b4dc3efe_90e8f4cf
Bytes: 656
This is my limited understanding of how the swap resolver works, so please correct me if I'm wrong.

In the original Move32 function, a StackSlot->StackSlot moves the value through stack with push+pop. The ParallelMoveResolver, on the other hand, requests EAX with ScratchRegisterScope and does mov+mov with that temp register.

Now that I'm looking at how the ScratchRegisterScope works, however, it looks like we cannot do that - it would never spill EAX even if used by the caller of this. Which would mean that DoubleStackSlot->DoubleStackSlot in Move64 is broken because it uses the move resolver. Looking at use sites, it never hits that case though.

1021:5-1021:72
Mon Jan 25 09:26:35 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b4dc3efe_90e8f4cf
UUID: f4ccf67e_e2cd468c
Bytes: 75
Not sure why you're saying it's broken? We should just push eax and pop it?

1022:5-1023:68
Fri Jan 22 09:55:33 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 742ac67b_3145aa2e
Bytes: 59
I don't see why this solves the temp issue stated before...

