Revision: b05f725bd9a7a22f6b57e2b121df1a26e326b9e0
Patch-set: 3
File: compiler/dex/quick/gen_invoke.cc

820:82-820:91
Tue Nov 25 07:02:54 2014 +0000
Author: Zheng Xu <1042649@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 7f526d24_3ab46978
Bytes: 595
This is a bit different with the original code, and it is better since it avoids duplicated copy.

But I think the correct algorithm should be :
  first_after_last_mapped_in += adjust;
  regs_left_to_pass_via_stack -= adjust;
  regs_left_to_pass_via_stack = GenDalvikArgsBulkCopy(info, first_after_last_mapped_in, regs_left_to_pass_via_stack);

Otherwise, first_after_last_mapped_in + regs_left_to_pass_via_stack will be wrong which is used by the below loop which handles the stack arguments. But maybe we need to find a better name for first_after_last_mapped_in, for example, stack_map_start.

820:82-820:91
Tue Nov 25 07:55:22 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7f526d24_3ab46978
UUID: 7f526d24_baa7394b
Bytes: 886
In both loops below (for stack and reg arguments) we are starting from the first parameter and iterates by the size of the argument. split wide we'd like to handle in reg handling part. So consider the cases:
1) no split of last wide arg. Then no problem at all. In the loop below we are iterating from the beginning up to the end (if bulk did not copied) or till the last mapped (if bulk did its job).
2) last wide is split. In the loop for stack we sill iterate from the beginning up to the end (if bulk did not copied) and split will be skipped because we increment iterator by argument size and we will not consider high part (for the low part valid register will be reported). Or up to the last mapped. split will be skipped as well.

Now in the reg part we will iterate up to the last mapped (which is low part) and will handle high part there.

So everything seems correct to me.

820:82-820:91
Tue Nov 25 08:15:09 2014 +0000
Author: Zheng Xu <1042649@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7f526d24_baa7394b
UUID: 7f526d24_7a9301e8
Bytes: 482
The problem is not on the high part split register. There is problem with the last stack register.

For example, we have the map like, 012(register/stack) 3(high part of 2) 456(stack). first_after_last_mapped_in = 3, regs_left_to_pass_via_stack = 4, adjust = 1. It is correct without adjustment.

After GenDalvikArgsBulkCopy(info, 3+1, 4-1), if we copied nothing in the function, regs_left_to_pass_via_stack becomes **3**. It will introduce bug in the next loop. See below comments.

820:82-820:91
Tue Nov 25 09:27:57 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7f526d24_7a9301e8
UUID: df3a79c4_c5ad7afb
Bytes: 22
Got it, you are right.

832:13-832:69
Tue Nov 25 08:15:09 2014 +0000
Author: Zheng Xu <1042649@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: df3a79c4_45d06a88
Bytes: 227
Continue with the comments in line 820.

This will be 6. We know register 3 will be handled in the next loop and regs_left_to_pass_via_stack was reduced by one. But in this loop, we cover registers 012345. register 6 is missed.

