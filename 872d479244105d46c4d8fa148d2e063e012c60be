Revision: 872d479244105d46c4d8fa148d2e063e012c60be
Patch-set: 1
File: runtime/mirror/object.cc

50
Thu Apr 10 21:10:11 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 79027fbc_2721a484
Bytes: 148
I think the SetFieldObject for the object class could cause problems for the large objects? They aren't necessarily in the card table address range.

50
Thu Apr 10 22:47:53 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 79027fbc_2721a484
UUID: f97e6f24_89d36e26
Bytes: 65
Sounds right. Will use SetFieldObjectWithoutWriteBarrier instead.

50
Thu Apr 10 22:51:32 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f97e6f24_89d36e26
UUID: b9add7fe_92bb7ced
Bytes: 123
That should work as long as we don't delete the WriteBarrier calls in CopyObject. Otherwise it could cause heap corruption.

71
Thu Apr 10 21:10:11 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f97e6f24_96c5c94d
Bytes: 156
Nice use of VisitReferences :) I think you need to pass in a java lang ref reference visitor. You can use the same visitor if you overload operator() again.

71
Thu Apr 10 22:47:53 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f97e6f24_96c5c94d
UUID: f97e6f24_89eb6e8b
Bytes: 4
Done

