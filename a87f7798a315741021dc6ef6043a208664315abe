Revision: a87f7798a315741021dc6ef6043a208664315abe
Patch-set: 1
File: compiler/optimizing/builder.cc

747:2-747:91
Wed Mar 18 19:16:59 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 06bbfcf2_3ecf31db
Bytes: 204
I am wondering: Is it possible that this can go wrong?  The code uses the current method's dex cache for this lookup, so the outer method. What if the class is not declared in the outer method's dex file?

747:2-747:91
Wed Mar 18 21:43:40 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 06bbfcf2_3ecf31db
UUID: 06a21cbf_83926023
Bytes: 256
The NeedsDexCache in HInstruction is here to prevent generating code for this situation. Indeed the storage_index is relative to the current dex file, which will not work if we use the most outer method (assuming the most outer is in a different dex file).

747:2-747:91
Wed Mar 18 22:41:45 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 06a21cbf_83926023
UUID: a6d4f037_300086b7
Bytes: 547
I see. So you're doing the work, but then let the inliner throw it away. I'm not sure I like that design, as it doesn't make it explicit here that most likely all the outer_dex_cache is overhead. (My running assumption is that there's a lot of cross-class static accesses.)

I guess the runtime entrypoints haven't been extended to support it, but maybe it's worth the effort to check whether there is a type index in the current dex file that matches? Another approach would be to try to load the ArtMethod for the inlined method, when necessary.

747:2-747:91
Thu Mar 19 10:33:32 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a6d4f037_300086b7
UUID: 666bd831_e65f00f9
Bytes: 435
About your first point: it's kind of an inlining decision/implementation state. At some point we'll be able to reference other dex cache in an inlined method. So yes, the builder does some extra work, but inlining heuristics should not mess with the builder. Also, it's only done once, as we setup the flag on the method that it's not worth inlining.

About your second point: yes, we could implement this improvement in a next change.

