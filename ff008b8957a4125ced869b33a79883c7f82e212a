Revision: ff008b8957a4125ced869b33a79883c7f82e212a
Patch-set: 1
File: compiler/dex/quick/gen_invoke.cc

410:0-411:31
Fri Nov 21 10:30:42 2014 +0000
Author: Zheng Xu <1042649@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 9f448158_8f5b153f
Bytes: 123
This generates more ldr/str for split long(ignoring arm soft-float), but it really make things easier and fits all targets.

410:0-411:31
Fri Nov 21 10:50:16 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 9f448158_8f5b153f
UUID: df3a79c4_11a2acb6
Bytes: 476
I agree with you. If it is an performance problem we can handle this in more optimal way, say to add a check if destination is promoted reg then run virtual function like OpRegCopy(dest_wide_reg, reg, mem location) and each architecture can implement this in its way (taking into account that dest_wide_reg can be fp).

I would prefer to do this optimization (if it is required) in a separate CL if you do not mind. If this is a critical, let me know and I will update a code.

410:0-411:31
Fri Nov 21 11:06:29 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: df3a79c4_11a2acb6
UUID: 9f448158_0faf2577
Bytes: 218
By the way the similar pattern can be met in several other places (everywhere we should handle split long). They are LoadArg, LoadArgDirect and GenDalvikArgs. If we decide to fix this we should fix that places as well.

410:0-411:31
Fri Nov 21 11:21:44 2014 +0000
Author: Zheng Xu <1042649@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: df3a79c4_11a2acb6
UUID: 7f526d24_86454a10
Bytes: 53
It is something could do, but I don't it is critical.

410:0-411:31
Fri Nov 21 11:21:44 2014 +0000
Author: Zheng Xu <1042649@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 9f448158_0faf2577
UUID: 7f526d24_46eab288
Bytes: 241
Yes, that's great you've removed the assumption that 64-bit register is always 32-bit pairs in all these places, so that we can also remove the redundant source code in int_arm.cc and utility_arm.cc which has TODO comment talking about this.

410:0-411:31
Fri Nov 21 11:29:02 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7f526d24_46eab288
UUID: 9f448158_8f931530
Bytes: 76
I think I've already done it in this patch :)
May be there are other places?

File: compiler/dex/quick/mir_to_lir.h

1777:25-1777:87
Fri Nov 21 10:30:42 2014 +0000
Author: Zheng Xu <1042649@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: df3a79c4_512394d4
Bytes: 34
How about "GetNextReg(char type)"?

1777:25-1777:87
Fri Nov 21 10:50:16 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: df3a79c4_512394d4
UUID: 7f526d24_c6990252
Bytes: 220
This is an interface to implement by each arch, so in the case of "char type" each architecture will need to parse this char. So I prefer to do it in common code and provide only required information. That was my intent.

1777:25-1777:87
Fri Nov 21 11:21:44 2014 +0000
Author: Zheng Xu <1042649@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7f526d24_c6990252
UUID: 9f448158_8fbaf5ad
Bytes: 178
I think parse the char is more clean. And we parse char or PrimitiveType directly to map in registers in all other places, such as trampoline , jni compiler, optimising compiler.

1777:25-1777:87
Fri Nov 21 11:29:02 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 9f448158_8fbaf5ad
UUID: 9f448158_4f776d77
Bytes: 210
Potentially I'm ok with that. But instead of char I would suggest to pass some class as ArgumentType with constructor ArgumentType(char type) and implement getters there for fp, wide and ref. What do you think?

1777:25-1777:87
Fri Nov 21 17:26:06 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 9f448158_4f776d77
UUID: ff5e5d2a_8d0e85a0
Bytes: 122
Do we really have to make it that complicated? Isn't a simple enum enough? That allows a nice simple switch in the callee.

1777:25-1777:87
Mon Nov 24 04:11:55 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ff5e5d2a_8d0e85a0
UUID: df3a79c4_b45f4e64
Bytes: 386
simple switch will not be enough, you need a bit more complex thing basing on pair <wide, fp>. Why don't we like my approach? It does not seem complex to me. And it seems to me operating on fp, wide, ref semantic a bit more natural for GetNextReg than accepting char. Let's do in this way. I will upload my case and if it seems complex to both of you I will re-implement in in your way.

1777:25-1777:87
Mon Nov 24 07:06:57 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: df3a79c4_b45f4e64
UUID: df151930_7faac719
Bytes: 190
Sorry, I don't understand the necessity of the pair. If the enum is ref/int/long/float/double, it covers all combinations (and not more, i.e., your parameters have meaningless combinations).

1786:22-1786:36
Fri Nov 21 10:30:42 2014 +0000
Author: Zheng Xu <1042649@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 7f526d24_4604f2ef
Bytes: 37
How about const char* or std::string?

1786:22-1786:36
Fri Nov 21 10:50:16 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7f526d24_4604f2ef
UUID: 9f448158_afd37910
Bytes: 222
I guess shorty iterator is a more general case (you may extend it and provide any implementation you want). If we provide shorty as string we need also provide whether call is static or not. So I decided to do in this way.

