Revision: 1ff251ae7a90baf5e91d50a33c7af3dca873838b
Patch-set: 3
File: compiler/dex/quick/gen_common.cc

1321:74-1321:75
Wed Apr 23 16:41:27 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2557fb42_40a7dfad
Bytes: 5
Typo?

File: runtime/mirror/array.h

71:17-71:27
Wed Apr 23 17:53:30 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 85fd0775_5c7242f9
Bytes: 308
How about supporting non-object arrays as well?

I'm thinking of something like:

template<typename ComponentType>
static MemberOffset DataOffsetAtIndex(int32_t index) {
  size_t component_size = sizeof(ComponentType);
  return MemberOffset(DataOffset(component_size).SizeValue() + component_size * index);
}

71:17-71:27
Wed Apr 23 18:28:30 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 85fd0775_5c7242f9
UUID: c5137f9f_64a20ace
Bytes: 281
I am not sure I agree. The issue is that on a high level, object arrays contain links to objects. But with your change, one would have to write <HeapReference<mirror::X>> so that component_size gets the right size, which is not as intuitive and straightforward as just <mirror::X>.

71:17-71:27
Wed Apr 23 19:16:31 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c5137f9f_64a20ace
UUID: c5137f9f_049076c9
Bytes: 961
OK. I was going to say the following, but there's already ObjectArray<T>::OffsetOfElement() which we can use in this case?

---

Do we need MirrorType? It does not seem that sizeof(HeapReference<MirrorType>) is a function of MirrorType or MirrorType is propagated to the return type.

If this is only for object arrays, I'd imagine something like:

static MemberOffset ObjectArrayDataOffsetAtIndex(int32_t index) {
  size_t component_size = sizeof(HeapReference<Object>);
  return MemberOffset(DataOffset(component_size).SizeValue() + component_size * index);
}

assuming that we don't need to parameterize it with MirrorType and we'd like to emphasize that it's only for object arrays. We could also consider moving it to object_array.h and losing the "ObjectArray" name prefix.

A minor point: I think the convention is to have MirrorType include the *. So, HeapReference<MirrorType> instead of HeapReference<MirrorType*>, if we need to use MirrorType at all.

71
Thu Apr 24 04:58:16 2014 +0000
Author: Dmitry Petrochenko <1039576@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c5137f9f_049076c9
UUID: a5f76b98_8e791b52
Bytes: 531
Changing notation to HeapReference<Object> could touch almost all source files refactored by Ian Rogers in bounds of 64-bit enabling efforts. Thus it does not sounds reasonable to change HeapReference notation at this moment.

Please note that this patch is just a fix which is required for ongoing efforts on 64-bit quick code generation for multiple platforms. 

I'd suggest to keep the patch as is with simplified notation, supporting only arrays of objects. There are no similar calculations in QCG for non-object arrays AFAIK.

