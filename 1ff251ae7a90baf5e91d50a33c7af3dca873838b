Revision: 1ff251ae7a90baf5e91d50a33c7af3dca873838b
Patch-set: 3
File: compiler/dex/quick/gen_common.cc

1321:74-1321:75
Wed Apr 23 16:41:27 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2557fb42_40a7dfad
Bytes: 5
Typo?

File: runtime/mirror/array.h

71:17-71:27
Wed Apr 23 17:53:30 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 85fd0775_5c7242f9
Bytes: 308
How about supporting non-object arrays as well?

I'm thinking of something like:

template<typename ComponentType>
static MemberOffset DataOffsetAtIndex(int32_t index) {
  size_t component_size = sizeof(ComponentType);
  return MemberOffset(DataOffset(component_size).SizeValue() + component_size * index);
}

71:17-71:27
Wed Apr 23 18:28:30 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 85fd0775_5c7242f9
UUID: c5137f9f_64a20ace
Bytes: 281
I am not sure I agree. The issue is that on a high level, object arrays contain links to objects. But with your change, one would have to write <HeapReference<mirror::X>> so that component_size gets the right size, which is not as intuitive and straightforward as just <mirror::X>.

