Revision: 900d3db0653ffb89a6f8af4424210a543c1f3a08
Patch-set: 1
File: compiler/optimizing/load_store_elimination.cc

737:37-737:68
Wed May 04 18:58:06 2016 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: cd6bef2f_4921c58f
Bytes: 109
What does it mean? When we hunt down original references, we only traverse through null check and bound type.

737:37-737:68
Thu May 05 09:45:43 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cd6bef2f_4921c58f
UUID: edb513f9_1c1eb5a9
Bytes: 100
We could hunt down even further for this particular DCHECK but I'd think it's not worth the trouble.

737:37-737:68
Thu May 05 23:48:29 2016 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: edb513f9_1c1eb5a9
UUID: 6d1763d9_2dbfe50b
Bytes: 182
I just meant the "the null could be behind a field access" part of the comment. A null check/bound check on null is still really null. But a field access on a null isn't really null.

737:37-737:68
Fri May 06 09:58:53 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6d1763d9_2dbfe50b
UUID: cd53efc8_e317b292
Bytes: 53
Sure, it's an NPE. But I don't think we need to care.

737:37-737:68
Fri May 06 23:17:02 2016 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cd53efc8_e317b292
UUID: 928758d1_6107b6bd
Bytes: 151
I just meant it's enough to say "the null could be behind a null check or a bound type". That's actually what we did when we hunt for the original ref.

737:37-737:68
Mon May 09 11:45:58 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 928758d1_6107b6bd
UUID: f2fb3484_cc520f23
Bytes: 144
Not sure I understand. The comment says "..originates from the null constant", which IMO includes HFieldGet on a null. Is the comment confusing?

739:73-739:93
Wed May 04 18:58:06 2016 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: cd6bef2f_29ed6935
Bytes: 69
Kind of ambiguous. "eliminate array gets" seems more straightforward.

739:73-739:93
Thu May 05 09:45:43 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cd6bef2f_29ed6935
UUID: edb513f9_fc7789f7
Bytes: 4
Done

742
Wed May 04 18:58:06 2016 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: cd6bef2f_e9b43148
Bytes: 680
I think there may be very rare cases where storing a value into a field of null constant ref, and loading a field (which is actually a different field) with the same offset from null constant ref, may trigger this assert since it's not array get. So we should probably relax the assert more.

It's almost not necessary. FindHeapLocationIndex() does compare GetDeclaringClassDefIndex() of the resolved field (for type based aliasing analysis), however since currently we don't compare dex_file (which can create unnecessary aliases, but very rare and benign), it might treat two null constant fields that should be different as the same instead,
and then try to eliminate the load.

742
Thu May 05 09:45:43 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cd6bef2f_e9b43148
UUID: edb513f9_bc8101d7
Bytes: 904
> I think there may be very rare cases where storing a value into a
 > field of null constant ref, and loading a field (which is actually
 > a different field) with the same offset from null constant ref, may
 > trigger this assert since it's not array get. So we should probably
 > relax the assert more.

Really? Fields are correctly typed from the beginning, so GVN will not try to merge them. Don't you do the same type check in lse?

 > 
 > It's almost not necessary. FindHeapLocationIndex() does compare
 > GetDeclaringClassDefIndex() of the resolved field (for type based
 > aliasing analysis), however since currently we don't compare
 > dex_file (which can create unnecessary aliases, but very rare and
 > benign), it might treat two null constant fields that should be
 > different as the same instead,
 > and then try to eliminate the load.

ok, so IIUC you agree the DCHECK can stay as it is?

742
Thu May 05 09:45:43 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cd6bef2f_e9b43148
UUID: edb513f9_dc7ccddc
Bytes: 4
Done

742
Thu May 05 23:48:29 2016 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: edb513f9_bc8101d7
UUID: 6d1763d9_1fbc84c9
Bytes: 334
LSE currently uses GetDeclaringClassDefIndex() (plus offset) but not dex_file so strictly it's not correctly typed. If CL 220683 goes in, we can type fields correctly with the ArtField in FieldInfo.

So the assert can stay the same if we do a follow-up in LSE after CL 220683 goes in, or CL 220683 includes the LSE part of the change.

742
Fri May 06 09:58:53 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6d1763d9_1fbc84c9
UUID: cd53efc8_a311ba9f
Bytes: 169
I know all this is very confusing, but please consider this change as the fix for b/27831001. CL 220683 will just end up being an optimizing where we cache the ArtField.

742
Fri May 06 23:17:02 2016 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cd53efc8_a311ba9f
UUID: 928758d1_24977c4a
Bytes: 275
CL 220683 would help the field typing in LSE (with some follow-up by using the ArtField instead of only the declaring class plus offset currently used in LSE). Before that happens, heap_value/instruction on line 741/742 may also be instance field get, although very unlikely.

742
Mon May 09 11:45:58 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 928758d1_24977c4a
UUID: f2c25456_b48700c7
Bytes: 4
Yes.

