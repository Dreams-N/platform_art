Revision: 42c3c33df8b6eefc4ba532f1981282510f109928
Patch-set: 3
File: runtime/gc/allocation_record.cc

110:40-110:50
Fri Jun 26 23:53:11 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 93a1f560_c26566c2
Bytes: 535
I think there is an invariant that IsMarkedCallback() won't get nullptr passed to it (see MarkSweep, SemiSpace or ConcurrentCopying) . It seems that this CL breaks that if we ever collect class objects. Before this CL, it was fine as we delete the entry if the object gets collected and the GcRoot becomes nullptr. It isn't the case any more as we now keep nullptr GcRoots around.

Besides, there's no point in calling callback if old_object is nullptr (for performance reason).

How about not calling 'callback' if old_object is null?

110:40-110:50
Sat Jun 27 03:08:47 2015 +0000
Author: Man Cao <1073545@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 93a1f560_c26566c2
UUID: 934c958c_fe6ec128
Bytes: 4
Done

132:33-132:41
Fri Jun 26 23:53:11 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 934c958c_98d9259a
Bytes: 156
Same here.

Not sure why it isn't already causing an error as old_object can actually be nullptr here (as we do collect those objects unlike class objects)?

132:33-132:41
Sat Jun 27 03:08:47 2015 +0000
Author: Man Cao <1073545@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 934c958c_98d9259a
UUID: 138ee5ef_b4a098aa
Bytes: 91
Good find! Fixed in CL 156975. Not sure why the DCHECK() for nullptr was not fired, either.

File: runtime/gc/heap.cc

3720:6-3720:28
Sat Jun 27 17:09:40 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 73a3a180_c3747648
Bytes: 118
Can we see the value of this change in the middle of a GC and end up with mismatched allow/disallow calls? Is it safe?

3720:6-3720:28
Sat Jun 27 22:09:41 2015 +0000
Author: Man Cao <1073545@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 73a3a180_c3747648
UUID: f390710b_0e45b3c6
Bytes: 1009
Yes, this value can change in the middle of a GC.

For a change from Enabled to Disabled, it is safe because disabling tracking deallocates the entries, thus GC won't need to sweep entries or call AllowNewAllocationRecords().

For a change from Disabled to Enabled, the result is that AllowNewAllocationRecords() and EnsureNewAllocationRecordsDisallowed() could be called when new allocations should be disallowed but are actually allowed. This might fail the CHECK() in EnsureNewAllocationRecordsDisallowed(). But it is safe for AllowNewAllocationRecords(), which just does a redundant store of "true" and a redundant Broadcast().

It is also possible that new allocation records get added to the list in this period, and they will be deleted on the next sweep. But I think this is OK since it just misses the first few allocation records, which is the same result as the user not clicking the button soon enough.

Therefore I think I can just remove EnsureNewAllocationRecordsDisallowed() to fix this issue.

3720:6-3720:28
Mon Jul 06 20:52:43 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f390710b_0e45b3c6
UUID: 736d61b3_59466373
Bytes: 540
> It is also possible that new allocation records get added to the list in this period, and they will be deleted on the next sweep. But I think this is OK since it just misses the first few allocation records, which is the same result as the user not clicking the button soon enough.

Is it safe for a new allocation record (a class strong root and a weak object root) to be added while GC is sweeping? How is this different such that the original reason that we needed to disable new allocation records during sweeping does not apply here?

3720:6-3720:28
Tue Jul 07 01:40:28 2015 +0000
Author: Man Cao <1073545@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 736d61b3_59466373
UUID: 135425e3_f93c8b81
Bytes: 553
It is thread-safe because the sweeping is also guarded by Locks::alloc_tracker_lock_. The worst case is the new allocation record get removed, or the object root or class root is set to null. The null class root case is not handled though, which I'll fix.

It is different because in this case, we could only miss records in the *first* GC cycle after user clicks the button and before the sweep. Without the disabling new records, in *every* subsequent GC cycle new allocations that happen between DisallowNewSystemWeaks() and the sweep will be missed.

