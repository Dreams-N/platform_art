Revision: 42c3c33df8b6eefc4ba532f1981282510f109928
Patch-set: 3
File: runtime/gc/allocation_record.cc

110:40-110:50
Fri Jun 26 23:53:11 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 93a1f560_c26566c2
Bytes: 535
I think there is an invariant that IsMarkedCallback() won't get nullptr passed to it (see MarkSweep, SemiSpace or ConcurrentCopying) . It seems that this CL breaks that if we ever collect class objects. Before this CL, it was fine as we delete the entry if the object gets collected and the GcRoot becomes nullptr. It isn't the case any more as we now keep nullptr GcRoots around.

Besides, there's no point in calling callback if old_object is nullptr (for performance reason).

How about not calling 'callback' if old_object is null?

110:40-110:50
Sat Jun 27 03:08:47 2015 +0000
Author: Man Cao <1073545@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 93a1f560_c26566c2
UUID: 934c958c_fe6ec128
Bytes: 4
Done

132:33-132:41
Fri Jun 26 23:53:11 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 934c958c_98d9259a
Bytes: 156
Same here.

Not sure why it isn't already causing an error as old_object can actually be nullptr here (as we do collect those objects unlike class objects)?

132:33-132:41
Sat Jun 27 03:08:47 2015 +0000
Author: Man Cao <1073545@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 934c958c_98d9259a
UUID: 138ee5ef_b4a098aa
Bytes: 91
Good find! Fixed in CL 156975. Not sure why the DCHECK() for nullptr was not fired, either.

File: runtime/gc/heap.cc

3720:6-3720:28
Sat Jun 27 17:09:40 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 73a3a180_c3747648
Bytes: 118
Can we see the value of this change in the middle of a GC and end up with mismatched allow/disallow calls? Is it safe?

3720:6-3720:28
Sat Jun 27 22:09:41 2015 +0000
Author: Man Cao <1073545@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 73a3a180_c3747648
UUID: f390710b_0e45b3c6
Bytes: 1009
Yes, this value can change in the middle of a GC.

For a change from Enabled to Disabled, it is safe because disabling tracking deallocates the entries, thus GC won't need to sweep entries or call AllowNewAllocationRecords().

For a change from Disabled to Enabled, the result is that AllowNewAllocationRecords() and EnsureNewAllocationRecordsDisallowed() could be called when new allocations should be disallowed but are actually allowed. This might fail the CHECK() in EnsureNewAllocationRecordsDisallowed(). But it is safe for AllowNewAllocationRecords(), which just does a redundant store of "true" and a redundant Broadcast().

It is also possible that new allocation records get added to the list in this period, and they will be deleted on the next sweep. But I think this is OK since it just misses the first few allocation records, which is the same result as the user not clicking the button soon enough.

Therefore I think I can just remove EnsureNewAllocationRecordsDisallowed() to fix this issue.

