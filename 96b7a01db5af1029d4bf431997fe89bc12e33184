Revision: 96b7a01db5af1029d4bf431997fe89bc12e33184
Patch-set: 2
File: compiler/dex/quick/x86/target_x86.cc

482
Thu Jul 10 17:16:50 2014 +0000
Author: Chao-ying Fu <1010712@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d9045004_f94dd0aa
Bytes: 69
rs_fr12 to rs_fr15 are still clobbered by an external C call.  Right?

482
Thu Jul 10 17:31:19 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d9045004_f94dd0aa
UUID: 993578d4_955e86cd
Bytes: 248
Yes, but we do not do external call directly, we do it using stubs which saves fr12-15, so we should be safe. Clobbering fr12-15 does not make any sense here because Clobber of promoted register does not make any sense (see Clobber implementation).

482
Thu Jul 10 17:44:05 2014 +0000
Author: Chao-ying Fu <1010712@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 993578d4_955e86cd
UUID: 598dc0f1_2081aa3f
Bytes: 130
Ok.  ART callee-saved registers (that are caller-saved in a native ABI) should not be included here.  This is kind of tricky.  :-)

487
Thu Jul 10 17:16:50 2014 +0000
Author: Chao-ying Fu <1010712@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 7988c4e2_c1800271
Bytes: 88
Can rs_rBX be skipped?  It is a callee-saved register in the native 32-bit ABI.  Thanks!

487
Thu Jul 10 17:31:19 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7988c4e2_c1800271
UUID: 19298885_b18aba07
Bytes: 59
rbx is caller save in 32-bit API but callee save in 64-bit.

487
Thu Jul 10 17:44:05 2014 +0000
Author: Chao-ying Fu <1010712@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 19298885_b18aba07
UUID: 7988c4e2_24a0dc8e
Bytes: 99
rbx is a callee saved in both native 32-bit and 64-bit ABI.  We should be skip rbx always.  Thanks!

487
Thu Jul 10 18:05:22 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7988c4e2_24a0dc8e
UUID: 593f80b5_13006e99
Bytes: 178
Ok I see what you mean (native ABI). Unfortunately this function is also used in intrinsic before using register directly. To be able to use ebx safely we should clobber it here.

487
Thu Jul 10 18:14:29 2014 +0000
Author: Chao-ying Fu <1010712@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 593f80b5_13006e99
UUID: d9045004_9c7c7afa
Bytes: 201
Four cases: (native, art) = (caller, caller), (callee, caller), (caller, callee), (callee, callee).  We only put registers that are (caller, caller), (callee, caller) in this function.  Right?  Thanks!

487
Thu Jul 10 18:24:36 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d9045004_9c7c7afa
UUID: 593f80b5_f30baab5
Bytes: 160
I see it in this way. Probably it can be changed if we stop using this function for ART things (like intrinsic), then we probably can remove rbx from this list.

File: runtime/arch/x86_64/quick_entrypoints_x86_64.S

898:0-898:36
Thu Jul 10 17:26:19 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 7988c4e2_c46810be
Bytes: 158
This one will need better protection.

There is also one entrypoint in entrypoints_init that is directly a C call. You will have to route that through a stub.

898:0-898:36
Thu Jul 10 17:31:19 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7988c4e2_c46810be
UUID: 993578d4_55a81e61
Bytes: 84
you mean spill all callee saves (both gprs and fprs?)

I will try to find which one.

898:0-898:36
Thu Jul 10 17:40:26 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 993578d4_55a81e61
UUID: 598dc0f1_c01b1e8d
Bytes: 498
For the exception case you want things to be "intact." That worked before as we agreed with native calling convention (i.e., the C compiler will restore all callee-saves). But it's possible gcc/clang will use fp regs for spills or whatever, and not save/restore them. So you need to save and restore them now.

The entrypoint is easy to find. It's "qpoints->pInstanceofNonTrivial = artIsAssignableFromCode;" That's going directly from Quick to native code, potentially losing the "callee-save" FPs.

898:0-898:36
Thu Jul 10 19:41:53 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 598dc0f1_c01b1e8d
UUID: 993578d4_35f59a32
Bytes: 220
Like a hint, instead of moving callee saved xmms to stack we can simply copy xmm12-15 to xmm8-11 due to no-one cares about xmm8-11 and then restore them after the call. It can help us to avoid memory operation, isn't it?

898:0-898:36
Thu Jul 10 19:44:05 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 993578d4_35f59a32
UUID: 598dc0f1_a6071238
Bytes: 156
How do you know that nobody cares? How do you know what exactly artIsAssignableFromCode entails and what GCC decides to do on its own, now or in the future?

898:0-898:36
Thu Jul 10 19:46:35 2014 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 993578d4_35f59a32
UUID: 7988c4e2_0afcbf1a
Bytes: 102
The native ABI allows all XMM registers to be clobbered by the call, so you have to save to the stack.

898:0-898:36
Thu Jul 10 19:48:21 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 598dc0f1_a6071238
UUID: 993578d4_15fa9622
Bytes: 231
Bad idea :) I thought about other side, as soon as it is caller-save then caller have already saved it and we can use it, but you are right callee are free to change it.
Generating ideas at 3am is bad idea :) Need to sleep a bit :)

