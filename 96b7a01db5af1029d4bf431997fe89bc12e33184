Revision: 96b7a01db5af1029d4bf431997fe89bc12e33184
Patch-set: 2
File: compiler/dex/quick/x86/target_x86.cc

482
Thu Jul 10 17:16:50 2014 +0000
Author: Chao-ying Fu <1010712@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d9045004_f94dd0aa
Bytes: 69
rs_fr12 to rs_fr15 are still clobbered by an external C call.  Right?

482
Thu Jul 10 17:31:19 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d9045004_f94dd0aa
UUID: 993578d4_955e86cd
Bytes: 248
Yes, but we do not do external call directly, we do it using stubs which saves fr12-15, so we should be safe. Clobbering fr12-15 does not make any sense here because Clobber of promoted register does not make any sense (see Clobber implementation).

487
Thu Jul 10 17:16:50 2014 +0000
Author: Chao-ying Fu <1010712@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 7988c4e2_c1800271
Bytes: 88
Can rs_rBX be skipped?  It is a callee-saved register in the native 32-bit ABI.  Thanks!

487
Thu Jul 10 17:31:19 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7988c4e2_c1800271
UUID: 19298885_b18aba07
Bytes: 59
rbx is caller save in 32-bit API but callee save in 64-bit.

File: runtime/arch/x86_64/quick_entrypoints_x86_64.S

898:0-898:36
Thu Jul 10 17:26:19 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 7988c4e2_c46810be
Bytes: 158
This one will need better protection.

There is also one entrypoint in entrypoints_init that is directly a C call. You will have to route that through a stub.

898:0-898:36
Thu Jul 10 17:31:19 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7988c4e2_c46810be
UUID: 993578d4_55a81e61
Bytes: 84
you mean spill all callee saves (both gprs and fprs?)

I will try to find which one.

898:0-898:36
Thu Jul 10 17:40:26 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 993578d4_55a81e61
UUID: 598dc0f1_c01b1e8d
Bytes: 498
For the exception case you want things to be "intact." That worked before as we agreed with native calling convention (i.e., the C compiler will restore all callee-saves). But it's possible gcc/clang will use fp regs for spills or whatever, and not save/restore them. So you need to save and restore them now.

The entrypoint is easy to find. It's "qpoints->pInstanceofNonTrivial = artIsAssignableFromCode;" That's going directly from Quick to native code, potentially losing the "callee-save" FPs.

