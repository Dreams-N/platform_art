Revision: fd060ffe569ca2598947080b9ea9e8274467082b
Patch-set: 1
File: compiler/optimizing/locations.h

276:41-276:42
Tue Mar 03 11:56:51 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 92c00617_0ddf118d
Bytes: 58
Why is that not Contains(other) || other.Contains(*this) ?

276:41-276:42
Wed Mar 04 07:57:27 2015 +0000
Author: Zheng Xu <1042649@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 92c00617_0ddf118d
UUID: d2bd1ee7_5749acb8
Bytes: 203
OverlapWith() can work with (R0,R1), (R1,R2) and DoubleStackSlot(sp), DoubleStackSlot(sp+4).

But "Contains(other) || other.Contains(*this)" should also work well with current locations that we generate.

276:41-276:42
Wed Mar 04 11:09:54 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d2bd1ee7_5749acb8
UUID: 12b17657_71c37831
Bytes: 173
We should not generate DoubleStackSlot(sp), DoubleStackSlot(sp+4). Same for registers (at least today, x86 might change this). So I would not bother considering these cases.

File: compiler/optimizing/parallel_move_resolver.cc

286:36-286:58
Tue Mar 03 11:56:51 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 92a646d4_3db16fc6
Bytes: 3
0u?

286:36-286:58
Wed Mar 04 07:57:27 2015 +0000
Author: Zheng Xu <1042649@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 92a646d4_3db16fc6
UUID: d2bd1ee7_17433499
Bytes: 7
Thanks.

335:36-335:58
Tue Mar 03 11:56:51 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d2a43ecd_bf26976e
Bytes: 3
0u?

335:36-335:58
Wed Mar 04 07:57:27 2015 +0000
Author: Zheng Xu <1042649@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d2a43ecd_bf26976e
UUID: f2ba22ed_b8511968
Bytes: 7
Thanks.

390:5-390:61
Tue Mar 03 11:56:51 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 92c00617_edc5e5b5
Bytes: 19
Move inside the if.

390:5-390:61
Wed Mar 04 07:57:27 2015 +0000
Author: Zheng Xu <1042649@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 92c00617_edc5e5b5
UUID: 126ed67a_8916197d
Bytes: 7
Will do

390:62-391:25
Tue Mar 03 11:56:51 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 92c00617_cdc829d1
Bytes: 66
I don't understand this comment, isn't the move already performed?

390:62-391:25
Wed Mar 04 07:57:27 2015 +0000
Author: Zheng Xu <1042649@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 92c00617_cdc829d1
UUID: 126ed67a_e9ea35f6
Bytes: 208
Yes, I will add an example in the comment.

(0->1) (1->0) (1->2) , cycle (0->1) (1->0) will be resolved as (1->scratch) (0->1) (scratch->0). (1->2) will be also performed, if we use 2 as the scratch location.

447:61-447:75
Tue Mar 03 11:56:51 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d2a43ecd_7f0a4fd9
Bytes: 34
But to perform -> But performing ?

447:61-447:75
Wed Mar 04 07:57:27 2015 +0000
Author: Zheng Xu <1042649@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d2a43ecd_7f0a4fd9
UUID: 52f84efa_7b505f2e
Bytes: 7
Thanks.

473:50-473:59
Tue Mar 03 11:56:51 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d2a43ecd_3f04c7c6
Bytes: 49
there should no -> we ensure there is no move ...

473:50-473:59
Wed Mar 04 07:57:27 2015 +0000
Author: Zheng Xu <1042649@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d2a43ecd_3f04c7c6
UUID: 52f84efa_5b4da392
Bytes: 7
Thanks.

480:51-480:55
Wed Mar 04 11:09:54 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 12b17657_b1eb20ab
Bytes: 13
less -> fewer

480:17-480:34
Wed Mar 04 11:09:54 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 929c86d9_8dad21a0
Bytes: 41
something must do -> something we must do

485:26-485:32
Tue Mar 03 11:56:51 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 92a646d4_dd972b1a
Bytes: 24
Why is that not Overlap?

485:26-485:32
Wed Mar 04 07:57:27 2015 +0000
Author: Zheng Xu <1042649@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 92a646d4_dd972b1a
UUID: d2bd1ee7_7ad37555
Bytes: 831
This should be Equals().

For example, after (0,1 -> 2,3) has been performed, we can update (0,1 -> 4,5) with (2,3 -> 4,5). But we cannot update (0 -> 6) with (2,3 -> 6).

And yes, we can update (0 -> 6) with (2 -> 6). But I don't want to rely on how the locations and registers are defined. Because that is backend dependent. On arm32 we have register and register pair overlap, while on arm64 we have W/X overlap(not defined in location currently).

As mentioned in the comment, this helps to improve the generated code quality but not a must. So it is fine to not update (0 -> 6) with (2 -> 6). And I don't think two overlapped locations(0,1 and 0) can be both used as move sources in current optimizing compiler(they can be source and destination in different moves). So I'd rather keep the code simple and backend independent.

492:0-499:3
Tue Mar 03 11:56:51 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d2a43ecd_1f0103b7
Bytes: 112
Is it really worth it trying to reuse old moves? Looks simpler to just append. At least this deserves a comment.

492:0-499:3
Wed Mar 04 07:57:27 2015 +0000
Author: Zheng Xu <1042649@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d2a43ecd_1f0103b7
UUID: d2bd1ee7_5ad0b146
Bytes: 40
You are right. It is not worth doing so.

535:35-535:55
Tue Mar 03 11:56:51 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d2a43ecd_7f112f03
Bytes: 109
You should add a comment that this is only for debugging/dcheck purposes, and why it's important to check it.

535:35-535:55
Wed Mar 04 07:57:27 2015 +0000
Author: Zheng Xu <1042649@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d2a43ecd_7f112f03
UUID: 12b17657_b1be80fb
Bytes: 8
Will do.

537:2-539:3
Tue Mar 03 11:56:51 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 92a646d4_1daeb364
Bytes: 21
Again why this logic?

537:2-539:3
Wed Mar 04 07:57:27 2015 +0000
Author: Zheng Xu <1042649@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 92a646d4_1daeb364
UUID: 12b17657_91c37c85
Bytes: 26
Yes, it can be simplified.

File: compiler/optimizing/parallel_move_resolver.h

174:29-174:45
Tue Mar 03 11:56:51 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d2a43ecd_df215b5a
Bytes: 48
What does it mean to be unblocked by a location?

174:29-174:45
Wed Mar 04 07:57:27 2015 +0000
Author: Zheng Xu <1042649@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d2a43ecd_df215b5a
UUID: f2ba22ed_f857915a
Bytes: 85
Should be : Get move which might be unblocked after we had performed move (loc->XXX).

181:9-181:15
Tue Mar 03 11:56:51 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 92c00617_50d5b26a
Bytes: 19
GetNum -> GetNumber

181:9-181:15
Wed Mar 04 07:57:27 2015 +0000
Author: Zheng Xu <1042649@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 92c00617_50d5b26a
UUID: f2ba22ed_d85ccd81
Bytes: 8
Will do.

File: compiler/optimizing/parallel_move_test.cc

258:0-258:30
Tue Mar 03 11:56:51 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 92a646d4_bd733fa2
Bytes: 30
You can avoid this check here.

258:0-258:30
Wed Mar 04 07:57:27 2015 +0000
Author: Zheng Xu <1042649@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 92a646d4_bd733fa2
UUID: 12b17657_f1c808a3
Bytes: 8
Will do.

281:0-281:32
Tue Mar 03 11:56:51 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 92a646d4_9d78837f
Bytes: 30
You can avoid this check here.

281:0-281:32
Wed Mar 04 07:57:27 2015 +0000
Author: Zheng Xu <1042649@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 92a646d4_9d78837f
UUID: d2bd1ee7_7afa55c7
Bytes: 8
Will do.

300:4-300:32
Tue Mar 03 11:56:51 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 92a646d4_dd7e0b6c
Bytes: 30
You can avoid this check here.

300:4-300:32
Wed Mar 04 07:57:27 2015 +0000
Author: Zheng Xu <1042649@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 92a646d4_dd7e0b6c
UUID: d2bd1ee7_5af791db
Bytes: 8
Will do.

408:21-408:61
Tue Mar 03 11:56:51 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 72147288_8790e8c7
Bytes: 93
We're currenlty doing 4 moves on arm for this. This will create a few more. Can we do better?

408:21-408:61
Wed Mar 04 07:57:27 2015 +0000
Author: Zheng Xu <1042649@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 72147288_8790e8c7
UUID: 12b17657_d1cd04b1
Bytes: 318
This is the choice for backend's AllocateScratchRegister(). 

On arm32, we can prefer D registers as the scratch locations to hold the value of register pairs and also support to move between D and register pairs. If we implement it in this way, it will also be 4 moves on arm32. (2,3 -> D31) (0,1 -> 2,3) (D31 -> 0,1)

408:21-408:61
Wed Mar 04 10:42:14 2015 +0000
Author: Zheng Xu <1042649@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 12b17657_d1cd04b1
UUID: 126ed67a_297b6da8
Bytes: 266
Just discussed with Alex, it might not be a good choice to move between core registers and float point registers, though we can save one instruction. Because move between core register and float point register is much slower than move between the same register kind.

408:21-408:61
Wed Mar 04 11:09:54 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 126ed67a_297b6da8
UUID: 12b17657_91f09c98
Bytes: 3
OK.

426:0-426:96
Tue Mar 03 11:56:51 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d20a7e5c_55169cce
Bytes: 5
ditto

426:0-426:96
Wed Mar 04 07:57:27 2015 +0000
Author: Zheng Xu <1042649@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d20a7e5c_55169cce
UUID: 12b17657_31d3b056
Bytes: 5
ditto

465:20-465:72
Tue Mar 03 11:56:51 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 92c00617_d0c8c2d0
Bytes: 53
Seems unfortunate lines 465 and 488 are not the same.

465:20-465:72
Wed Mar 04 07:57:27 2015 +0000
Author: Zheng Xu <1042649@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 92c00617_d0c8c2d0
UUID: 12b17657_71dd385e
Bytes: 208
Yes, but both of them are correct.

There are multiple moves in the cycle. Introducing a scratch location for one of the move can resolve the problem. But different choices will result to different solutions.

465:20-465:72
Wed Mar 04 10:42:14 2015 +0000
Author: Zheng Xu <1042649@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 12b17657_71dd385e
UUID: 929c86d9_2d6fcdfc
Bytes: 107
If we do not use D registers, it will be 6 moves for the swap version. It is the same with no-swap version.

488:20-488:78
Tue Mar 03 11:56:51 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d2a43ecd_3f1ba725
Bytes: 93
We're currenlty doing 4 moves on arm for this. This will create a few more. Can we do better?

488:20-488:78
Wed Mar 04 07:57:27 2015 +0000
Author: Zheng Xu <1042649@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d2a43ecd_3f1ba725
UUID: 126ed67a_e911d587
Bytes: 407
Yes, but this will require some additional logic in the resolver to do the best choice.

This case is quite special which has two intersected cycles. Introduce one scratch will result one additional move. So this becomes 5 moves. But if we introduce a scratch location for the common edge, we will only need one additional scratch location. This will be resolved as : (0,1 -> D) (2 -> 0) (3 -> 1) (D -> 2,3)

488:20-488:78
Wed Mar 04 10:42:14 2015 +0000
Author: Zheng Xu <1042649@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 126ed67a_e911d587
UUID: 12b17657_f1176840
Bytes: 316
If we are not using D registers, swap version generates 6 moves and no-swap version generates 7 moves.

But I prefer to not change the resolver at the moment, because this kind of choice only happens with register pairs which do not exist on arm64.

I will fine tune this if we want to use no-swap version for arm32.

508:0-508:26
Tue Mar 03 11:56:51 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 92a646d4_fd79c785
Bytes: 92
Explain why. Why do we want to test this then? Should we make NoSwap not support it as well?

508:0-508:26
Wed Mar 04 07:57:27 2015 +0000
Author: Zheng Xu <1042649@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 92a646d4_fd79c785
UUID: 12b17657_b1e5e027
Bytes: 167
The swap version do not support overlap like 0,1 and 1,2.

BTW, can the compiler make better use of registers if there is no such constrains in parallel move resolver?

508:0-508:26
Wed Mar 04 11:09:54 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 12b17657_b1e5e027
UUID: 929c86d9_0d9ad170
Bytes: 36
Define "better use" in this context?

508:0-508:26
Wed Mar 04 11:24:55 2015 +0000
Author: Zheng Xu <1042649@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 929c86d9_0d9ad170
UUID: 929c86d9_2d0b4d25
Bytes: 157
For register allocation, is it possible that we happen to have free register R1 and R2?

In this case, we can just allocate R1_R2 if we need a register pair.

508:0-508:26
Wed Mar 04 11:26:21 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 929c86d9_2d0b4d25
UUID: 52a68e28_2bd33956
Bytes: 145
Please provide an example, I don't understand at which level you'd like this to happen. R1_R2 as an allocatable register or as a scrach register?

508:0-508:26
Wed Mar 04 11:34:08 2015 +0000
Author: Zheng Xu <1042649@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 52a68e28_2bd33956
UUID: 12b17657_d1786480
Bytes: 236
Probably I'm describing a situation which might never happen. I haven't go through the code of register allocation yet. I mean R1_R2 as an allocatable register for the register allocator to assign it to the location in location summary.

508:0-508:26
Wed Mar 04 11:35:13 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 12b17657_d1786480
UUID: 52a68e28_4bda0568
Bytes: 139
Ah OK. I think we'd rather not do this, knowing that there are instructions that require even/odd register pair (for example arm32's ldrd).

508:0-508:26
Thu Mar 05 03:40:05 2015 +0000
Author: Zheng Xu <1042649@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 52a68e28_4bda0568
UUID: d22fde6e_47f4ced5
Bytes: 84
This depends on which mode we are using. There is no such limitation for thumb mode.

508:0-508:26
Thu Mar 05 09:19:46 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d22fde6e_47f4ced5
UUID: 929c86d9_33fa90c6
Bytes: 30
Yes. But let's keep it simple.

