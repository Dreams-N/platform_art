Revision: 5e0990073c6bf07e862d4b0d5a5ec5a1fe63cc06
Patch-set: 4
File: runtime/base/scoped_arena_containers.h

64
Tue Oct 20 19:05:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 79d47637_2a1a46b8
Bytes: 1
?

File: runtime/base/stl_util.h

142:0-148:2
Tue Oct 20 18:34:48 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f936a66e_41e6b24a
Bytes: 319
Can you also declare the DestroyOnlyDelete<T[]> specialization and deliberately omit definition? That will prevent people from using DestroyOnlyUniquePtr<T[]> which is probably not what they want. It doesn't work with arenas and I don't even see any way how to portably implement it for normal new[] allocations anyway.

142:0-148:2
Tue Oct 20 18:56:01 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f936a66e_41e6b24a
UUID: d90802ae_28eca078
Bytes: 4
Done

151
Tue Oct 20 19:05:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 79d47637_ea779ebe
Bytes: 973
IMHO DestroyOnlyUniquePtr is an anti-pattern because this isn't Java and freeing memory is actually important to maintain sanity.

There should be an ArenaUniquePtr or UniquePtrArena (whatever you want to call it) which works *only* by deleting within the arena.

Debug/valgrind modes could store the arena as an extra field (2x pointers instead of 1) so it can deallocate on the arena.

(the arena pointer can be stored by allocating +sizeof(void*) more and storing it in the pre-header, which wastes space in debug mode in return for better safety. maybe there's an even better way to get back to the arena pointer from the address, vmarko might know).

  debug memory layout of a debug arena object:

  |-------------------------------------|
  | arena ptr |  allocated memory  .... |
  |-------------------------------------|
              ^
              |
             unique ptr points here

Double deletes should be checked, not actually deleting should be checked.

File: runtime/dex_instruction.h

251
Tue Oct 20 19:05:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b9ec2e3d_489f8ed2
Bytes: 14
Why only this?

File: runtime/verifier/method_verifier.cc

705
Tue Oct 20 19:05:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 39de7e5b_77d95b55
Bytes: 117
This isn't very clean, this should be brought out to a helper

   unique_ptr<T> MakeArenaArrayZeroed<T>(arena, size);

File: runtime/verifier/method_verifier.h

127:2-127:77
Tue Oct 20 18:34:48 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 19345a65_65bbc04c
Bytes: 23
No longer true, remove.

127:2-127:77
Tue Oct 20 18:56:01 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 19345a65_65bbc04c
UUID: b9ec2e3d_48866ea8
Bytes: 4
Done

732
Tue Oct 20 19:05:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b9ec2e3d_28232a48
Bytes: 36
This needs to be an arena unique ptr

732
Tue Oct 20 19:19:42 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b9ec2e3d_28232a48
UUID: 595172a7_7fb82b4e
Bytes: 190
Do you want all array allocations on the arena to take additional 4B/8B, so that we can implement the ArenaDelete<T[]> specialization? If alignof(T)==8, it's 8B also on 32-bit architectures.

732
Tue Oct 20 20:18:24 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 595172a7_7fb82b4e
UUID: 791716fc_1851699d
Bytes: 222
Not sure what you mean, can you elaborate?

My original thought (comments in stl_util.h) was that we only introduce extra overhead for either debug or memory checking modes (i.e. no overhead for release / no memory check).

732
Tue Oct 20 20:30:25 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 791716fc_1851699d
UUID: f91146d4_776f13e9
Bytes: 854
Ah, I think it's because the size is untracked right?

The type being allocated knows the size though, so we can ask for it.

  template <typename T>
  void delete(T* ptr) {
    size_t array_size = ptr->GetSizeOf();
    // made up deleter function
    // that can mark the bits as unallocated
    ArenaDeleteArray(ptr, array_size);
  }

  struct InstructionFlags {
    size_t GetSizeOf() const {
      return sizeof(*this) + instruction_length_;
    }
  }

That would work for release modes.

If it's debug/memcheck only then we don't even need to do this, just store the size in the preheader.

   ---------------------------------
   | arena ptr | array size | data |
   ---------------------------------
                            ^
                            |
                          unique_ptr.get()

(and of course it can use a custom deleter)

732
Tue Oct 20 20:36:16 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f91146d4_776f13e9
UUID: f936a66e_41fd52ca
Bytes: 215
Yes, that's because we don't track the size of the array. And it's indeed a simple array and the first element doesn't know how many elements are there, so we cannot do the GetSizeOf() trick without overhead either.

732
Tue Oct 20 21:19:42 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f936a66e_41fd52ca
UUID: 79d47637_aab87617
Bytes: 96
Ok, thanks for elaborating.

So can we just do the release 0-overhead/non-release some overhead?

732
Tue Oct 20 21:42:30 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 79d47637_aab87617
UUID: 19345a65_2537f87d
Bytes: 102
Not if you want to actually destroy elements of an array held by ArenaUniquePtr<T[]> in release build.

732
Tue Oct 20 22:21:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 19345a65_2537f87d
UUID: 39111e0a_88c523c4
Bytes: 1095
Well, the size has to be stored somewhere right if we actually wanted to call the destructor on each element in T, in which case it might as well be in the arena.

That being said we only need to call the destructor on elements that are non-trivial, and hence only need the overhead for non-trivial types.

  // Slow path, user-defined destructor in self or in a field
  // This can also be used for debugging
  template <typename T, typename=void>
  T* AllocateArray(size_t count) {
    size_t actual_size = sizeof(T) * count;
    actual_size += sizeof(size_t);

    uint8_t* ptr = actual_allocator(actual_size);

    *(size_t*)ptr = count;
    return (T*)(ptr + sizeof(size_t));
  }

  // Fast path, no user-defined destructors anywhere
  template <typename T, typename = 
                        typename std::enable_if<std::is_trivial<T>>::type>::type>
  T* AllocateArray(size_t count) {
    size_t actual_size = sizeof(T) * count;

    uint8_t* ptr = actual_allocator(actual_size);

    return (T*)ptr;
  }

(except implemented with proper style, and the deleters could be done analogously)

File: runtime/verifier/reg_type-inl.h

187
Tue Oct 20 19:05:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d90802ae_48211469
Bytes: 50
Where is the delete operator that takes the arena?

File: runtime/verifier/reg_type.h

287
Tue Oct 20 19:05:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 791716fc_78633d1b
Bytes: 29
Delete operator taking arena?

File: runtime/verifier/reg_type_cache.cc

169
Tue Oct 20 19:05:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 39111e0a_6731dace
Bytes: 51
Who is responsible for cleaning up the string then?

274:25-274:27
Tue Oct 20 19:05:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 99f3ea1a_b8278982
Bytes: 69
nit: magic numbers deserve a constant, or at the very least a comment

342:23-342:24
Tue Oct 20 18:34:48 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b940aed4_5fb8cb16
Bytes: 55
This is in bits, so 64. Also use plural in the comment.

342:23-342:24
Tue Oct 20 18:56:01 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b940aed4_5fb8cb16
UUID: b9ec2e3d_085bc6e1
Bytes: 4
Done

342:23-342:24
Tue Oct 20 19:05:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b940aed4_5fb8cb16
UUID: 39de7e5b_7480393b
Bytes: 105
nit: please no magic numbers in our code base, put the 2 into scoped arena as a constexpr with a comment.

389:9-389:17
Tue Oct 20 19:05:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 791716fc_786cddf2
Bytes: 74
AddEntry should take a unique_ptr so it's clear it's taking over ownership

File: runtime/verifier/reg_type_cache.h

61
Tue Oct 20 19:05:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 791716fc_783a1dff
Bytes: 14
nit: comments?

File: runtime/verifier/reg_type_test.cc

657
Tue Oct 20 19:05:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 79d47637_6a95ee36
Bytes: 85
Can't these 2 lines just go into the RegTypeTest struct to avoid this copy-and-paste?

File: runtime/verifier/register_line-inl.h

187:43-187:44
Tue Oct 20 19:05:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b9f26ee4_9b53cefe
Bytes: 36
nit: indentation needs 4 more spaces

File: runtime/verifier/register_line.h

62:48-62:56
Tue Oct 20 19:05:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f91146d4_9cbbcc4b
Bytes: 41
nit: please comment on what the uints are

64
Tue Oct 20 19:05:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b9ec2e3d_48b5ce1b
Bytes: 36
nit: public method missing comments?

