Revision: 5e0990073c6bf07e862d4b0d5a5ec5a1fe63cc06
Patch-set: 4
File: runtime/base/scoped_arena_containers.h

64
Tue Oct 20 19:05:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 79d47637_2a1a46b8
Bytes: 1
?

64
Tue Oct 20 23:02:22 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 79d47637_2a1a46b8
UUID: b9f26ee4_9be50e92
Bytes: 4
Done

File: runtime/base/stl_util.h

142:0-148:2
Tue Oct 20 18:34:48 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f936a66e_41e6b24a
Bytes: 319
Can you also declare the DestroyOnlyDelete<T[]> specialization and deliberately omit definition? That will prevent people from using DestroyOnlyUniquePtr<T[]> which is probably not what they want. It doesn't work with arenas and I don't even see any way how to portably implement it for normal new[] allocations anyway.

142:0-148:2
Tue Oct 20 18:56:01 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f936a66e_41e6b24a
UUID: d90802ae_28eca078
Bytes: 4
Done

151
Tue Oct 20 19:05:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 79d47637_ea779ebe
Bytes: 973
IMHO DestroyOnlyUniquePtr is an anti-pattern because this isn't Java and freeing memory is actually important to maintain sanity.

There should be an ArenaUniquePtr or UniquePtrArena (whatever you want to call it) which works *only* by deleting within the arena.

Debug/valgrind modes could store the arena as an extra field (2x pointers instead of 1) so it can deallocate on the arena.

(the arena pointer can be stored by allocating +sizeof(void*) more and storing it in the pre-header, which wastes space in debug mode in return for better safety. maybe there's an even better way to get back to the arena pointer from the address, vmarko might know).

  debug memory layout of a debug arena object:

  |-------------------------------------|
  | arena ptr |  allocated memory  .... |
  |-------------------------------------|
              ^
              |
             unique ptr points here

Double deletes should be checked, not actually deleting should be checked.

151
Tue Oct 20 23:02:22 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 79d47637_ea779ebe
UUID: 79d47637_aa3e3681
Bytes: 73
Needing to remember to use ~T() everywhere is more of an antipattern IMO.

151
Tue Oct 20 23:22:20 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 79d47637_aa3e3681
UUID: b9ec2e3d_e1f2fdc9
Bytes: 160
I think I may have been unclear, I apologize for that.

Of course it needs to call ~T(). However it's insufficient, as it also needs to do the delete operation.

151
Wed Oct 21 01:06:01 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b9ec2e3d_e1f2fdc9
UUID: 99f3ea1a_c5a8a9ce
Bytes: 72
I added a memset that should cause valgrind / address sanitizer to fail.

File: runtime/dex_instruction.h

251
Tue Oct 20 19:05:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b9ec2e3d_489f8ed2
Bytes: 14
Why only this?

251
Tue Oct 20 23:02:22 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b9ec2e3d_489f8ed2
UUID: 99020a8c_2daf0ed0
Bytes: 57
Showed up in profile, the other ones are already inlined.

File: runtime/verifier/method_verifier.cc

705
Tue Oct 20 19:05:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 39de7e5b_77d95b55
Bytes: 117
This isn't very clean, this should be brought out to a helper

   unique_ptr<T> MakeArenaArrayZeroed<T>(arena, size);

705
Tue Oct 20 23:02:22 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 39de7e5b_77d95b55
UUID: f91146d4_d74ebfaa
Bytes: 20
Seems like overkill.

File: runtime/verifier/method_verifier.h

127:2-127:77
Tue Oct 20 18:34:48 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 19345a65_65bbc04c
Bytes: 23
No longer true, remove.

127:2-127:77
Tue Oct 20 18:56:01 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 19345a65_65bbc04c
UUID: b9ec2e3d_48866ea8
Bytes: 4
Done

732
Tue Oct 20 19:05:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b9ec2e3d_28232a48
Bytes: 36
This needs to be an arena unique ptr

732
Tue Oct 20 19:19:42 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b9ec2e3d_28232a48
UUID: 595172a7_7fb82b4e
Bytes: 190
Do you want all array allocations on the arena to take additional 4B/8B, so that we can implement the ArenaDelete<T[]> specialization? If alignof(T)==8, it's 8B also on 32-bit architectures.

732
Tue Oct 20 20:18:24 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 595172a7_7fb82b4e
UUID: 791716fc_1851699d
Bytes: 222
Not sure what you mean, can you elaborate?

My original thought (comments in stl_util.h) was that we only introduce extra overhead for either debug or memory checking modes (i.e. no overhead for release / no memory check).

732
Tue Oct 20 20:30:25 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 791716fc_1851699d
UUID: f91146d4_776f13e9
Bytes: 854
Ah, I think it's because the size is untracked right?

The type being allocated knows the size though, so we can ask for it.

  template <typename T>
  void delete(T* ptr) {
    size_t array_size = ptr->GetSizeOf();
    // made up deleter function
    // that can mark the bits as unallocated
    ArenaDeleteArray(ptr, array_size);
  }

  struct InstructionFlags {
    size_t GetSizeOf() const {
      return sizeof(*this) + instruction_length_;
    }
  }

That would work for release modes.

If it's debug/memcheck only then we don't even need to do this, just store the size in the preheader.

   ---------------------------------
   | arena ptr | array size | data |
   ---------------------------------
                            ^
                            |
                          unique_ptr.get()

(and of course it can use a custom deleter)

732
Tue Oct 20 20:36:16 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f91146d4_776f13e9
UUID: f936a66e_41fd52ca
Bytes: 215
Yes, that's because we don't track the size of the array. And it's indeed a simple array and the first element doesn't know how many elements are there, so we cannot do the GetSizeOf() trick without overhead either.

732
Tue Oct 20 21:19:42 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f936a66e_41fd52ca
UUID: 79d47637_aab87617
Bytes: 96
Ok, thanks for elaborating.

So can we just do the release 0-overhead/non-release some overhead?

732
Tue Oct 20 21:42:30 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 79d47637_aab87617
UUID: 19345a65_2537f87d
Bytes: 102
Not if you want to actually destroy elements of an array held by ArenaUniquePtr<T[]> in release build.

732
Tue Oct 20 22:21:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 19345a65_2537f87d
UUID: 39111e0a_88c523c4
Bytes: 1095
Well, the size has to be stored somewhere right if we actually wanted to call the destructor on each element in T, in which case it might as well be in the arena.

That being said we only need to call the destructor on elements that are non-trivial, and hence only need the overhead for non-trivial types.

  // Slow path, user-defined destructor in self or in a field
  // This can also be used for debugging
  template <typename T, typename=void>
  T* AllocateArray(size_t count) {
    size_t actual_size = sizeof(T) * count;
    actual_size += sizeof(size_t);

    uint8_t* ptr = actual_allocator(actual_size);

    *(size_t*)ptr = count;
    return (T*)(ptr + sizeof(size_t));
  }

  // Fast path, no user-defined destructors anywhere
  template <typename T, typename = 
                        typename std::enable_if<std::is_trivial<T>>::type>::type>
  T* AllocateArray(size_t count) {
    size_t actual_size = sizeof(T) * count;

    uint8_t* ptr = actual_allocator(actual_size);

    return (T*)ptr;
  }

(except implemented with proper style, and the deleters could be done analogously)

732
Tue Oct 20 22:36:28 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 39111e0a_88c523c4
UUID: 79d47637_2575d951
Bytes: 495
minor: strictly speaking it would be 'void* operator new[](std::size_t count, Arena& arena)' and not actually 'AllocateArray.'

To make things clean we'd still want a separate "ArenaUniquePtr<T> MakeUniqueArenaPtr(Arena&, Args&&...)" function which calls the new(arena) operator under the hood and is specialized to avoid storing 'arena'.

-----
In other words it's the special new/delete operators which should know about whether or not the extra bytes are allocated, not the unique ptr itself.

732
Tue Oct 20 23:02:22 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 39111e0a_88c523c4
UUID: 791716fc_3efd2d67
Bytes: 99
If you want to call the destructor on each element, its probably better to use a ScopedArenaVector?

732
Tue Oct 20 23:02:22 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 595172a7_7fb82b4e
UUID: 39111e0a_8d37f57b
Bytes: 19
Seems not worth it.

732
Tue Oct 20 23:02:22 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b9ec2e3d_28232a48
UUID: 99f3ea1a_13abfeb0
Bytes: 4
Done

File: runtime/verifier/reg_type-inl.h

187
Tue Oct 20 19:05:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d90802ae_48211469
Bytes: 50
Where is the delete operator that takes the arena?

187
Tue Oct 20 23:02:22 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d90802ae_48211469
UUID: d90802ae_6363d91b
Bytes: 61
I don't think that is required, after looking at ArenaObject.

187
Tue Oct 20 23:22:20 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d90802ae_6363d91b
UUID: b9f26ee4_3131a3cf
Bytes: 365
Then there needs to be a check here

  static_assert(std::is_trivial<RegType>::value,
                "Non-trivial types must be deleted");

And anyway that only works because the string was changed to a StringPiece, what if someone comes in and adds another field later? It would shift the complexity to someone else to figure out what happened to all the deletes.

187
Wed Oct 21 01:06:01 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b9f26ee4_3131a3cf
UUID: 79d47637_e0da1fd5
Bytes: 48
That doesn't work to virtual methods. Any ideas?

File: runtime/verifier/reg_type.h

287
Tue Oct 20 19:05:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 791716fc_78633d1b
Bytes: 29
Delete operator taking arena?

287
Tue Oct 20 23:02:22 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 791716fc_78633d1b
UUID: b9ec2e3d_6b3a4cb1
Bytes: 4
Done

File: runtime/verifier/reg_type_cache.cc

169
Tue Oct 20 19:05:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 39111e0a_6731dace
Bytes: 51
Who is responsible for cleaning up the string then?

169
Tue Oct 20 23:02:22 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 39111e0a_6731dace
UUID: 79d47637_8a6dba81
Bytes: 70
Its in the arena, when the arena goes out of scope it gets cleaned up.

274:25-274:27
Tue Oct 20 19:05:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 99f3ea1a_b8278982
Bytes: 69
nit: magic numbers deserve a constant, or at the very least a comment

274:25-274:27
Tue Oct 20 23:02:22 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 99f3ea1a_b8278982
UUID: 791716fc_9893b999
Bytes: 4
Done

342:23-342:24
Tue Oct 20 18:34:48 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b940aed4_5fb8cb16
Bytes: 55
This is in bits, so 64. Also use plural in the comment.

342:23-342:24
Tue Oct 20 18:56:01 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b940aed4_5fb8cb16
UUID: b9ec2e3d_085bc6e1
Bytes: 4
Done

342:23-342:24
Tue Oct 20 19:05:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b940aed4_5fb8cb16
UUID: 39de7e5b_7480393b
Bytes: 105
nit: please no magic numbers in our code base, put the 2 into scoped arena as a constexpr with a comment.

342:23-342:24
Tue Oct 20 23:02:22 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 39de7e5b_7480393b
UUID: 79d47637_ca274250
Bytes: 4
Done

389:9-389:17
Tue Oct 20 19:05:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 791716fc_786cddf2
Bytes: 74
AddEntry should take a unique_ptr so it's clear it's taking over ownership

389:9-389:17
Tue Oct 20 23:02:22 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 791716fc_786cddf2
UUID: b9ec2e3d_8b35109d
Bytes: 8
Overkill

File: runtime/verifier/reg_type_cache.h

61
Tue Oct 20 19:05:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 791716fc_783a1dff
Bytes: 14
nit: comments?

61
Tue Oct 20 23:02:22 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 791716fc_783a1dff
UUID: 79d47637_4a90f2d6
Bytes: 4
Done

File: runtime/verifier/reg_type_test.cc

657
Tue Oct 20 19:05:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 79d47637_6a95ee36
Bytes: 85
Can't these 2 lines just go into the RegTypeTest struct to avoid this copy-and-paste?

657
Tue Oct 20 23:02:22 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 79d47637_6a95ee36
UUID: 39111e0a_0df5a5ef
Bytes: 4
Done

File: runtime/verifier/register_line-inl.h

187:43-187:44
Tue Oct 20 19:05:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b9f26ee4_9b53cefe
Bytes: 36
nit: indentation needs 4 more spaces

187:43-187:44
Tue Oct 20 23:02:22 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b9f26ee4_9b53cefe
UUID: 39111e0a_ed1029d5
Bytes: 4
Done

File: runtime/verifier/register_line.h

62:48-62:56
Tue Oct 20 19:05:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f91146d4_9cbbcc4b
Bytes: 41
nit: please comment on what the uints are

62:48-62:56
Tue Oct 20 23:02:22 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f91146d4_9cbbcc4b
UUID: 39de7e5b_97a28717
Bytes: 4
Done

64
Tue Oct 20 19:05:17 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b9ec2e3d_48b5ce1b
Bytes: 36
nit: public method missing comments?

64
Tue Oct 20 23:02:22 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b9ec2e3d_48b5ce1b
UUID: 39111e0a_2d034191
Bytes: 4
Done

