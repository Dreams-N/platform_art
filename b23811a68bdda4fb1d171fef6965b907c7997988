Revision: b23811a68bdda4fb1d171fef6965b907c7997988
Patch-set: 1
File: compiler/dex/quick/x86/codegen_x86.h

260:20-260:30
Wed Jan 15 21:11:31 2014 +0000
Author: Razvan A Lupusoru <1013855@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4deed135_39efff9c
Bytes: 9
immediate

File: compiler/dex/quick/x86/int_x86.cc

864
Wed Jan 15 21:11:31 2014 +0000
Author: Razvan A Lupusoru <1013855@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0df0590e_8ccecf68
Bytes: 210
Even though the destination may be a dalvik register, it is possible it has been promoted or is in a physical register. I wonder if there are additional checks needed here before you do the operation in memory.

864
Wed Jan 15 21:22:27 2014 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0df0590e_8ccecf68
UUID: 0df0590e_0c08ffb8
Bytes: 119
If the location is DalvikFrame or CompilerTemp after an UpdateLoc, then the value isn't in registers (as far as I know)

864
Wed Jan 15 21:43:09 2014 +0000
Author: Bill Buzbee <1001578@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0df0590e_0c08ffb8
UUID: 0df0590e_2c74db14
Bytes: 8
Correct.

901:17-901:26
Wed Jan 15 21:43:09 2014 +0000
Author: Bill Buzbee <1001578@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0df0590e_2c25fb93
Bytes: 1027
[my first comment here was going to be "don't do this!", but now I think I see what you're after.  Note, though, that it's really dangerous to directly modify the register fields of RegLocations.  Avoid doing so if possible.].


As you've no doubt noticed, the general structure of Quick codegen has a 3-address bias.  I'm assuming that you are intending this routine to better support 2-address operations.  Let's move this to gen_loadstore.cc, and make it available for all targets.  Also, don't pass RegLocations by reference.  They are small enough to frequently be held in registers, so make this a function that returns a RegLocation.  I could envision a similar use for int, single and double - but let's not worry about that now.  Just call this one RegLocation ForceTempWide(RegLocation loc) and DCHECK to make sure that your incoming registers are core.

I'm in the midst of a rework of register handling (part of the "pair" cleanup).  As part of that, I'll rework your new ForceTempWide() to handle core and FP regs.

901:17-901:26
Wed Jan 15 22:03:13 2014 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0df0590e_2c25fb93
UUID: 4deed135_74e18eed
Bytes: 4
Done

921:33-921:35
Wed Jan 15 21:43:09 2014 +0000
Author: Bill Buzbee <1001578@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: edaa25eb_d2606420
Bytes: 775
The various UpdateLocs tell you if the desired value happens to already be live in a register.  It will not, however, allocate any registers.  For rl_dest, what you generaly want is EvalLoc().  EvalLoc() will ensure that physical registers are allocated for your eventual result.  Your use of UpdateLoc to snoop on the current state of the world is fine, but if you can't do the operation directly into registers you may end up at the final StoreValue with no registers having been allocated.

You may generally get away with this, but I think you may get caught if one of the two Dalvik vregs that makes up the wide value here was promoted, but the other wasn't.  EvalLocWide() deals with this case.


Add an EvalLocWide below, immediately before the final StoreValueWide().

943
Wed Jan 15 20:27:58 2014 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: edaa25eb_b2983863
Bytes: 126
Is this necessary?  I couldn't figure out if LoadValueWide returns a temporary copy if the home location is in Core registers.

943
Wed Jan 15 21:11:15 2014 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: edaa25eb_b2983863
UUID: 0df0590e_2caa1b6c
Bytes: 44
I think EvalLocWide is what I really wanted.

943
Wed Jan 15 21:43:09 2014 +0000
Author: Bill Buzbee <1001578@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: edaa25eb_b2983863
UUID: 4deed135_14ff62d5
Bytes: 373
The above call to LoadValueWide lets you specify the register class you want (which could be anything - float even if it's core, or core if it's float).  It will ensure that the value is loaded into physical register[s] of the specified class.  However, you cannot assume that the register[s] will be temp.  If the value has been promoted, you'll get the promoted register.

952
Wed Jan 15 21:43:09 2014 +0000
Author: Bill Buzbee <1001578@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: edaa25eb_32460896
Bytes: 19
EvalLocWide() here.

952
Wed Jan 15 22:03:13 2014 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: edaa25eb_32460896
UUID: 0df0590e_6c26e3e7
Bytes: 4
Done

952
Wed Jan 15 22:34:07 2014 +0000
Author: Bill Buzbee <1001578@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: edaa25eb_32460896
UUID: 4deed135_74950edb
Bytes: 1388
Now that I think about it, my advice about needing an EvalLocWide() here was wrong.  What threw me here was not seeing an EvalLoc anywhere - which is something that's usually required.  However, your new ForceTempWide() plays a similar role to EvalLoc elsewhere.  Normally, you'd:

rl_src1 = LoadValue()

rl_src2 = LoadValue()

rl_result = EvalLoc(rl_dest)

... do operations into rl_result's registers

StoreValue(rl_dest, rl_result);  // flush to home location


Your ForceTempWide can be looked at as the functional equivalent of


rl_src = LoadValue(rl_src)

rl_result = EvalLoc(rl_dest)

copy(rl_result, rl_src)


So, I don't think you need the explicit EvalLoc after all.  However, to make this code fit in better with the existing scheme, go ahead and use the "rl_result" name for the result of ForceTempWide:

RegLocation rl_result = ForceTempWide(rl_src)

.. then operate on rl_result

StoreValue(rl_dest, rl_result);


Now, I think there may be another problem that I overlooked.  In your ForceTempWide, if either of the registers is already a temp you leave it alone and use it as-is.  In this case, you also need to Clobber() it to break the association between that temp register and the src vReg it was loaded from.  Otherwise, a subsequent operation may attempt to reuse that register assuming the original vreg's value is still live in it (and you've since stepped on it).

File: compiler/dex/quick/x86/target_x86.cc

682
Wed Jan 15 20:27:58 2014 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: edaa25eb_d2bea4b6
Bytes: 55
This is a bug fix.  IsFpReg(INVALID_REG) returns 'true'

682
Wed Jan 15 21:43:09 2014 +0000
Author: Bill Buzbee <1001578@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: edaa25eb_d2bea4b6
UUID: 4deed135_54228abe
Bytes: 109
Ah, yes.  I'll keep that in mind during my register rework. 0xff does match all of the bit mask flags.  Yuck.

700
Wed Jan 15 20:27:58 2014 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: edaa25eb_12c14c3c
Bytes: 12
More fixes..

