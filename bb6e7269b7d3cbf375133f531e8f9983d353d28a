Revision: bb6e7269b7d3cbf375133f531e8f9983d353d28a
Patch-set: 2
File: runtime/interpreter/mterp/arm/op_iget_object_quick.S

5:4-7:55
Thu Jan 14 23:29:00 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 676db610_44bd2ced
Bytes: 585
Can we add some kind of checks for this?

I would advocate instead of bl to use a macro (with the name of the runtime function), but it prohibits micro optimizations like your scheduling here. And it's also not clear whether you should do it everywhere (though it would probably be better).

We don't store a frame on such a direct transition, so we can't compare in the runtime code, regrettably.

How about in debug builds always scrambling the stored pc first in every assembly fragment? Kinda like heap poisoning. Still requires coverage for all the paths, but better than nothing.

5:4-7:55
Fri Jan 15 00:09:58 2016 +0000
Author: Bill Buzbee <1001578@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 676db610_44bd2ced
UUID: 07623a24_ebc24c7a
Bytes: 997
Though I understand macro vs. bl, I would prefer the keep the ability to schedule.  And yes, not all runtime support calls can throw.

One thing that makes it a little more difficult to have debug vs. non-debug builds is that there is a hard limit on the size of the initial assembly block (128 bytes currently, but Dalvik used 64 and I'd planned to switching back to that after thing stabilized).   So, you have to be careful not to have a macro with extra debug code expand and push you over the limit.

However, there is a place we could do something like this.  The traditional "alt" version of mterp includes a common callout prior to each instruction interpretation - MterpCheckBefore().  This could scramble the stashed Dalvik PC prior to each interpretation without altering the opcode handling bodies.  In fact, in my early development of mterp I did something opposite - I always exported PC.  If I crashed regular and passed when using Alt that was a clear sign I'd forgotten to export.

