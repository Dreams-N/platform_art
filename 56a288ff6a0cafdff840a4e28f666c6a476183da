Revision: 56a288ff6a0cafdff840a4e28f666c6a476183da
Patch-set: 5
File: compiler/optimizing/dead_code_elimination_test.cc

35:9-35:23
Mon Dec 15 17:57:24 2014 +0000
Author: Razvan A Lupusoru <1013855@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a453fafb_50280ced
Bytes: 87
Shouldn't you check the result of the "try". If not expect to fail, maybe add a dcheck.

35:9-35:23
Mon Dec 15 18:35:46 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a453fafb_50280ced
UUID: e4adf2fd_7511a2c5
Bytes: 130
Good point. This is in testing code though, and will fail pretty quickly if we can't build SSA, so we save on extra checking code.

File: compiler/optimizing/inliner.cc

72:24-72:37
Mon Dec 15 17:57:24 2014 +0000
Author: Razvan A Lupusoru <1013855@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a453fafb_700ef0a5
Bytes: 82
Eventually, the caching system from Quick that Vmarko made will be useful as well.

91:53-91:59
Mon Dec 15 17:57:24 2014 +0000
Author: Razvan A Lupusoru <1013855@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 04c126c3_06cc7c44
Bytes: 142
This message is correct now but I imagine at some point we will also want more compiler generated methods as well (which won't have code item)

91:53-91:59
Mon Dec 15 18:35:46 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 04c126c3_06cc7c44
UUID: 24162a01_372ef2fb
Bytes: 137
You mean intrinsics? This won't be done at this level, but at codegen. The inlining code here is meant to inline methods with code items.

101:17-101:28
Mon Dec 15 17:57:24 2014 +0000
Author: Razvan A Lupusoru <1013855@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a453fafb_b01e98d2
Bytes: 125
What if the caller is inside try block? Does it work because you don't handle exceptions? (namely you don't need environment)

101:17-101:28
Mon Dec 15 18:35:46 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a453fafb_b01e98d2
UUID: 24162a01_172bf6eb
Bytes: 51
Yes, we don't optimize methods with try blocks yet.

137:6-137:65
Mon Dec 15 17:57:24 2014 +0000
Author: Razvan A Lupusoru <1013855@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a453fafb_d0131cc9
Bytes: 101
As a future approach, it might make sense to estimate the number of blocks before building the graph.

137:6-137:65
Mon Dec 15 18:35:46 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a453fafb_d0131cc9
UUID: e4adf2fd_951ec6d2
Bytes: 287
By estimate, you mean running over it and find the number of branches? Yeah, we could do this by steps. On the other hand, I don't think this limit will stay long. The instruction size is already a good indicator. As soon as we support control flow, there's no reason to keep this limit.

File: compiler/optimizing/nodes.cc

717:6-717:63
Mon Dec 15 17:57:24 2014 +0000
Author: Razvan A Lupusoru <1013855@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a453fafb_102e84fb
Bytes: 39
I like that the IR allows doing this :)

File: compiler/optimizing/optimizing_compiler.cc

206:11-206:18
Mon Dec 15 17:57:24 2014 +0000
Author: Razvan A Lupusoru <1013855@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a453fafb_302b88ec
Bytes: 184
To me it makes sense to move inliner to be first one in this graph. Constant Folding and dead code elimination have more of an effect when looking at the whole graph with inlined code.

206:11-206:18
Mon Dec 15 18:35:46 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a453fafb_302b88ec
UUID: 24162a01_f7cabadc
Bytes: 163
The idea is to run simple (and cheap) optimizations first, to help find more inlining heuristics (code size, null checks, etc). But this will be driven by numbers.

