Revision: b19ccb1d88f0bff7371c9b72f265148677c18e95
Patch-set: 3
File: /COMMIT_MSG

10:32-11:27
Wed Jul 15 21:08:31 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 183e024a_03c9901e
Bytes: 70
Is this true? Runnable threads no longer hold the shared mutator lock?

10:32-11:27
Wed Jul 15 21:31:16 2015 +0000
Author: Man Cao <1073545@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 183e024a_03c9901e
UUID: 3837466d_c75e5243
Bytes: 236
Yes, it is true. Runnable threads would "pretend" to hold the mutator lock by calling BaseMutex::RegisterAsLocked() before transitioning to runnable, in order to pass various assertion checks, but they are not actually holding the lock.

10:32-11:27
Thu Jul 16 00:25:48 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 3837466d_c75e5243
UUID: 183e024a_4976d9b5
Bytes: 333
Hm, I have an impression that it could be potentially leaky/error-prone.

What happens if a mutator thread calls Locks::mutator_lock_->SharedUnlock(self) and then Locks::mutator_lock_->SharedLock(self) when it pretends to hold the shared mutator lock? Does it actually hold the lock now?

Is there a way to avoid the need to pretend?

10:32-11:27
Thu Jul 16 01:17:48 2015 +0000
Author: Man Cao <1073545@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 183e024a_4976d9b5
UUID: 78f7fee1_a45d4ebf
Bytes: 570
I agree this is error prone and we should make it better.

mutator_lock_->SharedLock() and mutator_lock_->SharedUnlock() still work as before, that the calling thread would hold/release the lock after the call. But after the JNI patch, a mutator thread would not call these two functions for thread state transitions. Calling them improperly could lead ReaderWriterMutex::state_ having a incorrect value.

I think we can remove the pretending part, but we may as well remove a lot of SHARED_LOCKS_REQUIRED(Locks::mutator_lock_) annotations, since this is no longer true.

File: runtime/gc/collector/concurrent_copying.cc

76:24-76:41
Wed Jul 15 21:08:31 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 3837466d_e7dcb657
Bytes: 289
I think this corresponds to the old ReferenceProcessor::PreserveSoftReferenceCallback() and it didn't have a CAS. So, it seems ok (i.e., preserving the old behavior). And the new comment sounds valid.

We could have retained DCHECK(new_obj != nullptr) from PreserveSoftReferenceCallback()?

76:24-76:41
Wed Jul 15 21:52:30 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 3837466d_e7dcb657
UUID: 78f7fee1_fb05251b
Bytes: 4
Done

File: runtime/thread_list.cc

384:2-384:20
Wed Jul 15 21:08:31 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f8404ed5_8561260a
Bytes: 156
So I didn't follow the JNI CL, but is this supposed to have about the same latency as before? Is there a chance that the worst case latency could be longer?

384:2-384:20
Wed Jul 15 21:31:16 2015 +0000
Author: Man Cao <1073545@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f8404ed5_8561260a
UUID: f8404ed5_45e23ec4
Bytes: 125
In my limited performance experiments, I didn't see any significant slowdown for SuspendAll(). I shared the results with you.

