Revision: b19ccb1d88f0bff7371c9b72f265148677c18e95
Patch-set: 3
File: /COMMIT_MSG

10:32-11:27
Wed Jul 15 21:08:31 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 183e024a_03c9901e
Bytes: 70
Is this true? Runnable threads no longer hold the shared mutator lock?

File: runtime/gc/collector/concurrent_copying.cc

76:24-76:41
Wed Jul 15 21:08:31 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 3837466d_e7dcb657
Bytes: 289
I think this corresponds to the old ReferenceProcessor::PreserveSoftReferenceCallback() and it didn't have a CAS. So, it seems ok (i.e., preserving the old behavior). And the new comment sounds valid.

We could have retained DCHECK(new_obj != nullptr) from PreserveSoftReferenceCallback()?

File: runtime/thread_list.cc

384:2-384:20
Wed Jul 15 21:08:31 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f8404ed5_8561260a
Bytes: 156
So I didn't follow the JNI CL, but is this supposed to have about the same latency as before? Is there a chance that the worst case latency could be longer?

