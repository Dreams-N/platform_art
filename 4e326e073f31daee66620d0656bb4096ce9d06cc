Revision: 4e326e073f31daee66620d0656bb4096ce9d06cc
Patch-set: 1
File: runtime/indirect_reference_table-inl.h

34:10-34:71
Sat Sep 06 04:51:18 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 10431f82_1eaa6d73
Bytes: 3225
I take back my comment. This is more subtle than I thought.

Here are what I think are the issues:

An invalid entry of the weak globals table will contain the "old" (or from-space) cleared jni weak global ref (the sentinel) from the last GC run (or the ref before it's moved) because it was what was written at the last GC (in JavaVMExt::SweepJniWeakGlobals()).

During the current GC run, when the weak globals table is scanned for sweep (JavaVMExt::SweepJniWeakGlobals()), the table is iterated by using IrtIterator and this function should skip invalid entries (line 34 above). But, since the Runtime::sentinel_ already points to the "new" ref (already moved by the GC), this comparison won't correctly skip invalid entries. In other words, IsClearedJniWeakGlobal() is incorrect after the sentinel is moved at the beginning of a GC run (at the root scan time.) (This was the issue before patch set 1.)

If we enable the read barrier on the entry read (the Read() call in line 34 above), then it'd cause all objects in the valid entries of the table marked alive, which is incorrect because they should be 'weak' refs. (This is the issue in patch set 1.)

I think one way to fix these is to use the "old" cleared jni weak global ref in IsClearedJniWeakGlobal(), as opposed to the 'current' ref and remove line 34. 

If we use the "old" ref, it should match what's in the weak globals table.

If we remove line 34, the invalid entries in the weak globals will get updated as the JNI weak global sweep will see invalid entries (otherwise they don't.) Since the cleared jni weak global ref points to a real object, if we don't skip invalid entries in line 34, JavaVMExt::SweepJniWeakGlobals() will see them and correctly update the cleared jni weak global ref from the old ref to the new ref.

void JavaVMExt::SweepJniWeakGlobals(IsMarkedCallback* callback, void* arg) {
  MutexLock mu(Thread::Current(), weak_globals_lock_);
  for (mirror::Object** entry : weak_globals_) {                ---> This will invoke IrtIterator. We don't skip invalid entries.
    // Since this is called by the GC, we don't need a read barrier.                                                                                                                                                                                                                                                        
    mirror::Object* obj = *entry;                                     ---> This will read the entry without a read barrier.
    mirror::Object* new_obj = callback(obj, arg);             ---> This will update the cleared jni weak global ref as well as valid entries.
    if (new_obj == nullptr) {
      new_obj = Runtime::Current()->GetClearedJniWeakGlobal();  ---> This will write the new cleared jni weak global ref into the entries that died at this GC.
    }
    *entry = new_obj;
  }
}

For the local/global tables, removing line 34 is fine as they won't contain the cleared jni weak global ref ever.

Unfortunately, we need a lock around SweepJniWeakGlobals() because that's the time when the 'right' cleared jni weak global ref changes. And GetClearedJniWeakGlobal() and IsClearedJniWeakGlobal() need to lock the same lock.

Feedback appreciated.

34:10-34:71
Sat Sep 06 23:38:43 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 10431f82_1eaa6d73
UUID: 10807fc3_f5e7d9f5
Bytes: 266
Skipping nulls and tombstones doesn't sound worth it, we should just process the sentinel references and upto to the to space. There's no correctness about scanning the sentinels just a performance one. The old code needed to skip as otherwise it could break the GC.

34:10-34:71
Mon Sep 08 17:22:41 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 10807fc3_f5e7d9f5
UUID: 10807fc3_5d3353e0
Bytes: 1550
I thought more about this over the weekend, and it seems that if we just remove line 34 (without changing IsClearedJniWeakGlobal()), it seems to work out.

Here's a long version:

If we just remove line 34, things will work out in the following way:

For CMS, objects don't move. So, no issue.

For SS/GSS, the sentinel is moved at the beginning of a GC run, and at the end of a GC run, invalid weak globals entries that contain the old sentinel ref will be updated with the new sentinel ref by SweepJniWeakGlobals() as IrtIterator does not skip the (old) sentinel ref. Since they are non-concurrent collectors, we don't have to worry about a mutator calling DecodeJObject() and interacting with the sentinel during a GC run.

For a read barrier based collector, like SS/GSS, the sentinel is moved at the beginning of a GC run, and at the end of a GC run, invalid weak globals entries that contain the old sentinel ref will be updated with the new sentinel ref by SweepJniWeakGlobals(). Since it's concurrent, a mutator may call DecodeJObject() and interact with the sentinel during a GC run, but at that point, the sentinel is already moved, and when a weak global entry is read by DecodeJObject(), the object in the entry gets moved by the read barrier, IsClearedJniWeakGlobal() compares two moved (or to-space) references (as opposed mixing up (a from-space and a to-space refs) and works correctly.

I believe this matches Ian's comment. As Ian says, we can probably remove the null-skipping code as well.

I will send a new patch set to this CL.

