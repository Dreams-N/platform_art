Revision: 019e45474585156ec134f8b24363b4fa11e499b4
Patch-set: 8
File: compiler/optimizing/ssa_builder.cc

590:2-594:3
Wed May 06 19:23:20 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2d62a1ee_8c332770
Bytes: 206
make this clearer with:

  HNullCheck* instance = invoke->InputAt(0)->AsNullCheck();

  if (instance == nullptr) {
    // Can this actually happen? It shouldn't. So I think we can DCHECK it.
    return;
  }

596:0-603:2
Wed May 06 19:23:20 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2d62a1ee_cc391f52
Bytes: 72
you are checking that the input of a NullCheck is a NullCheck here. why?

596:0-603:2
Wed May 06 19:47:12 2015 +0000
Author: Guillaume Sanchez <1068522@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2d62a1ee_cc391f52
UUID: cd290587_f1b72236
Bytes: 1099
I agree, it's confusing. The "first time" you see a method call on a ref, the if is false, and you fall down in the for loop below. This loop replaces all uses of the current NullCheck's source, including next NullCheck. Like this:

Given:
l6 ParamValue
...
l42 NullCheck [ l6 ]
v43 Invoke [ l42 ... ]
...
l52 NullCheck [ l6 ]
v53 Invoke [ l52 ... ]

When we visit the first Invoke (v43), we will execute the for loop below, replace following uses of l6 with l42, and have this:

l6 ParamValue
...
l42 NullCheck [ l6 ]
v43 Invoke [ l42 ... ]
...
l52 NullCheck [ l42 ]
v53 Invoke [ l52 ... ]

but now l52 has another NullCheck as input. So, when we will visit v53, checking that l52's input is a NullCheck is a way to know that we already changed inputs. Finally, we fall in the if, and output:

l6 ParamValue
...
l42 NullCheck [ l6 ]
v43 Invoke [ l42 ... ]
...
l52 NullCheck [ l42 ]  <== output is ignored, will be removed
v53 Invoke [ l42 ... ] <== notice the s/l52/l42/

Is that more clear? Reversing the order of the if and the for and adding comments will make this more understandable, I guess.

596:0-603:2
Wed May 06 20:09:27 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cd290587_f1b72236
UUID: cd290587_517b96ed
Bytes: 328
Thanks for the explanations! Clear now.

I see... maybe we should not wait until GVN to remove the extra null checks. We can do it now and avoid this source of confusion. I don't mind doing it here but I'm not sure if the ssabuilder is the best place to do.. Let's chat offline.

Nicolas, do you have any early feedback on this?

609:11-609:49
Thu May 07 07:53:31 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ad24d1ad_73e1f817
Bytes: 225
Let's chat about the decision you made on doing this after SSA building. I don't understand it. As it is, you more or less added an optimization pass after the SSA. The idea was to do it during SSA to avoid calling Dominates.

