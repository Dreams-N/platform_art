Revision: e545eee026ddbc32020a80da029f7eefa9eb542b
Patch-set: 2
File: compiler/optimizing/intrinsics_arm.cc

857:0-858:42
Sat May 09 07:05:43 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ed5b293d_ac50e2b4
Bytes: 26
Same comment as for arm64.

864:67-864:80
Mon May 11 14:05:10 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: cd290587_a89127cd
Bytes: 54
Nit: start-index = 0 (to be consistent with line 896).

870
Mon May 11 14:05:10 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2d62a1ee_5eb391fe
Bytes: 195
Shouldn't you add this check:

  // Note that the null check must have been done earlier.
  DCHECK(!invoke->CanDoImplicitNullCheckOn(invoke->InputAt(0)));

as you did in x86 and x86-64 back ends?

File: compiler/optimizing/intrinsics_arm64.cc

1000:0-1001:42
Sat May 09 07:05:43 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ad921112_ccd597e1
Bytes: 144
Shouldn't you just say that we are going to call a hand-crafted assembly stub that requires the inputs to follow the runtime calling convention?

1000:0-1001:42
Mon May 11 12:15:22 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ad921112_ccd597e1
UUID: 2d62a1ee_a333966f
Bytes: 84
yea, please do so. I was a bit confused by this comment before seeing Nicolas' note.

1043:4-1043:38
Sat May 09 07:05:43 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ed5b293d_ec56dab2
Bytes: 17
What is that for?

1043:4-1043:38
Sat May 09 07:47:04 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ed5b293d_ec56dab2
UUID: 0d679d0f_4d44197a
Bytes: 245
Taken from how InvokeRuntime does it. I think it disallows the macro assembler to use any helper registers so as to not clobber anything.

I have copied that from InvokeRuntime as that potentially records a safepoint, which isn't necessary here.

1043:4-1043:38
Sat May 09 14:15:58 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0d679d0f_4d44197a
UUID: ed5b293d_0cb80e51
Bytes: 54
So are you saying you are not sure we need it? Serban?

1043:4-1043:38
Mon May 11 10:55:52 2015 +0000
Author: Serban Constantinescu <1072549@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ed5b293d_0cb80e51
UUID: cd290587_e8872f13
Bytes: 386
We use the BlockPoolsScope whenever we call RecordPcInfo(). This way we make sure that the Vixl MacroAssembler does not generate any Literal or Vermeer Pool behind our back and thus GetAssembler()->CodeSize() will record the correct exact native_pc position of an instruction that might cause a transition to the runtime.

In this case is not needed since we do not call RecordPcInfo().

1057:0-1058:42
Sat May 09 07:05:43 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ed5b293d_cc59d6e1
Bytes: 5
ditto

