Revision: c4d85f8b63bf1d0ecd4deec633ac05541778855a
Patch-set: 1
File: compiler/optimizing/builder.cc

1026:8-1026:22
Tue Dec 02 13:59:55 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 3f70f517_ca904757
Bytes: 100
I actually did not mind having the duplication. Macros tend to make things less readable. Up to you.

1026:8-1026:22
Tue Dec 02 17:46:03 2014 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 3f70f517_ca904757
UUID: ff82dd17_50e96440
Bytes: 65
Alright; I reverted this.  Iy wasn't a huge gain of lines anyway.

File: compiler/optimizing/code_generator_x86.cc

1574:36-1574:46
Tue Dec 02 13:43:12 2014 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 3f70f517_2aa8fb95
Bytes: 63
worth a comment why this is 0x7fff...

same in the other place.

1574:36-1574:46
Tue Dec 02 13:59:55 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 3f70f517_2aa8fb95
UUID: ff82dd17_50f9648e
Bytes: 68
You could create a (shared) kFooBar constant with a meaningful name.

1574:36-1574:46
Tue Dec 02 17:46:03 2014 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ff82dd17_50f9648e
UUID: 3f70f517_aadf8b8c
Bytes: 4
Done

1584:9-1584:24
Tue Dec 02 17:58:23 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1fb25112_240958c9
Bytes: 47
// TODO: use a slow path and avoid branch-over.

1586:9-1588:25
Tue Dec 02 17:58:23 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ffc01d6a_2383982c
Bytes: 816
float comparisons on x86 set unsigned flags, so less-than is CF=1. By comparing with MAX_INT as float and the appropriate < or >, you can then use subtract with borrow (SBB) to adjust the unorderered result (MIN_INT - 0x8000000) to MAX_INT - 0x7FFFFFF. This can avoid the branch over too. Something like this here:

http://git.codehaus.org/gitweb.cgi?p=mrp.git;a=blob;f=rvm/src/org/jikesrvm/compilers/baseline/ia32/BaselineCompilerImpl.java#l1826

I see this is a literal bring over of the quick code that I whinged at Intel was sub-optimal at the time. The general issue is how to compare with a float constant? The best way is to place it in a literal pool at the end of the code and RIP encode the loading. I don't think the Intel assemblers support PC relative literals yet - something they lack compared to ARM.

