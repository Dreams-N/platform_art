Revision: 19241d8f4b27f77f4ddc6bb89414a77050d0f802
Patch-set: 3
File: runtime/debugger.cc

584:10-585:45
Fri Feb 19 12:18:30 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c2bbb59e_ea2b87c3
Bytes: 13
One per line.

584:10-585:45
Fri Feb 19 17:34:14 2016 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c2bbb59e_ea2b87c3
UUID: 82dc5dfe_76c4685e
Bytes: 4
Done

File: runtime/instrumentation.cc

155:0-155:63
Fri Feb 19 12:18:30 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 421b45b8_a62ec6d4
Bytes: 201
This looks like the only thing interesting to keep in this method. I would remove everything else: don't bother updating the entrypoint, just expect the runtime to do the interpreter -> jit transition.

155:0-155:63
Fri Feb 19 17:34:14 2016 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 421b45b8_a62ec6d4
UUID: a2d5e1d0_97e1cce6
Bytes: 692
Sorry can you be more specific? We need to install the entry-exit stub as wrapper around quick code. However if there is no quick code that can be used, I install the interpreter bridge (if entry-exit stub is installed, then seems to me there will be double instrumentation happening, one by the entry-exit stub and the other by interpreter).

I also have a question on Instrumentation::UpdateMethodsCode(), which is called by jit to install jitted code in method. However when entry_exit_stubs_installed_ is true, GetQuickInstrumentationEntryPoint() is installed, not jitted code. The entry-exit stub will still call GetQuickCodeFor() to get the oat code to call, instead of the jitted code.

155:0-155:63
Mon Feb 22 09:46:00 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a2d5e1d0_97e1cce6
UUID: c283b51b_8a456b91
Bytes: 158
How about we kill those entry-exit stubs and just rely on the interpreter? With mterp we should get enough performance benefits that I think we can afford it.

155:0-155:63
Mon Feb 22 21:39:04 2016 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c283b51b_8a456b91
UUID: c2981592_564c1417
Bytes: 226
Method tracing and debugger on at the same time should be extremely rare. Even when that happens it should be fine some debuggability is reduced. I think we should keep the entry-exit stubs for good method tracing performance.

155:0-155:63
Mon Feb 22 22:51:50 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c2981592_564c1417
UUID: 62b209f8_571f8cf2
Bytes: 376
Since JIT won't update the entry point (for now it's too risky to expose entry points that are not in an ArtMethod's entry point), we won't get performance under JIT anyway.

Actually, why do you need to change this method at all? To get "accurate" method tracing in the presence of inlining? I think that did not work even before, as Quick was inlining within the boot image.

791:2-793:7
Mon Feb 22 22:51:50 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 82affd8e_d8958d68
Bytes: 77
Why? This is an "undeoptimize operation", why can't you restore the AOT code?

