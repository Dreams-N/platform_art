Revision: b9e81a5ce6a0e565f083a500fb8ff06dca62473d
Patch-set: 1
File: compiler/optimizing/ssa_liveness_analysis.cc

186:0-186:31
Tue Feb 02 17:47:24 2016 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 31c3005d_9424c48e
Bytes: 199
This can fail in the case where one of the inputs is HX86LoadFromConstantTable, which has emitted_at_use_site_ true and no output.  How about:
DCHECK(has_out_location || input->IsEmittedAtUseSite())?

186:0-186:31
Tue Feb 02 17:52:44 2016 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 31c3005d_9424c48e
UUID: 5116b490_a5ba3e24
Bytes: 134
No, that is not enough, as the input has no SSA index.  I think you need to handle this case (IsEmittedAtUseSite) first.  Will confirm

186:0-186:31
Tue Feb 02 17:57:58 2016 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 5116b490_a5ba3e24
UUID: 91d90c41_3fd587de
Bytes: 444
There's nothing wrong with the DCHECK. What this says is that if an instruction expects an input value, the input instruction must produce one.

What you need to do is not set the in-location on the input which uses the HX86LoadFromConstantTable in the LocationBuilder. If you look at LocationBuilderX86::VisitAdd, you'll see that I've added code that does exactly that. You should do the same with the instructions you're modifying in your CL.

186:0-186:31
Tue Feb 02 17:58:13 2016 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 5116b490_a5ba3e24
UUID: 5116b490_8530e28e
Bytes: 1157
Working version:
  for (size_t i = 0, e = current->InputCount(); i < e; ++i) {
    HInstruction* input = current->InputAt(i);
    if (input->IsEmittedAtUseSite()) {
      // `Input` is inlined into `current`. Walk over its inputs and record
      // uses at `current`.
      RecursivelyProcessInputs(input, actual_user, live_in);
    } else {
      bool has_in_location = current->GetLocations()->InAt(i).IsValid();
      bool has_out_location = input->GetLocations()->Out().IsValid();

      if (has_in_location) {
        DCHECK(has_out_location);
        DCHECK(input->HasSsaIndex());
        // `Input` generates a result used by `current`. Add use and update
        // the live-in set.
        input->GetLiveInterval()->AddUse(current, /* environment */ nullptr, i, actual_user);
        live_in->SetBit(input->GetSsaIndex());
      } else if (has_out_location) {
        // `Input` generates a result but it is not used by `current`.
      }
    }
  }

This is similar to the version that I had in my code.  You could eliminate the last else if and replace the bools has_in_location and has_out_location with their expression in the only uses of them

