Revision: cc30205bdb78ae8c5ece0f457314ff8b22a0a8f7
Patch-set: 3
File: runtime/stack_map.cc

289:44-289:72
Thu May 28 15:33:48 2015 +0000
Author: Serban Constantinescu <1072549@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8d470d3e_95efc6cb
Bytes: 366
If you are re-factoring this what about adding oat_method.GetCodeOffset() to GetNativePcOffset() ? 

IMHO, this should make it easier to associate a native pc to the stack map's native_pc_offset since there would be no need to add the method's code_offset.

I have a patch in my tree that does this. I was planning to push it together with the slowpath sharing work.

289:44-289:72
Fri May 29 15:40:27 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8d470d3e_95efc6cb
UUID: 6d42d931_60bc5848
Bytes: 64
Thanks for the suggestion Serban.  I've implemented this in PS5.

289:44-289:72
Tue Jun 02 09:46:17 2015 +0000
Author: Serban Constantinescu <1072549@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6d42d931_60bc5848
UUID: b9a97860_e55ad6c7
Bytes: 5
PS6 ?

289:44-289:72
Tue Jun 02 11:09:50 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b9a97860_e55ad6c7
UUID: 99a8345d_24ba322f
Bytes: 547
I have changed art::StackMap::Dump in PS5 so that it now shows the relative PC offset *and* the (absolute) native PC.  The output looks like this now:

  [..]
  0x00aa71d8:         64FF1510010000               call fs:[0x110]  ; pAllocObject
    StackMap [native_pc=0xaa71df] (dex_pc=0x4, native_pc_offset=0x63, dex_register_map_offset=0x0, inline_info_offset=0xffffffff, register_mask=0x40, stack_mask=0b000000100000000000000000)
      v3: in register (6)   [entry 0]
  0x00aa71df:               8944240C               mov [esp + 12], eax
  [â€¦]

