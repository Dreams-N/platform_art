Revision: 6d23e205cfc25cf2499726d1629f2a6ebb813be8
Patch-set: 3
File: compiler/utils/mips64/assembler_mips64.cc

239:14-239:41
Fri Sep 11 05:19:01 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 244c8613_8475a70d
Bytes: 28
Why not [GpuRegister::]ZERO?

239:14-239:41
Fri Sep 11 12:17:16 2015 +0000
Author: Chris Larsen <1071873@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 244c8613_8475a70d
UUID: 64cf5e9f_a943f778
Bytes: 691
Because the instruction format is described in the documentation as:

SPECIAL3                         BITSWAP  BSHFL
 011111   00000    rt     rd      00000  100000
          ^^^^^

That is, the documentation doesn't specify a register value which goes into that field but says that the field must be all zeroes.

Also, other previously added functions for emitting other machine instructions (such as MultR2, MultuR2, DivR2, DivuR2, Sll, Srl, Sra, Dsll, Dsrl, Dsra, Dsll32, Dsrl32, Dsra32, Lui, etc.) follow this convention. I probably didn't write the function from scratch, but copied some other function which already used this convention, and just modified the other fields, as needed.

239:14-239:41
Fri Sep 11 17:41:37 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 64cf5e9f_a943f778
UUID: 64175efc_b51680de
Bytes: 595
Sorry, tradition isn't a good argument.

I'd rather have functions where types agree with what is expected. As such, EmitR isn't correct here. Your argument that it's zero and you don't want ZERO doesn't really apply if you have to cast it to GpuRegister. In that case, EmitR should actually take integrals always, and you let the GpuRegister be implicitly converted to that.

I'd rather have this gone, even if you hide it somewhere like:

 // A GPURegister value that will be encoded as a sequence of zeroes.
 static GpuRegister ZeroValue() {
   return ZERO;
 }

Vladimir, what's your opinion?

239:14-239:41
Fri Sep 11 20:25:56 2015 +0000
Author: Chris Larsen <1071873@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 64175efc_b51680de
UUID: 848ff2ac_fedac101
Bytes: 1745
That's fine. Internally, the suggestion was made that a new "Emit" function could be created for cases such as this, i.e., cases where register type instructions don't use all of the register positions. It's been my understanding that each patch should only address one issue. Would you prefer that this fix be rolled into this patch or submitted as a separate patch?

The methods which are using EmitR but using fewer than 3 registers fall into three categories. Instructions which use
- the t & d registers,
- the s & d registers,
- don't use any of the registers.

I'm proposing for the first case, quit using the the EmitR function and instead use a new function EmitRtd which would be implemented as:

void Mips64Assembler::EmitRtd(int opcode, GpuRegister rt, GpuRegister rd,
                               int shamt, int funct) {
  CHECK_NE(rt, kNoGpuRegister);
  CHECK_NE(rd, kNoGpuRegister);
  uint32_t encoding = static_cast<uint32_t>(opcode) << kOpcodeShift |
                      0u << kRsShift |  // Not needed?
                      static_cast<uint32_t>(rt) << kRtShift |
                      static_cast<uint32_t>(rd) << kRdShift |
                      shamt << kShamtShift |
                      funct;
  Emit(encoding);
}

The second case would be similar but use a new function called EmitRsd.

The "nop", nominally, falls into category 3, but architecturally it's really a special case of sll (sll ZERO, ZERO, 0) which puts it into the first case.

For the third case I would propose that the "sync" instruction be modified to use Emit directly:

void Mips64Assembler::Sync(uint32_t stype) {
  Emit((0u << kOpcodeShift) |
       (0u << kRdShift) |
       ((stype & 0x1f) << kShamtShift) |
       0xf);
}

Thoughts? Thanks.

