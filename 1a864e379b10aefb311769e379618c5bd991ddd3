Revision: 1a864e379b10aefb311769e379618c5bd991ddd3
Patch-set: 1
File: compiler/optimizing/nodes.cc

130:6-132:7
Thu Mar 03 10:17:08 2016 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 620689d1_ba6aed7c
Bytes: 1446
by commenting this out I've got 
+Thread: 78119 "main"
+Registers:
+    rax: 0xa6dbba5eb94f6100    rbx: 0x00007f5ab77cd228    rcx: 0x00007f5ab77ce250    rdx: 0x00007fff9b299930
+    rdi: 0x0000000000000078    rsi: 0x00007fff9b299938    rbp: 0x00007fff9b299920    rsp: 0x00007fff9b2998f0
+    r8 : 0x00007f5ab77cee28    r9 : 0x00007f5ab77cee20    r10: 0x00007f5ab77ce548    r11: 0x00007f5b8ce51c00
+    r12: 0x00007f5ab77cd228    r13: 0x00007f5ab77cd150    r14: 0x00007f5ab77ced48    r15: 0x00007fff9b299930
+    rip: 0x00007f5b8e36056d    eflags: 0x00010206 [ PF IF ]
+     cs: 0x00000033     gs: 0x00000000     fs: 0x00000000
+
+Backtrace:
+	#00 pc 000000000033256d  out/host/linux-x86/lib64/libartd-compiler.so (void art::ReplaceElement<art::dchecked_vector<art::HBasicBlock*, art::ArenaAllocatorAdapter<art::HBasicBlock*> >, art::HBasicBlock*>(art::dchecked_vector<art::HBasicBlock*, art::ArenaAllocatorAdapter<art::HBasicBlock*> >&, art::HBasicBlock* const&, art::HBasicBlock* const&)+29)
+	  std::__1::vector<art::HBasicBlock*, art::ArenaAllocatorAdapter<art::HBasicBlock*> >::begin()
+	   external/libcxx/include/vector:1464
+	  void art::ReplaceElement<art::dchecked_vector<art::HBasicBlock*, art::ArenaAllocatorAdapter<art::HBasicBlock*> >, art::HBasicBlock*>(art::dchecked_vector<art::HBasicBlock*, art::ArenaAllocatorAdapter<art::HBasicBlock*> >&, art::HBasicBlock* const&, art::HBasicBlock* const&)
+	   art/runtime/base/stl_util.h:137

1875:2-1877:3
Thu Mar 03 10:13:08 2016 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c2d7357d_aa31ef46
Bytes: 70
BTW, mentioned only now - so in this method we do not need code below.

File: test/579-inline-infinite/src/Main.java

20:21-20:29
Thu Mar 03 10:38:30 2016 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 42f42502_24187696
Bytes: 238
Could you also rename this to "$noinline$infinite"? The consequence of the bug is that the inliner does not reject the method as it should. The $noinline$ marker will make the compiler fail if the method stops being rejected at any point.

21:0-23:5
Thu Mar 03 09:46:17 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a2b16159_74fb668f
Bytes: 89
I don't understand this change. There's code in the inliner to not inline infinite loops.

21:0-23:5
Thu Mar 03 10:00:49 2016 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a2b16159_74fb668f
UUID: a2b881d5_537f9c87
Bytes: 487
Optimizing compiler has a bug. Indeed inliner checks whether the method contains infinite loop or not. It checks whether the graph corresponding to inlining method contains or not exit_block_ set. This field is set by builder in the beginning. After that exit block can be removed but no one clear exit_block_ field in graph. As result graph contains a link to block which is removed. So inliner does not really detect that inlining method contains the infinite loop.

I hope this helps.

21:0-23:5
Thu Mar 03 10:06:16 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a2b881d5_537f9c87
UUID: 42f42502_04e8da9a
Bytes: 85
No, why was I able to pass your test then?
/art/test/run-test --host --optimizing 579

