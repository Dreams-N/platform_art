Revision: 5101f8faed525b423561801bf35fba344d79c37b
Patch-set: 2
File: compiler/dex/quick/arm/call_arm.cc

180:0-180:69
Fri Mar 28 22:24:49 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1926e3b5_d0cb02e6
Bytes: 209
We should switch this to be the slow path, the gain from being inline is marginal and the code expansion imo not worth it. The slow path handles both recursion and quick path locking without going into C code.

180:0-180:69
Fri Mar 28 23:20:08 2014 +0000
Author: Dave Allison <1036486@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1926e3b5_d0cb02e6
UUID: f94bcf71_58d3ad4a
Bytes: 12
Separate CL.

180:0-180:69
Sat Mar 29 00:30:14 2014 +0000
Author: Bill Buzbee <1001578@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f94bcf71_58d3ad4a
UUID: d948cb7a_575b7c71
Bytes: 502
Ian, if I remember correctly, when you proposed doing this last year the tests showed measurable/significant performance degradation on at least some popular devices - which is why we didn't do it then.  Has something changed?  (or perhaps my memory isn't correct).  In any event, I agree with Dave that this should be taken up in a separate CL with new measurements to judge the cost/benefit.  I'd be thrilled if we could push this code out-of-line, provided there was no significant performance loss.

180:0-180:69
Mon Mar 31 18:05:45 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d948cb7a_575b7c71
UUID: f9a02f5c_3fe78354
Bytes: 279
measurable, yes, significant it was around the noise margin on a single benchmark. The issue that's relevant here is that Dave is optimizing a code path we should probably have just deleted for code expansion reasons. Note we don't have this code path on anything other than ARM.

180:0-180:69
Mon Mar 31 21:58:28 2014 +0000
Author: Dave Allison <1036486@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f9a02f5c_3fe78354
UUID: 39ae4766_867a0acb
Bytes: 124
Not optimizing it, just making it work.  We can move it to a slow path later but I wanted to get it into a good state first.

243:17-243:31
Fri Mar 28 22:24:49 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1926e3b5_b0c876ea
Bytes: 5
ditto

243:17-243:31
Fri Mar 28 23:20:08 2014 +0000
Author: Dave Allison <1036486@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1926e3b5_b0c876ea
UUID: f94bcf71_18dd3553
Bytes: 5
ditto

415
Sat Mar 29 00:30:14 2014 +0000
Author: Bill Buzbee <1001578@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d948cb7a_12e75254
Bytes: 566
What's the size of the overflow reserve?  In the previous code, we used a 2 operand sub form, which allows for a large immediate.  I don't have an ARM manual in front of me, but reg/reg/imm doesn't allow nearly as large an immediate - which could mean OpRegRegImm would try to allocate a temp register at this point.  Thinking about it though, I vaguely recall a special sub reg immediate form if the reg is SP.   Anyway, worth reviewing temp register requirements at this point in the code if you can't afford another temp register to be allocated behind your back.

415
Mon Mar 31 21:35:18 2014 +0000
Author: Dave Allison <1036486@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d948cb7a_12e75254
UUID: 79db5f06_f3d2aa21
Bytes: 422
It's 16K.  The ARM instruction sequence is:
sub r12,sp,#16384
ldr.w r12,[r12,#0]

Those are both 4 byte instructions due to the use of r12.  Thumb doesn't have a ldr.w r12,[sp,#-16384] or anything negative so this seems to be the best sequence I could find.

The offset is constant so there will never be a register allocated unless someone goes and changes it.  I'll add a comment to that effect in the code as a warning.

File: compiler/dex/quick/gen_invoke.cc

819
Sat Mar 29 00:30:14 2014 +0000
Author: Bill Buzbee <1001578@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 194fc37f_1f0abbed
Bytes: 20
leftover debug code?

819
Mon Mar 31 21:35:18 2014 +0000
Author: Dave Allison <1036486@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 194fc37f_1f0abbed
UUID: b9d157e4_f5761262
Bytes: 19
Indeed, I'll remove

File: runtime/arch/arm/fault_handler_arm.cc

169:0-170:21
Fri Mar 28 22:24:49 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1926e3b5_90c57ad4
Bytes: 154
why not 'ldr.w r12,[sp, #-16384]' ?
Note r12 is used for a hidden argument during imt resolution. This is ok as stack overflow checks occur post dispatch.

169:0-170:21
Fri Mar 28 23:20:08 2014 +0000
Author: Dave Allison <1036486@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1926e3b5_90c57ad4
UUID: d948cb7a_972a145c
Bytes: 196
Because thumb2 has no instruction for an ldr with a negative immediate offset.  You have to use an mvn instruction, or a movw/movt pair to put the offset into a register.

R12 is safe to use here.

File: runtime/stack.cc

37:0-37:38
Fri Mar 28 22:24:49 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1926e3b5_508952a1
Bytes: 117
can you follow the pattern from runtime to actually allocate a proper object? See the resolution method allocation...

37:0-37:38
Fri Mar 28 23:20:08 2014 +0000
Author: Dave Allison <1036486@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1926e3b5_508952a1
UUID: d948cb7a_573edc9e
Bytes: 18
I'll look into it.

37:0-37:38
Mon Mar 31 21:58:28 2014 +0000
Author: Dave Allison <1036486@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d948cb7a_573edc9e
UUID: b9d157e4_b53f2a33
Bytes: 258
On second thoughts, I think it's better just make this into a void* and not worry about allocating a real object.  It removes any future difficulties with moving objects, and whatever else we come up with.  Best not to have a fake object in the heap I think.

File: runtime/stack.h

109:22-109:23
Fri Mar 28 22:24:49 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1926e3b5_10daaab3
Bytes: 68
Can you make this not a mirror type as its breaking heap invariants.

109:22-109:23
Fri Mar 28 23:20:08 2014 +0000
Author: Dave Allison <1036486@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1926e3b5_10daaab3
UUID: 194fc37f_54101a1d
Bytes: 179
Does this not conflict with your desire to allocate a proper object for it?  I started out with a hardcoded constant address but thought it would be safer to use a static address.

File: runtime/thread.cc

257:0-257:53
Fri Mar 28 22:24:49 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1926e3b5_f0cefef7
Bytes: 30
this will add to footprint :-/

257:0-257:53
Fri Mar 28 23:20:08 2014 +0000
Author: Dave Allison <1036486@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1926e3b5_f0cefef7
UUID: d948cb7a_77e2f8f6
Bytes: 195
Yeah, but no choice.  You have to get the kernel to map the pages before you can mprotect them.  It only affects the main stack, so an overall footprint increase of 32K per process.  Not too bad.

257:0-257:53
Fri Mar 28 23:25:25 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d948cb7a_77e2f8f6
UUID: 3929e785_d7e89620
Bytes: 33
Could we madvise the memory away?

257:0-257:53
Mon Mar 31 21:35:18 2014 +0000
Author: Dave Allison <1036486@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 3929e785_d7e89620
UUID: 39ae4766_c6bb22a1
Bytes: 299
It's on the main stack only.  There's no point in doing that because the process will exit.

However, I just though of something.  We don't really need to touch the memory for non-main-stack threads.  I know in the caller if the stack is the main stack so I can only do the memset if it is the main.

