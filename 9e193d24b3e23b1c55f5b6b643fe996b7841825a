Revision: 9e193d24b3e23b1c55f5b6b643fe996b7841825a
Patch-set: 19
File: compiler/optimizing/nodes.cc

218:39-218:59
Sat Dec 12 13:41:24 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 85b2a2f4_37ca1874
Bytes: 117
This isn't really bottom. Maybe just say that by lack of proper type infrastructure, we use inexact Object as bottom.

218:39-218:59
Mon Dec 14 11:50:50 2015 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 85b2a2f4_37ca1874
UUID: 25673634_747aa89d
Bytes: 4
Done

File: compiler/optimizing/reference_type_propagation.cc

393:0-393:49
Sat Dec 12 13:41:24 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e59a7e77_d2b9e4ec
Bytes: 134
I'm not convinced this is better than the previous dual implementation. Now we've just made it harder to reason on an individual case.

393:0-393:49
Mon Dec 14 11:50:50 2015 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e59a7e77_d2b9e4ec
UUID: 85a702bf_8f665530
Bytes: 247
I don't mind either way but I would slightly side with this single implementation. Following the code path to each individual case isn't that difficult, it gets rid of duplicity and completely gets rid of the logic inside BoundTypeForIfInstanceOf.

393:0-393:49
Mon Dec 14 12:20:47 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 85a702bf_8f665530
UUID: a5532654_7b11fb9b
Bytes: 108
I don't really care either. This looks complex, but it's in one place and get's rid of the code duplication.

