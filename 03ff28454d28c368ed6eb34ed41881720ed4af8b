Revision: 03ff28454d28c368ed6eb34ed41881720ed4af8b
Patch-set: 2
File: runtime/entrypoints_order_test.cc

112:76-112:101
Tue Jul 07 09:39:36 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1840c241_30ac88a9
Bytes: 13
line too long

File: runtime/quick_exception_handler.cc

214:0-214:74
Tue Jul 07 09:39:36 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f8f4ce42_3f068728
Bytes: 143
So are we guaranteeing that every managed frame that is deoptimized *will* end up here and pick up its shadow frame (if created by SetValues) ?

214:0-214:74
Thu Jul 09 21:43:58 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f8f4ce42_3f068728
UUID: 98a11261_d03d2c98
Bytes: 86
debugger side will be responsible for that by patching the return pc's and reach here.

215:0-215:97
Tue Jul 07 09:39:36 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f8f4ce42_9f7593aa
Bytes: 120
Shouldn't it be the one with the highest (or lowest, not sure which way they are going) frame id? Could you DCHECK that?

215:0-215:97
Thu Jul 09 21:43:58 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f8f4ce42_9f7593aa
UUID: 98a11261_f0d708b6
Bytes: 81
Not sure if there is highest. The range can be from 0 to max allowed stack depth.

220:6-220:12
Tue Jul 07 13:10:36 2015 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f8f4ce42_9f1913a9
Bytes: 9
DCHECK_EQ

220:6-220:12
Thu Jul 09 21:43:58 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f8f4ce42_9f1913a9
UUID: d8970a01_4d8ae522
Bytes: 35
For nullptr DCHECK_EQ doesn't work.

240:12-240:61
Wed Jul 08 09:29:53 2015 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d8fb8a32_c140e408
Bytes: 961
This is wrong (and all others SetVRegXXX below) when the ShadowFrame has been created for the debugger with a value for the current vreg. Otherwise, we overwrite all values set by the debugger.

This means we need to know which registers have been set by the debugger so we do not override them, thus only set the vregs that have not been "touched" by the debugger. I think you need to keep a kind of set of all vregs modified by the debugger in the FrameIdToShadowFrame.

An alternative solution is to init your ShadowFrame (like we do it here) when creating it in Thread::GetDebuggerShadowFrameForFrameId. Therefore, when we deoptimize the current frame and we find there is already a ShadowFrame for it (in Thread::tlsPtr_.frame_id_to_shadow_frame list), it is already initialized (and even updated by the debugger) so there is nothing more to do (except linking it to previous ShadowFrame). It prevents from tracking which vregs are touched by the debugger.

240:12-240:61
Wed Jul 08 18:21:49 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d8fb8a32_c140e408
UUID: 534a1d43_ef311619
Bytes: 642
Very good point! I'll try this approach:
Have a CreateDebuggerShadowFrame() that returns a ShadowFrame that has another uint32_t array at the end that keeps track of which values are set. Debugger shadow frame will have a special dex_pc of 0xffffffff. A ShadowFrame::SetVRegForDebugger() will do regular SetVReg() plus setting a flag in the new array at the end. So later when we initialize deoptimized shadow frame here we check if the value has been set first.

Another thing is GetVRegFromOptimizedCode() also needs to check the debugger shadow frame first if one is available before it visits the real optimized stack frame to get values.

240:12-240:61
Wed Jul 08 20:55:49 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 534a1d43_ef311619
UUID: f8f4ce42_6586c2f2
Bytes: 164
I actually liked Sebastien's other suggestion of creating the deopt frame and eagerly fetch the values of vregs :-) Any reason you preferred to do it the other way?

240:12-240:61
Thu Jul 09 17:55:46 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f8f4ce42_6586c2f2
UUID: 731ba15b_57563ca1
Bytes: 777
1) creating the deopt frame requires verifier, class loading and may set thread local. I'm not sure if jdwp thread is a java thread and can do all of those. Class loading is done at a different time from the real deoptimization time from a different thread. And I'm a little uncomfortable about the possibility of accidentally setting jdwp thread's thread local which should be done on the visited thread.

2) since class loading can fail (especially if it's done from a different thread at a different time) so initializing the deopt frame can fail. Then it's not able to signal it's uninitialized values. I plan some change on GetVRegFromOptimizedCode() side also to get the set values first before visiting the compiled frame so it's good to be able to make the distinction.

240:12-240:61
Thu Jul 09 17:57:46 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 731ba15b_57563ca1
UUID: 18f28255_d4e41cd1
Bytes: 86
If creating the deopt frame did not need verifier, would 1) and 2) still be a problem?

240:12-240:61
Thu Jul 09 18:20:15 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 18f28255_d4e41cd1
UUID: 387026c3_3c90fd9e
Bytes: 142
Probably not. Cutting the dependency on verifier would be great. Actually what's the reason we need to run verifier for deoptimization? Quick?

File: runtime/stack.cc

481:0-481:32
Tue Jul 07 09:39:36 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d829ca86_ae6db7fb
Bytes: 114
Looks like GetDebuggerShadowFrameForFrameId never returns null if search_only is false. Should you DCHECK instead?

481:2-481:32
Tue Jul 07 13:10:36 2015 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 18f28255_40bcce57
Bytes: 121
Yeah, the ShadowFrame must exist here so it's more a CHECK(shadow_frame != nullptr) (and you can remove the if statement)

481:2-481:32
Thu Jul 09 21:43:58 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 18f28255_40bcce57
UUID: 789c5e2a_c4d81495
Bytes: 4
Done

File: runtime/thread.cc

242:1-242:8
Tue Jul 07 13:10:36 2015 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d8fb8a32_7e06515b
Bytes: 55
Also add DISALLOW_COPY_AND_ASSIGN(FrameIdToShadowFrame)

242:1-242:8
Thu Jul 09 21:43:58 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d8fb8a32_7e06515b
UUID: 789c5e2a_44064490
Bytes: 4
Done

243:2-243:8
Tue Jul 07 13:10:36 2015 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 18f28255_a31964a8
Bytes: 12
const size_t

243:2-243:8
Thu Jul 09 21:43:58 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 18f28255_a31964a8
UUID: d8970a01_2dd8b916
Bytes: 4
Done

244:2-244:14
Tue Jul 07 13:10:36 2015 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f8f4ce42_9fdeb3ce
Bytes: 18
ShadowFrame* const

248:54-250:72
Tue Jul 07 09:39:36 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 18f28255_a026fa44
Bytes: 18
Nit: one per line?

248:54-250:72
Thu Jul 09 21:43:58 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 18f28255_a026fa44
UUID: d8970a01_2df19990
Bytes: 83
Done. Now there is one arg anyway after refactoring to Findxxx and FindOrCreatexxx.

282:0-283:13
Tue Jul 07 09:39:36 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d8fb8a32_5e3ef5ea
Bytes: 23
no delete of the entry?

282:0-283:13
Thu Jul 09 21:43:58 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d8fb8a32_5e3ef5ea
UUID: 586ddaeb_e3d740b6
Bytes: 29
Nice catch. Added the delete.

File: runtime/thread.h

822:15-822:47
Tue Jul 07 13:10:36 2015 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d829ca86_cefda332
Bytes: 371
It's more "GetOrCreateDebuggerShadowFrameForFrameId" since you may create the frame if requested.

Why not having two distinct methods and remove the bool search_only flag? You would have:

  * FindDebuggerShadowFrameForFrameId: for finding the frame
  * GetOrCreateDebuggerShadowFrameForFrameId: for finding or creating the frame, using FindDebuggerShadowFrameForFrameId

822:15-822:47
Thu Jul 09 21:43:58 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d829ca86_cefda332
UUID: 98a11261_b0fae036
Bytes: 4
Done

1238:21-1238:26
Tue Jul 07 09:39:36 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d8fb8a32_7e39b100
Bytes: 22
more of a linked list?

1238:21-1238:26
Thu Jul 09 21:43:58 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d8fb8a32_7e39b100
UUID: 789c5e2a_2401b876
Bytes: 49
Changed to "a linked list that keeps the mapping"

1241:26-1241:50
Tue Jul 07 13:10:36 2015 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d8fb8a32_9e9c7d70
Bytes: 100
We must CHECK this is null when the thread exits, to be sure we do not leave any shadow frame there.

1241:26-1241:50
Thu Jul 09 21:43:58 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d8fb8a32_9e9c7d70
UUID: 387026c3_42a70897
Bytes: 35
Added a check in Thread::~Thread().

