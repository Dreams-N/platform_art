Revision: 2c7175d85ccfb9005cede0420ba720bb2bbb1b3b
Patch-set: 3
File: compiler/optimizing/code_generator_arm.cc

4716:25-4716:27
Tue Sep 15 17:25:53 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 89fb8b33_3ebc4911
Bytes: 58
Maybe add a kReturnReg? same for longs and other backends.

4722:4-4722:17
Tue Sep 15 17:25:53 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 44209a82_27735471
Bytes: 106
just a note that I had to implement this for unresolved fields:)  The interface is a bit different though.

4722:4-4722:17
Tue Sep 15 22:57:14 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 44209a82_27735471
UUID: 44725a92_05ef152e
Bytes: 39
Yours isn't merged, yet, though, right?

4722:4-4722:17
Wed Sep 16 14:27:25 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 44725a92_05ef152e
UUID: a9f4cf41_0247ec88
Bytes: 184
Nope, not merged yet. We shouldn't wait for each other here . I can have a cleanup CL and unify stuff. Just wanting to point out that we need to do a similar stuff in some other place.

4722:4-4722:17
Wed Sep 16 15:55:36 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a9f4cf41_0247ec88
UUID: e467cecb_a5f749f8
Bytes: 487
What do you think about the new version that uses the parallel move resolver.

I have also thought about a generic way to do the pairs: I could simply distinguish by asking the location whether it's a pair. So it would boil down to something like:

 HParallelMove ...
 if (target.IsPair()) {
   move.addMove(src.low(),target.low(),To32Type(type),...)
   move.addMove(src.high(),target.high(),To32Type(type),...)
 } else {
   move.addMove(src, target, type, ...)
 }
 resolver->emit(move);

4722:4-4722:17
Wed Sep 16 16:24:40 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e467cecb_a5f749f8
UUID: 691f3755_98193983
Bytes: 365
That's definitely better in this case as it removes duplication. For the other case (fpu <-> reg) I wasn't convinced about extending the resolver to handle it (just to avoid shooting ourselves in the foot, since it's a special case). 

I am more inclined to have a generic wrapper MoveLocation(dst, src). Produces less code :). arm64/mips64 already implements this.

File: compiler/optimizing/intrinsics_utils.h

70:15-70:37
Tue Sep 15 17:25:53 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e9ea475e_616eb63b
Bytes: 134
Do we consider out to be available as a temporary? If so add a note. Otherwise we don't need to do this if out is the return register?

70:15-70:37
Tue Sep 15 22:57:14 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e9ea475e_616eb63b
UUID: 0465c2c3_84a887c2
Bytes: 111
It's possible that out is a temp. Assumption here is that the callee will take care of out being already right.

