Revision: c810ebded1f476ce32b097392f63118e04086976
Patch-set: 3
File: runtime/quick_argument_visitor.h

199:0-212:3
Tue Dec 02 17:30:53 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: bfba25ec_fbd54bfb
Bytes: 386
This function is static and using constants, it doesn't motivate moving all this code into a header file. You need just make a public declaration of this function (or a function to call this function), the definition needn't be fast and can remain in the .cc file. If the issue is the function is declared in a class, don't declare it in a class or declare a global function to call it.

File: runtime/stack.cc

129:16-129:29
Wed Nov 26 09:48:10 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1fa5f182_069a9cd0
Bytes: 78
Don't you need the IsOptimized check before? Who compiles these proxy methods?

129:16-129:29
Wed Nov 26 10:46:57 2014 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1fa5f182_069a9cd0
UUID: 1fa5f182_09286dac
Bytes: 229
Proxy methods are only created at runtime (for a proxy class) so they are not compiled. They have special entrypoint artQuickProxyInvokeHandler to support the invoke. I think the optimizing compiler will handle them the same way.

129:16-129:29
Wed Nov 26 11:10:01 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1fa5f182_09286dac
UUID: 9f448158_04ba6442
Bytes: 122
Hmmm, so the cur_quick_frame_ check below is kind of misleading, right? It's not a frame generated by quick compiled code.

129:16-129:29
Wed Nov 26 14:03:41 2014 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 9f448158_04ba6442
UUID: 9f448158_18976451
Bytes: 183
It follows the Quick convention for stack layout at least (with Method* at sp[0]). Currently we either have Quick frame (compiled code and native/proxy) or Shadow frame (interpreter).

