Revision: 84956ff6c0ff150d86a08157216ded79217d860a
Patch-set: 2
File: runtime/reflection.cc

549:18-549:22
Thu Mar 27 09:04:12 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 19f8a337_4056109b
Bytes: 47
I don't understand this. Why unconditionally J?

549:18-549:22
Thu Mar 27 10:20:44 2014 +0000
Author: Narayan Kamath <1014443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 19f8a337_4056109b
UUID: 19f8a337_60a34c51
Bytes: 224
JValue is a packed 4 byte union. 

If I understand correctly, the conversions from float -> int here are actually being done by the C++ compiler. for eg, dst->SetF(src.GetI()) there's an implicit static_cast<float>(int32_t).

549:18-549:22
Thu Mar 27 10:21:26 2014 +0000
Author: Narayan Kamath <1014443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 19f8a337_60a34c51
UUID: 99ec937b_4456209b
Bytes: 15
s/done/inserted

549:18-549:22
Thu Mar 27 10:25:31 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 19f8a337_60a34c51
UUID: 19f8a337_009248fb
Bytes: 86
Ah thanks! I skipped the JValue definition.... (A type is always a class, right? :-)).

