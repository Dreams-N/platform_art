Revision: ab1efba41e1d8fe32157cb4adffb9ce8d6defcfd
Patch-set: 2
File: compiler/optimizing/builder.cc

1188
Fri Sep 11 16:20:09 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c4b72a4b_902894c7
Bytes: 135
const uint16_t

(browsing around this file, we don't seem to generally do that, but it is a good style to make write-once locals const)

1325:2-1325:10
Fri Sep 11 16:20:09 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 64175efc_9536e419
Bytes: 14
const uint16_t

File: compiler/optimizing/load_store_elimination.cc

27:2-27:10
Fri Sep 11 16:20:09 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 24a64628_4b3de5f0
Bytes: 13
why explicit?

42:7-42:26
Fri Sep 11 16:20:09 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c4b72a4b_500f4c64
Bytes: 92
something like "may become" is not very clear at first reading, please add more detailed doc

53:6-53:19
Fri Sep 11 16:20:09 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a405d6c4_77fb50b0
Bytes: 142
C++ style guide requires every class to get a top comment
please follow that rule so that your readers can grasp the meaning of classes faster

55:2-55:10
Fri Sep 11 16:20:09 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 44ab3af0_0cf81783
Bytes: 9
explicit?

59:10-59:14
Fri Sep 11 16:20:09 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c4b72a4b_904ff4a9
Bytes: 91
use (1) instead of 1) so that some old style tools for matching brackets don't get confused

186:10-186:11
Fri Sep 11 16:20:09 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 84a1b20e_8e287bc7
Bytes: 12
const size_t

234:8-234:88
Thu Sep 17 07:47:53 2015 +0000
Author: Zheng Xu <1074104@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 09bb1ba1_6a4f97aa
Bytes: 41
What happens if ref1 inherits from ref2 ?

247:50-247:53
Fri Sep 11 16:20:09 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c4b72a4b_f054803f
Bytes: 5
const

325:67-325:70
Fri Sep 11 16:20:09 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 841c5220_b64a089a
Bytes: 8
const 2x

527:60-527:61
Fri Sep 11 16:20:09 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 24a64628_0b947d01
Bytes: 744
this makes me a bit uncomfortable, the volatile stuff is fine but just being a sync block is not what is preventing optimizations (since the method itself can be inside a sync block) 

synchronized, besides mutual exclusion, is used for memory visibility between threads (through the happens-before relation). What is needed is that, conceptually, when a lock is acquired, the "cache" is invalided and all loads need to occur again. Likewise, when the lock is released the "cache" is flushed, i.e. all writes need to be done.

it does not matter for now, since you are just being overly conservative; but having this "inside monitor" concept may scare future developers; I would much rather see a proper solution around monitor-enter/exit calls

527:60-527:61
Fri Sep 11 21:10:22 2015 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 24a64628_0b947d01
UUID: 6473de94_756b28e5
Bytes: 862
Agreed.

I'm not sufficiently familiar with this code base to tell whether this actually satisfies the necessary restrictions.

Some examples of the memory model rules for checking purposes.  Here v is volatile, x is not:

r1 = x;
r2 = v;
r3 = x;

Here the second load of x can NOT be replaced by r1.  (If there are no intervening uses, the other way around works.)
The same of the middle statement is replaced by another "acquire" operation, e.g. MonitorEnter. 

r1 = v;
r2 = v;  

It's fine to combine these if there are no intervening shared memory accesses.  This is not important, but I wanted to emphasize that these are not C volatiles.

In general the effect on the algorithm of a volatile load should be essentially the same as MonitorEnter, and volatile store should be treated similarly to MonitorExit.  But the dramatic asymmetry between those cases.

538:28-538:55
Fri Sep 11 21:10:22 2015 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 44725a92_34a6108e
Bytes: 531
The real monitor level is presumably dynamic, since it depends on callers as well.  I don't think this test makes any sense here.  Note that if you have

r1 = x;
synchronized (p1) {...};
synchronized (p2) {...};
r2 = x;

it is not safe to eliminate the second load, no matter what's in the ellipses.  A safe, though probably too strong, rule is to have the first monitor entry call kill all prior information.  (This particular case may actually be safe with a single critical section.  I'd need to think about it.  It is for C++.)

538:28-538:55
Thu Sep 17 07:47:53 2015 +0000
Author: Zheng Xu <1074104@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 44725a92_34a6108e
UUID: e9d407d5_b1198082
Bytes: 49
Maybe just regard monitor as volatile load/store?

778:24-778:25
Fri Sep 11 16:20:09 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 24a64628_6b126190
Bytes: 284
this is conservative, and imho not needed at all
(synchronized method is no different from calling a method on an object with the object's lock held)

so at least add comments to document why you do that now so that future developers are not afraid to go in and improve this later :-)

786:33-786:37
Fri Sep 11 16:20:09 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 24a64628_4b0fa564
Bytes: 85
"would act" 
seems a bit more clear than "acts", so that we understand why you return

File: compiler/optimizing/load_store_elimination.h

28:2-28:10
Fri Sep 11 16:20:09 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e4b0ae55_b12320ea
Bytes: 62
no need for explicit keyword since you have multiple args here

42:47-42:49
Fri Sep 11 16:20:09 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 64175efc_f52bd8af
Bytes: 47
empty line before the DISALLOW macro invocation

File: compiler/optimizing/nodes.h

4087:11-4087:36
Fri Sep 11 16:20:09 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 44ab3af0_6c6efbf6
Bytes: 89
the "Declaring" seems a bit overkill in the name, since none of the other getters do that

File: test/530-checker-lse/src/Main.java

57:0-58:33
Thu Sep 17 07:47:53 2015 +0000
Author: Zheng Xu <1074104@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e913274a_1cf5198e
Bytes: 81
Seems the reference alias analysis does something similar with escape analysis :)

61:39-61:40
Fri Sep 11 16:20:09 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 24a64628_2b5fb95a
Bytes: 13
this is nice!

164:13-164:29
Thu Sep 17 07:47:53 2015 +0000
Author: Zheng Xu <1074104@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2919bf72_937a3cf8
Bytes: 50
Maybe replace with a phi node as VMarko suggested.

189:13-189:29
Thu Sep 17 07:47:53 2015 +0000
Author: Zheng Xu <1074104@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 89246ba5_96a58cea
Bytes: 5
ditto

229:0-232:74
Thu Sep 17 07:47:53 2015 +0000
Author: Zheng Xu <1074104@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 6992d715_1d841394
Bytes: 139
I'm not familiar with the debugger. Is it possible that debugger updates the heap value and we still run the compiled code not interpreter?

427:2-427:3
Fri Sep 11 16:20:09 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c402caba_5802bd14
Bytes: 116
uh, don't you want to verify the output of the methods?

optimization without verification is, well, very dangerous!

