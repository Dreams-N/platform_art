Revision: 0cf4493166ff28518c8eafa2d0463f6e817cce75
Patch-set: 7
File: compiler/optimizing/builder.cc

472:0-472:48
Sun Dec 27 11:00:31 2015 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 6a773b0f_46a532bf
Bytes: 56
Not necessary - arena allocated memory is always zeroed.

File: compiler/optimizing/code_generator_arm.cc

1626:0-1626:49
Sun Dec 27 11:00:31 2015 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 6a8e5b43_2eee47df
Bytes: 830
Are you sure this is safe? The runtime assumes that there is at most one stack map per native_pc_offset, e.g. when searching for a deoptimize or try/catch stack map (go/stack-map-native). If the previous HIR instruction generated a stack map for its last native instruction, this will generate another one with the same native pc offset.

It's probably fine for the moment because GetStackMapForNativePcOffset does a linear search and will thus always return the first encountered stack map, but we've been planning to change it to binary search.

Either way, I feel like this is breaking an implicit agreement between the compiler and the runtime (which we should probably try to enforce in the stack map stream) and should at least be better documented. If it were up to me, I'd emit a NOP to bump the native_pc as a safety net.

1626:0-1626:49
Wed Jan 06 15:19:24 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6a8e5b43_2eee47df
UUID: 6a31fb81_593a270b
Bytes: 35
Good point. dsrbecky@ any thoughts?

1626:0-1626:49
Wed Jan 06 16:59:32 2016 +0000
Author: David Srbecky <1065473@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6a8e5b43_2eee47df
UUID: 6a31fb81_b9e1fbbc
Bytes: 249
If there are two stack maps generated for the same native_pc, aren't they essentially guaranteed to be equivalent?  Does it matter which one the run-time picks?

I think my only concern is that this might waste a bit of memory due to the redundancy.

1626:0-1626:49
Thu Jan 07 09:55:03 2016 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6a31fb81_b9e1fbbc
UUID: 6a5f3bcc_896dbd0a
Bytes: 620
They are *not* guaranteed to be equivalent. Each is generated for a different HInstruction, likely with a different HEnvironment because the non-NativeDebugInfo instruction will have overwritten its output vreg. Since you generate NativeDebugInfos at the beginning of basic blocks, they're not even guaranteed to come from two subsequent HInstructions.

And yes, it is absolutely critical that the runtime picks the correct one, otherwise it will look for values of vregs in the wrong locations. Deoptimization might then wrongly initialize the interpreter and try/catch will set wrong values of phis in the catch block.

1626:0-1626:49
Thu Jan 07 11:49:53 2016 +0000
Author: David Srbecky <1065473@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6a5f3bcc_896dbd0a
UUID: 0a54ffaf_46d1f47e
Bytes: 208
Oh.  I assumed the dex mapping would correspond to the state at native_pc.  This is not the case?  (i.e. does the dex mapping store state before the HInstruction, but native_pc the PC after the HInstruction?)

1626:0-1626:49
Thu Jan 07 12:17:14 2016 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0a54ffaf_46d1f47e
UUID: 8a68ef71_2a9cbf2c
Bytes: 1124
Nope. The dex register map is generated from the HEnvironment of the HInstruction which reflects the mapping state before the HInstruction, not the native instruction. Since an HInstruction may emit multiple native instructions, the stack map reflects neither the state before nor after that native instruction. It is simply generated at an address where it is easily locatable by the runtime, typically at the end.

You also need to realize that the location mapping is not generated by codegen but by the register allocator. Each HInstruction is given its own linear-scan position and the register allocator can generate a different mapping at each position. Since the debug info has its own HInstruction, it will also get its own position different from other HInstructions. There's no connection to the resulting native pcs whatsoever.

But as I said from the start, all you need to do is emit a NOP before you call RecordPcInfo. Your stack map will get a unique native_pc and life will be swell again. Since that's a single instruction, you can also assume that such stack map reflects the state of the world before it.

1626:0-1626:49
Thu Jan 07 13:51:39 2016 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8a68ef71_2a9cbf2c
UUID: 6a5f3bcc_894e1d70
Bytes: 189
Sorry, brain freeze. With normal stack maps you can of course assume that the stack map reflects the state just before the corresponding native instruction.

Everything else still stands...

1626:0-1626:49
Thu Jan 07 13:57:16 2016 +0000
Author: David Srbecky <1065473@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8a68ef71_2a9cbf2c
UUID: 6a5f3bcc_a953d918
Bytes: 613
Would it be crazy to set the native_pc to point at the first native instruction? (so it actually corresponds to the location of dex maps)

I am thinking what I need to do in the debugger when looking at the backtrace.  Let's say I am interested in local variables of non-leaf function.  The debugger will tell me the the PC of the call instruction, but there is no useful stack map there, I need to know to actually lookup the data a bit further down.  Even worse, if I wanted to see variables after finishing step out (and thus have PC right after the native call instruction), I would be in even bigger trouble.

