Revision: 4be15d55ddab0f25ba09fea4086cb9fe437d16ae
Patch-set: 8
File: compiler/optimizing/code_generator.cc

662:2-662:21
Fri Feb 05 10:51:34 2016 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 51feb4bd_e51236a7
Bytes: 81
Since you're not counting the edges any more, this can now be a BitVector, right?

662:2-662:21
Fri Feb 05 11:24:25 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 51feb4bd_e51236a7
UUID: 51feb4bd_6582c6ef
Bytes: 95
Yes, but as it could be useful information (number of back edges), I'd rather keep it this way.

802:4-802:29
Fri Feb 05 10:51:34 2016 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1126fc4f_93f3bcc5
Bytes: 149
Thanks for adding this, we should have had this a long time ago. Could you refactor the code a little to also apply to non-OSR SuspendChecks, though?

802:4-802:29
Fri Feb 05 11:24:25 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1126fc4f_93f3bcc5
UUID: 918f4c7c_2ffe0980
Bytes: 4
Done

File: runtime/jit/jit_code_cache.h

249:2-249:34
Fri Feb 05 10:51:34 2016 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 51feb4bd_2533ae33
Bytes: 225
I'm gonna nitpick here because the map is queried from the interpreter instrumentation...

What is the expected number of entries for this map? If it's in single digits, a vector of pairs would give you better cache locality.

249:2-249:34
Fri Feb 05 11:24:25 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 51feb4bd_2533ae33
UUID: 51feb4bd_457fcab5
Bytes: 65
Who knows, depends on the app really. I wouldn't sweat it though.

File: runtime/jit/jit_instrumentation.cc

163:2-163:46
Fri Feb 05 11:36:49 2016 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 7176584c_ce7663df
Bytes: 247
This tells me that you might store two different compiled methods: osr and normal).

Can't you re-use the normal compile method here?
If not, do we get rid of the osr method eagerly (once the execution of the methods finishes we wouldn't need it)?

File: runtime/thread.cc

3019:99-3019:104
Fri Feb 05 10:51:34 2016 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f1340868_22012e4f
Bytes: 9
long line

3019:99-3019:104
Fri Feb 05 11:24:25 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f1340868_22012e4f
UUID: f1340868_8236fa20
Bytes: 4
Done

File: test/570-checker-osr/src/Main.java

65:38-65:45
Fri Feb 05 10:51:34 2016 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 918f4c7c_4fd58d11
Bytes: 48
Can we have a non-zero pattern for the high reg?

65:38-65:45
Fri Feb 05 11:24:25 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 918f4c7c_4fd58d11
UUID: d185445a_1101ec4e
Bytes: 26
Yes, it's already there :)

