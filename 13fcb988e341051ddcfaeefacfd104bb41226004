Revision: 13fcb988e341051ddcfaeefacfd104bb41226004
Patch-set: 1
File: compiler/dex/frontend.cc

874
Wed Jul 02 18:32:11 2014 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 04cafddd_a6580633
Bytes: 181
Removing kNullCheckElimination from here and doing: mma clean-oat && mma will hit the DCHECK(target_lir) issue.

You can also try running test 082 and it will fail in a similar way.

File: compiler/dex/quick/arm64/int_arm64.cc

500
Thu Jul 03 11:48:12 2014 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 445eb5fe_f80491af
Bytes: 96
Do we really need this? Shouldn't we just LoadValueWide() below and get rid of the As64BitReg()?

500
Thu Jul 03 17:18:28 2014 +0000
Author: Matteo Franchin <1037505@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 445eb5fe_f80491af
UUID: 445315fd_b3a5c2a9
Bytes: 64
I agree, this does not make sense. We'll change it as suggested.

File: compiler/dex/quick/arm64/utility_arm64.cc

898:2-898:26
Thu Jul 03 23:43:53 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c4c385c9_4aacb78c
Bytes: 56
I was trying to find all cases where we get a 32b index.

898
Fri Jul 04 09:04:01 2014 +0000
Author: Matteo Franchin <1037505@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c4c385c9_4aacb78c
UUID: c498e5f7_bf2d9320
Bytes: 279
There are a couple of them (you can easily find them by restoring the check, which will lead to assertion failures). Using a 32-bit register as an index is, however, a legitimate thing to do (e.g. if the index is loaded with ldr wN, [...]) and therefore it is good to support it.

931
Wed Jul 02 18:35:39 2014 +0000
Author: Matteo Franchin <1037505@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e4c6c9d8_0517525f
Bytes: 322
The change above and the three analogous companions below are necessary to avoid problems with reference widths. Notice that without these changes, we would be asserting that references must be 32-bit wide. Notice that the one above is a hack, but a proper fix for this issue should probably come through a separate patch.

931
Thu Jul 03 23:43:53 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e4c6c9d8_0517525f
UUID: a4c051c0_86750ce0
Bytes: 138
This means we reach kReference through something that is not Load/Store*Ref*, and that is wrong, IMHO. I marked two cases in another file.

931
Fri Jul 04 09:04:01 2014 +0000
Author: Matteo Franchin <1037505@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a4c051c0_86750ce0
UUID: 043d9d9e_eee2ff3d
Bytes: 1282
OK. I now understand what your intentions are. I assumed that 

  LoadBaseIndexed(r_base, r_index, r_dest_ref, 0, kReference);

would be a perfectly legitimate thing do to for loading a reference. LoadRefIndexed() seems a specialisation of the function above. I assumed that one would use LoadRefIndexed(), when it is known that that the function-call always loads a reference. And I assumed that one would rather use LoadBaseIndexed(), when this is not known at compile time. In other words, I assumed that one would do:

  OpSize size = SizeOfDest(r_dest);
  int scale = ScaleOfDest(r_dest); // Or zero.
  LoadBaseIndexed(r_base, r_index, r_dest, scale, size);

Rather than:

  if (DestIsReference(r_dest)) {
    LoadRefIndexed(r_base, r_index, r_dest, 0);
  } else {
    OpSize size = SizeOfDest(r_dest);
    int scale = ScaleOfDest(r_dest); // Or zero.
    LoadBaseIndexed(r_base, r_index, r_dest, scale, size);
  }

I have still to get convinced that the latter is better than the former. But, we should - at least - clarify what the calling protocol is by adding a comment before LoadBaseIndexed such as "Do not use this to load a reference".

A problem would still remain, as the current prototype of LoadRefIndexed cannot replace LoadBaseIndexed if the offset is not scaled.

File: compiler/dex/quick/gen_invoke.cc

1702:4-1702:67
Thu Jul 03 11:48:12 2014 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 445eb5fe_183dc549
Bytes: 128
EvalLoc() calls EvalLocWide() for wide location. Why do we need to split this instead of initializing rl_result above as before?

1702
Thu Jul 03 17:18:28 2014 +0000
Author: Matteo Franchin <1037505@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 445eb5fe_183dc549
UUID: 246381c5_3d26f720
Bytes: 44
You are right, this line can be moved above.

1703:0-1706:75
Thu Jul 03 11:48:12 2014 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a495b1be_1be13bb1
Bytes: 77
These can be merged, the LoadBaseIndexed() is correct for x86/x86_64 as well.

1706
Thu Jul 03 17:18:28 2014 +0000
Author: Matteo Franchin <1037505@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a495b1be_1be13bb1
UUID: 246381c5_bdc207cb
Bytes: 12
OK, will do.

1714:4-1716:56
Thu Jul 03 23:43:53 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a4c051c0_26853881
Bytes: 45
Should be LoadRefIndexed when you have a ref.

1716
Fri Jul 04 09:04:01 2014 +0000
Author: Matteo Franchin <1037505@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a4c051c0_26853881
UUID: 043d9d9e_eefbdfdd
Bytes: 91
AFAICS, LoadRefIndexed uses scale == 2, here we use scale == 0. I think this will not work.

1716
Fri Jul 04 09:11:18 2014 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 043d9d9e_eefbdfdd
UUID: c498e5f7_3f8343b6
Bytes: 207
It's easy to miss and that's pretty dangerous. I would vote for getting rid of the Load/StoreRefIndexed() before it's widely used given that the Load/StoreBaseIndexed is supposed to handle kReference anyway.

1716
Fri Jul 04 10:52:07 2014 +0000
Author: Matteo Franchin <1037505@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c498e5f7_3f8343b6
UUID: 04cafddd_b07f95ec
Bytes: 451
The implicit scaling of the offset register in Load/StoreRefIndexed() is something I certainly would not expect as a "natural behaviour". I suspect that these functions should either not scale the index, or - if they do - be named differently (e.g. LoadRefScaleIndexed()?). Alternatively, they could take a boolean (to indicate whether to scale or not) or they could be removed, as you suggest. I have no strong opinions about what is the best option.

1716
Fri Jul 04 17:14:07 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 04cafddd_b07f95ec
UUID: 4485d588_466cc646
Bytes: 432
I have a strong opinion, and it's for keeping this. The reason to introduce the Ref functions was twofold: 1) to avoid having to check in the Base functions whether we have a small or a large register, and more importantly 2) so that all ref handling is in a "central" place. If/when we move to references being more than 32b pointers, this will allow us to easily and in very obvious places implement the compress/uncompress logic.

1716
Fri Jul 04 17:19:41 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4485d588_466cc646
UUID: a4c051c0_49084545
Bytes: 154
I should have made this clearer: missing the scale parameter was an oversight of mine. Load/StoreRefIndexed should have that parameter if it is necessary.

1716
Fri Jul 04 17:31:25 2014 +0000
Author: Matteo Franchin <1037505@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a4c051c0_49084545
UUID: 445315fd_397b7347
Bytes: 180
OK. Could we move this discussion to CL 100257?

  https://android-review.googlesource.com/#/c/100257/

We could merge this patch as is and try to "get it right" in a dedicated CL.

1716
Fri Jul 04 18:29:26 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 445315fd_397b7347
UUID: 4485d588_06fb9e28
Bytes: 77
I agree. I am testing this patch right now, and will hopefully merge it soon.

1754:0-1757:75
Thu Jul 03 11:48:12 2014 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 445eb5fe_78340164
Bytes: 78
These can be merged, the StoreBaseIndexed() is correct for x86/x86_64 as well.

1757
Thu Jul 03 17:18:28 2014 +0000
Author: Matteo Franchin <1037505@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 445eb5fe_78340164
UUID: 04cafddd_7bf4e364
Bytes: 8
Will do.

1766:4-1767:56
Thu Jul 03 23:43:53 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c4c385c9_aa89eb19
Bytes: 44
Should be StoreRefIndexed if you have a ref.

1767
Fri Jul 04 09:04:01 2014 +0000
Author: Matteo Franchin <1037505@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c4c385c9_aa89eb19
UUID: c498e5f7_1f3da749
Bytes: 24
Again, scale == 0, here.

