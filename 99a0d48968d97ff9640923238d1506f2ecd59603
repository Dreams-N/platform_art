Revision: 99a0d48968d97ff9640923238d1506f2ecd59603
Patch-set: 1
File: runtime/class_linker.cc

3493:29-3493:56
Wed Oct 14 18:16:04 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 5fa8725b_2b58bae5
Bytes: 78
Would be shorter and just as expressive to add the NewHandle template instead?

3493:29-3493:56
Wed Oct 14 18:19:17 2015 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 5fa8725b_2b58bae5
UUID: 7fa9b65d_98b1fc68
Bytes: 34
You mean a 0-argument constructor?

3493:29-3493:56
Wed Oct 14 18:21:07 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7fa9b65d_98b1fc68
UUID: 7f2b7617_84fcd06c
Bytes: 128
I mean this:

  hs_iface.NewHandle<mirror:Class>(nullptr)

That should work, right? IMHO that looks better than the static_cast.

3493:29-3493:56
Wed Oct 14 18:24:40 2015 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7f2b7617_84fcd06c
UUID: 9fae6a64_70953d3f
Bytes: 516
Nope:
    art/runtime/class_linker.cc:3493:20: error: no matching member function for call to 'NewHandle'
              hs_iface.NewHandle(nullptr));
              ~~~~~~~~~^~~~~~~~~
    art/runtime/handle_scope.h:153:34: note: candidate template ignored: could not match 'T *' against 'nullptr_t'
  ALWAYS_INLINE MutableHandle<T> NewHandle(T* object) SHARED_REQUIRES(Locks::mutator_lock_);
                                     ^

I think it has to do with the way that nullptr interacts with templates or something.

3493:29-3493:56
Wed Oct 14 18:25:35 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 9fae6a64_70953d3f
UUID: 5fa8725b_2ba67a2d
Bytes: 66
I suggested to explicitly mark the template (which you omitted)...

3493:29-3493:56
Wed Oct 14 18:35:54 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 5fa8725b_2ba67a2d
UUID: 7fa9b65d_d8e3f435
Bytes: 62
Why don't we have an empty MutableHandle constructor for null?

3493:29-3493:56
Wed Oct 14 18:43:51 2015 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7fa9b65d_d8e3f435
UUID: bfb7aeb4_449f1f60
Bytes: 80
We need to have it copy from NewHandle or else it's not bound to the scope IIUC.

3493:29-3493:56
Wed Oct 14 18:43:51 2015 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 5fa8725b_2ba67a2d
UUID: 3fa3be81_00d35761
Bytes: 55
Ah. Sorry templates are still somewhat new to me. Done.

3499:39-3499:43
Wed Oct 14 18:16:04 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ff32061b_59ffde1c
Bytes: 7
Remove.

3499:39-3499:43
Wed Oct 14 18:43:51 2015 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ff32061b_59ffde1c
UUID: 9fae6a64_b06975e2
Bytes: 4
Done

3617
Wed Oct 14 18:35:54 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: df39c202_5d76ac99
Bytes: 9
UNLIKELY?

3617
Wed Oct 14 18:43:51 2015 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: df39c202_5d76ac99
UUID: bfb7aeb4_64a4a3ab
Bytes: 4
Done

3617:2-3620:60
Wed Oct 14 18:16:04 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 3fa3be81_8042e7d4
Bytes: 145
You could consider asking for a MutableHandle from the caller. That way the class-hierarchy traversal doesn't install more than one handle scope.

3617:2-3620:60
Wed Oct 14 18:35:54 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 3fa3be81_8042e7d4
UUID: 7f2b7617_a4d9cc0c
Bytes: 66
agreed,

but how will it know the right size for StackHandleScope?

3617:2-3620:60
Wed Oct 14 18:43:51 2015 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 3fa3be81_8042e7d4
UUID: 9fae6a64_707c5da9
Bytes: 510
This path is extremely cold. I really don't think it would make enough of a difference to be worth how confusing it would make the function signature and call.

For example aosp/libcore has ~400 interfaces of which only ~120 extend anything (for context there are ~6000 classes in libcore).

    % git grep -E "^[^\*\"\/]*[^@]class " | wc -l              
    5894

    % git grep -E "^[^\*\"\/]*[^@]interface " | wc -l          
    395

    % git grep -E "^[^\*\"\/]*[^@]interface .* extends" | wc -l
    122

3617:2-3620:60
Wed Oct 14 18:46:50 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 9fae6a64_707c5da9
UUID: 7fa9b65d_78744000
Bytes: 260
Igor: you only need *one* handle (which has to be Mutable).

Alex: Libcore is not that interesting, because of the boot image. Look into apps - at least in the L time frame we had Google apps with non-trivial amount of interfaces. Then there's always Facebook.

3617:2-3620:60
Wed Oct 14 18:49:40 2015 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7fa9b65d_78744000
UUID: bfb7aeb4_246d4bee
Bytes: 210
No I think igor is right. We also need to keep around the 'iface' handle over this call and the handle_super_iface becomes that handle the next call down so each recursion requires another handle to be created.

