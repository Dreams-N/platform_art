Revision: 99a0d48968d97ff9640923238d1506f2ecd59603
Patch-set: 1
File: runtime/class_linker.cc

3493:29-3493:56
Wed Oct 14 18:16:04 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 5fa8725b_2b58bae5
Bytes: 78
Would be shorter and just as expressive to add the NewHandle template instead?

3493:29-3493:56
Wed Oct 14 18:19:17 2015 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 5fa8725b_2b58bae5
UUID: 7fa9b65d_98b1fc68
Bytes: 34
You mean a 0-argument constructor?

3493:29-3493:56
Wed Oct 14 18:21:07 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7fa9b65d_98b1fc68
UUID: 7f2b7617_84fcd06c
Bytes: 128
I mean this:

  hs_iface.NewHandle<mirror:Class>(nullptr)

That should work, right? IMHO that looks better than the static_cast.

3493:29-3493:56
Wed Oct 14 18:24:40 2015 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7f2b7617_84fcd06c
UUID: 9fae6a64_70953d3f
Bytes: 516
Nope:
    art/runtime/class_linker.cc:3493:20: error: no matching member function for call to 'NewHandle'
              hs_iface.NewHandle(nullptr));
              ~~~~~~~~~^~~~~~~~~
    art/runtime/handle_scope.h:153:34: note: candidate template ignored: could not match 'T *' against 'nullptr_t'
  ALWAYS_INLINE MutableHandle<T> NewHandle(T* object) SHARED_REQUIRES(Locks::mutator_lock_);
                                     ^

I think it has to do with the way that nullptr interacts with templates or something.

3499:39-3499:43
Wed Oct 14 18:16:04 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ff32061b_59ffde1c
Bytes: 7
Remove.

3617:2-3620:60
Wed Oct 14 18:16:04 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 3fa3be81_8042e7d4
Bytes: 145
You could consider asking for a MutableHandle from the caller. That way the class-hierarchy traversal doesn't install more than one handle scope.

