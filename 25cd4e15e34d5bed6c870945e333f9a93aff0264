Revision: 25cd4e15e34d5bed6c870945e333f9a93aff0264
Patch-set: 3
File: compiler/optimizing/nodes.h

3352:7-3352:21
Wed Apr 22 13:14:41 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 9070061a_872ba87c
Bytes: 169
MustDoNullCheck is probably better, as this suggests it it the same thing as Input(0)->CanBeNull.

A comment that this is only used by code generation might be good too.

File: compiler/optimizing/reference_type_propagation.cc

93:0-97:7
Wed Apr 22 13:14:41 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 706b9231_c34bd6b5
Bytes: 343
I don't think this is the right place for doing this.

At the very end of the optimizations, before code generation, you have all the information you need: an HInstanceOf instruction takes an input, and you can just query that input to know whether it can be null.

I think a good place for this could be in prepare_for_register_allocation.cc.

93:0-97:7
Wed Apr 22 13:29:26 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 706b9231_c34bd6b5
UUID: 90972654_8ced873b
Bytes: 928
Doing it here you'll also miss patterns where the direct input cannot be null anyway (which may result because of inlining).

e.g.
void f() {return new A()}
void g() {
 Object x = f(); // this will be inlined and instanceof will not have a bound type as input.
 if (x instanceof A) {
 }
}

However I'm not sure I'd move this to prepare_for_register_allocation.cc.

This still deals with nullability propagation which is one thing this analysis does. Having related stuff together seems better to me. An you already have all the info you need for that after this pass. What do you think Nicolas?

Also, thinking forward we'd like to detect also cases like
a.f()
...
if (a instanceOf A){...}
which will probably require to look at the dominators anyway. I wouldn't do that either in prepare_for_reg_alloc.

If kept here a good place for it would be as a separate iteration over nodes at the end of ReferenceTypePropagation::Run().

93:0-97:7
Wed Apr 22 13:38:02 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 90972654_8ced873b
UUID: b0718a1d_a838734e
Bytes: 568
So ideally, at the code generation, you'd like to just do if (input->CanBeNull()).

But we get rid of such information by removing HNullCheck as inputs. So it's the responsability of whoever does this optimization to preserve that info (so prepare_for_register_allocation.cc).

Also recognizing a.f().... if (a instanceof A) is a general type propagation optimization that is sort of out of the scope of what Guillaume is doing. You'd still want to have all optimizations prior to code generation be able to do if (my_input->CanBeNull()) and have the optimized answer.

93:0-97:7
Wed Apr 22 14:02:59 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b0718a1d_a838734e
UUID: 90972654_ec960b93
Bytes: 200
You convinced me when saying that whoever removes the nodes is responsible for preserving the info.

As for the a.f()... if (a instanceof A): yeap, that's a different propagation that we need to make.

152:0-156:7
Wed Apr 22 13:14:41 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b0718a1d_280643a4
Bytes: 5
ditto

