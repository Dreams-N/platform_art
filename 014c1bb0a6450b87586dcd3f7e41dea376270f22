Revision: 014c1bb0a6450b87586dcd3f7e41dea376270f22
Patch-set: 4
File: test/800-smali/smali/catch_handler_on_entry.smali

23:7-23:25
Thu Jan 22 17:58:05 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4bd16f3e_55d9ac83
Bytes: 857
I don't think this exposes the problem. This was only so I had something that throws an exception to check what the verifier is doing.

What you'd have to do here is a call. Then we'd have a call-stack of

   catchHandlerOnEntry
 ->something-called

Now assume deopt hits, so we have two deopted shadow frames:

 ->Shadow(something-called)->Shadow(catchHandlerOnEntry)

Further assume something-called now throws an exception (it's likely easiest to have something-called in a different class that is not written in smali for this). *Now* the entry check becomes interesting, because it's EnterInterpreterFromDeopt that handles the queue of shadow frames - and I believe we will fail the check.

My problem was that I don't know how to force deopt, and my code was only meant to show that it passes the verifier. I guess some VMDebug function could be used?

23:7-23:25
Thu Jan 22 18:16:56 2015 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4bd16f3e_55d9ac83
UUID: 4b8a4f30_b06616c3
Bytes: 1282
No I don't thing we fail the check if there is no move-exception. In EnterInterpreterFromDeopt, we'll see an exception is pending so we'll find a catch handler. Now 2 possibilities:
- We don't find a catch handler in the current method: we don't enter interpreter and pop the frame. Then we continue with the "caller" deoptimized frame.
- Or we find a catch handler in the current method. If it doesn't start with a move-exception, we clear the exception  (FindNextInstructionFollowingException) before entering the interpreter with the deoptimized frame at the DEX pc of the catch handler found.
In both cases, we never enter the interpreter from a deoptimized frame with a pending exception (if the method does not start with a move-exception a DEX pc 0x0).


I created a JDWP test for that in https://android-review.googlesource.com/123850 (look at the DeoptimizationWithExceptionHandlingDebuggee class). It causes a deopt when hitting the breakpoint of the last method in the file. Then we throw a NullPointerException while interpreting a deoptimized frame. It is then caught by the caller which also runs with a deoptimized frame.


We should be able to trigger deoptimization by starting method tracing (it switches everything to interpreter) with VMDebug.startMethodTracing.

23:7-23:25
Thu Jan 22 18:31:49 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4b8a4f30_b06616c3
UUID: 4bd16f3e_9584e4ea
Bytes: 543
You are right about the clearing (though the test is still not testing what we want...)

However, I took a look at the verifier and how it handles MOVE_EXCEPTION. It seems we are simply scanning the handlers that start at that PC and accept the exception types for the registered handlers. We don't check anywhere whether the exception register will actually contain something (whether we reach the block from an exception "jump"), which is odd to me, to say the least.

As usual, the dex spec isn't helpful, because it doesn't cover the case.

23:7-23:25
Thu Jan 22 18:37:19 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4bd16f3e_9584e4ea
UUID: 2bcefba3_54c9ac35
Bytes: 134
I confirmed that a move-exception is valid as pc 0, this passes the verifier, and the test runs. We'll really have to extend the test.

