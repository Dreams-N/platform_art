Revision: eaf23af99b3af0922526b283956e04142d965654
Patch-set: 2
File: runtime/arch/mips/quick_entrypoints_mips.S

1345:0-1349:23
Wed Dec 09 19:58:15 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 251f3657_34b0f0b3
Bytes: 45
Does mips provide the same guarantees as arm?

1345:0-1349:23
Thu Dec 10 02:08:28 2015 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 251f3657_34b0f0b3
UUID: 454eea83_ee4bb3aa
Bytes: 746
Looking back at the MIPS memory model document, and prior discussions with David Lau, the answer remains unclear to me.  I'm not sure whether dependencies enforce visibility ordering.  What does "uniprocessor data dependencies are maintained" mean?  Does it just mean that a single thread executes correctly.  Or does it mean that if there is an address dependency from load a to load b, then a is visible to other cores before b?

We need the latter, at least in some cases, for Java code with final fields to execute correctly at better than glacial speed.  We need a very strong version of the latter property for this to work correctly.

I previously suggested an in-person meeting to resolve this and related issues.  I'm still open to that.

1345:0-1349:23
Thu Dec 10 02:18:46 2015 +0000
Author: Alexey Frunze <1057043@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 454eea83_ee4bb3aa
UUID: a567a60d_21bf74ce
Bytes: 386
My understanding (indicated in an internal review of this patch) is that we likely need SYNC here (just as we have one at the end of this routine). Clearly, the XOR/ADDU won't have any reliable effect on memory accesses or ordering. However, I don't know the perf impact of inserting SYNC here. But above all, we need to remain correct, fast alone is worhtless if the code is incorrect.

1345:0-1349:23
Thu Dec 10 05:40:40 2015 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a567a60d_21bf74ce
UUID: 6553ee27_f51ee249
Bytes: 483
This really needs to get straightened out for more basic reasons.  If data dependencies like this are never guaranteed to enforce ordering, then there is no guarantee that reading a Java reference field, and the using that to access a final field ensures ordering of those two loads.  Those are required to be ordered by the Java language specification.  If we have to insert SYNCs there, I suspect the performance impact would be disastrous.

We really need to understand the rules.

1345:0-1349:23
Fri Dec 11 02:13:48 2015 +0000
Author: Raghu Gandham <1064548@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6553ee27_f51ee249
UUID: 05487277_cc3fdeaf
Bytes: 551
The two instructions xor and addu ensure that loading of status is visible before flags. Infact addu $t0, $t0, $zero is sufficient to create the dependency. This is the most efficient way of ensuring that status gets loaded before flags and size.

Alternatively SYNC(19)/SYNC_RMB could also be used. The architecture defines this as optional but is implemented on all latest processors IMG releases. On processors where SYNC(19) is not implemented, SYNC gets used in its place. However using SYNC/SYNC(19) is less efficient than creating a dependency.

1345:0-1349:23
Fri Dec 11 14:23:35 2015 +0000
Author: Pavle Batuta <1080239@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 05487277_cc3fdeaf
UUID: a5f24653_8371c07c
Bytes: 72
Added addu  $t0, $t0, $zero; this should create the required dependency.

1358:4-1358:7
Wed Dec 09 19:58:15 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4520aa91_d5809cb1
Bytes: 182
Is "GE" unsigned comparison? Or are we guaranteed to never allocate across the 0x80000000 boundary?
(I think "EQ" would work just as well, top offset should never exceed end offset.)

1358:4-1358:7
Thu Dec 10 21:44:09 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4520aa91_d5809cb1
UUID: 253496db_41c9802c
Bytes: 31
+1 for using unsigned GE or EQ.

1358:4-1358:7
Fri Dec 11 14:23:35 2015 +0000
Author: Pavle Batuta <1080239@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 253496db_41c9802c
UUID: c5701ac6_39a1efc9
Bytes: 4
Done

1363:4-1363:7
Wed Dec 09 19:58:15 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2506560b_fc99493a
Bytes: 68
Signed or unsigned? (Though I wouldn't expect a 2GiB instance size.)

1363:4-1363:7
Thu Dec 10 21:44:09 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2506560b_fc99493a
UUID: e55fde25_91157b1d
Bytes: 22
+1 for using unsigned.

1363:4-1363:7
Fri Dec 11 14:23:35 2015 +0000
Author: Pavle Batuta <1080239@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e55fde25_91157b1d
UUID: 0576b2c5_73c8e0ca
Bytes: 4
Done

1366:54-1366:63
Wed Dec 09 19:58:15 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c03648c7_29632d21
Bytes: 76
I recently learned that this is an obsolete form, the correct is "subtract."

1366:54-1366:63
Fri Dec 11 14:23:35 2015 +0000
Author: Pavle Batuta <1080239@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c03648c7_29632d21
UUID: c03648c7_2ce6dbd7
Bytes: 4
Done

1386:0-1389:88
Wed Dec 09 19:58:15 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 65fcce2b_7ecf7135
Bytes: 94
This store should be before the comment. The comment belongs to the assertion and store below.

1386:0-1389:88
Thu Dec 10 21:44:09 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 65fcce2b_7ecf7135
UUID: 855c6237_618fda14
Bytes: 2
+1

1386:0-1389:88
Fri Dec 11 14:23:35 2015 +0000
Author: Pavle Batuta <1080239@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 855c6237_618fda14
UUID: 45c18a18_4d73d9f3
Bytes: 4
Done

