Revision: fe8a1d4e5b4683529583ee01ae67a34c053b6173
Patch-set: 2
File: compiler/optimizing/intrinsics_arm64.cc

292:0-293:71
Fri Jan 29 11:03:45 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b140d043_50182cc4
Bytes: 280
It's a matter of personal taste, but I'd use the RegisterFrom helper here, as we do in compiler/optimizing/code_generator_arm64.cc:

  Register op1_reg = RegisterFrom(op1, type);
  Register op2_reg = RegisterFrom(op2, type);

(and pass `type` instead of `is_long` to this method).

292:0-293:71
Fri Jan 29 18:04:43 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b140d043_50182cc4
UUID: 5422228b_abc46d6b
Bytes: 143
I agree, I like such utils better too (but for now I just complied with the surrounding style). Perhaps I clean this up with my latter efforts.

296
Fri Jan 29 12:05:57 2016 +0000
Author: Alexandre Rames <1052304@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f1116843_5a7955a3
Bytes: 312
Three instructions are necessary, but we can spare one conditional instruction by using an arithmetic shift.

__ Sub(out, op1, op2, SetFlags);
__ Asr(out, out, op1.size() - 1);
// At this point `out` contains:
//   * -1 if op1 < op2
//   * 0 otherwise
// Now fix the result when op1 > op2.
__ Cinc(out, out, gt);

296
Fri Jan 29 12:17:50 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f1116843_5a7955a3
UUID: 112fdc8d_6b8ea11e
Bytes: 100
This doesn't work due to arithmetic overflows: INT_MIN < INT_MAX but (INT_MIN - INT_MAX) >> 31 == 0.

296
Fri Jan 29 13:15:32 2016 +0000
Author: Alexandre Rames <1052304@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 112fdc8d_6b8ea11e
UUID: 71fc982b_de1fa548
Bytes: 240
You are right it would only work for unsigned arithmetic.

Then would this sequence be clearer?

    __ Cmp();
    __ Cset(out, ne);      // If not equal, the result is -1 or +1.
    __ Cneg(out, out, lt); // Negate +1 to -1 when op1 < op2.

296
Fri Jan 29 13:26:14 2016 +0000
Author: Alexandre Rames <1052304@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 71fc982b_de1fa548
UUID: f1116843_9a8ecde4
Bytes: 117
Not even sure it would work for unsigned arithmetic. I need to double check all this. Anyway it does not matter here.

296
Fri Jan 29 13:46:45 2016 +0000
Author: Alexandre Rames <1052304@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f1116843_9a8ecde4
UUID: 71fc982b_9e191d65
Bytes: 148
And it does not: 0xFFFFFFFF, 0x1.
I think it can work if we restrict the input ranges. Maybe this staid in our mind from v8's smis (31bit integers).

296
Fri Jan 29 14:36:36 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 71fc982b_9e191d65
UUID: 7153b827_26ac565d
Bytes: 598
The CMP+CSET/NE+CNEG/LT should be just as good as the CMP+CSET/GT+CINV/LT. Both work perfectly for the signed comparison. (If we wanted an unsigned compare, we would have to replace LT->LO, GT->HI, but I cannot see why we would ever need that.)

And the CMP+CSET/NE+CNEG/LT approach is exactly what I would want for Thumb2:

    cmp op1, op2
    ite eq
    moveq out, #0       // 16-bit if out is low reg.
    movne out, #1       // 16-bit if out is low reg.
    it lt
    rsblt out, out, #0  // 16-bit if out is low reg.

(mov out, #-1 would be 32-bit) so maybe we should use that for consistency.

296
Fri Jan 29 18:04:43 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7153b827_26ac565d
UUID: d468d2a0_420bc8b0
Bytes: 63
So, what's the verdict. Should I change, or it this good to go?

296
Fri Jan 29 18:15:16 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d468d2a0_420bc8b0
UUID: 7153b827_6675ae62
Bytes: 321
Your choice.

There's actually also a Thumb2 approach similar to CMP+CSET/GT+CINV/LT:

    cmp op1, op2
    ite le
    movle out, #0       // 16-bit if out is low reg.
    movgt out, #1       // 16-bit if out is low reg.
    it lt
    sublt out, out, #1  // 16-bit if out is low reg.

(With 0-1 being used instead of ~0.)

297:18-297:28
Fri Jan 29 11:03:45 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d139c4d1_712578ec
Bytes: 23
Nit: extra white space.

297:18-297:28
Fri Jan 29 18:04:43 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d139c4d1_712578ec
UUID: 5422228b_ab9d4d7f
Bytes: 74
Ah, I liked to line up the conditions, but it is again style yes. Removed.

