Revision: 3049b2a54b5b55d094fea603236f492c31b842e1
Base-for-patch-set: 4
File: runtime/native/java_lang_reflect_Method.cc

33
Fri Aug 19 17:35:57 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e8f9973d_11029c14
Bytes: 63
Where did these go to? Shouldn't they be moved into Executable?

33
Fri Aug 19 17:46:33 2016 +0000
Author: Neil Fuller <1038039@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e8f9973d_11029c14
UUID: a846bf69_232a0a7c
Bytes: 602
They went to AbstractMethod because they were (near) identical.

The only other one I think it may be possible to move was getExceptionTypes but the implementation is sufficiently different with the one in Constructor that I didn't want to try. Figured the differences were for a good reason.

I've kept all the ART-related code in AbstractMethod for now because not everything on AbstractMethod could be moved to Executable (since the API of Executable is public), and it made sense to me to keep all the native ART / Android knowledge together.

I think it could move up in this case if we wanted to.

33
Fri Aug 19 18:39:30 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a846bf69_232a0a7c
UUID: e8f9973d_ac94abdb
Bytes: 741
It's very confusing now where the actual code lives.

Just looking at the APIs all the real inherited logic should come from Executable (if not on the original class that had it).

The next person to come look at this will have to dig through a lot of java code in libcore and understand its intricacies of why everything was moved to AbstractMethod.

--------
I have no comment regarding the structure of the java code but it would be really good if the JNI code wasn't all just in AbstractMethod.cc .

If putting it into java_lang_reflect_Executable doesn't make sense (since it doesn't really have native functions! and you can't have default natives in Java), what if we put it into the AnnotatedElements equivalent cc file (or similar)?

33
Fri Aug 19 18:40:26 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e8f9973d_ac94abdb
UUID: e8f9973d_ec4cf3a1
Bytes: 181
Just to be perfectly clear this is a statement regarding the location of the native code only. I.e. I was confused where the native implementations of the annotations actually were.

33
Mon Aug 22 10:58:41 2016 +0000
Author: Neil Fuller <1038039@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e8f9973d_ec4cf3a1
UUID: a846bf69_c351f6dd
Bytes: 1924
Before my change here we had the base class, AbstractMethod, with some of the native code and some other, related, native code on the subclasses Method / Constructor (with near-identical implementations).

i.e. things like getSignatureAnnotation(), getDeclaredAnnotations(), isAnnotationPresentNative() were already implemented in AbstractMethod (after d890de26ec16f7fc32b58a00725aff1b2a79a169). 

getDeclaredAnnotations() was present in AbstractMethod and overridden for Constructor only, which was a bit strange.

I think now the native code associated with annotations all lives on AbstractMethod, with less duplication, so I think this is a step forward. With my change, the only native code left on Method / Constructor appears to be related to their inherent behavior differences. The only one I'm not 100% sure of (i.e. it logically "smells" like it could be moved to AbstractMethod) is native getExceptionTypes(). The actual code appears to be different, though. One for the runtime team who understand this, perhaps.

What I think *could* ultimately happen is that AbstractMethod and Executable should be collapsed. We can do so only if we keep the Executable public API as it is. To do so we'd need to rely on package-protected methods to provide the native methods that couldn't be protected/public. That would probably allow us to remove the AbstractMethod, but would require reasonably heavy customization of Executable to introduce the fields / code from AbstractMethod.

If I do that, I would like to do it as a follow up because it's likely to involve some discussion / bike shedding and shouldn't hold up this change. The motivation here is to introduce Executable and arrange the code more closely to upstream structure to ease the rest of the upstream pull and so I can unblock the Parameter integration. It would come after the rest of the OpenJDK pull as it should have no impact on published APIs, etc.

