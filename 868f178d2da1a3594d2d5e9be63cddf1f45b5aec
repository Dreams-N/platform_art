Revision: 868f178d2da1a3594d2d5e9be63cddf1f45b5aec
Patch-set: 12
File: cmdline/cmdline_parser_test.cc

108:4-108:8
Wed Jun 17 16:47:37 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 397f484e_957354c5
Bytes: 21
Isn't that a T or T*?

108:4-108:8
Wed Jun 17 18:21:30 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 397f484e_957354c5
UUID: 39b10858_0009f034
Bytes: 111
Not necessarily, it can be something convertible to T (typically signed/unsigned mismatch or widening numerics)

108:4-108:8
Wed Jun 17 18:27:21 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 39b10858_0009f034
UUID: 39b10858_2037d4ec
Bytes: 528
Although looking at the existing test cases ...

UsuallyEquals (the one where the types matter) is implemented for the same type for all overloads except string+char*. 

So while there aren't any 'expected default key value' that check strings against const char*s now, there could be in the future.

And the 'expected (non-default) key-value' definitely make use of this, because I just put in a c-string as the expected to compare against an std::string value.
------
So I guess I can just specify the type explicitly for now.

109:4-109:5
Wed Jun 17 16:47:37 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 79bf0033_f77bc871
Bytes: 16
Why the nesting?

109:4-109:5
Wed Jun 17 18:21:30 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 79bf0033_f77bc871
UUID: b99c18d9_aaf27610
Bytes: 9
No reason

540:2-540:3
Wed Jun 17 16:47:37 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 79bf0033_3796001d
Bytes: 56
Could you put the start/end braces in the macro instead?

540:2-540:3
Wed Jun 17 18:21:30 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 79bf0033_3796001d
UUID: 19b8c43c_97ec0306
Bytes: 127
Ok, I'll get rid of the {}s here. The other tests introduced the same local variable over and over again so they needed the {}.

