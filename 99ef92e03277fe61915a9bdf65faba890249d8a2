Revision: 99ef92e03277fe61915a9bdf65faba890249d8a2
Patch-set: 2
File: compiler/driver/compiler_driver.cc

1896:9-1896:41
Wed Jun 18 01:07:48 2014 +0000
Author: Dong-Yuan Chen <1000428@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 64d659dd_17c2bc3b
Bytes: 277
How do we know at compile time whether a method needs native bridge? The information is not available from the DEX file and can only be known when one tries to load a native library at runtime. From the DEX file, we know a method is native but don't know it uses a foreign ISA.

1896:9-1896:41
Wed Jun 18 01:38:21 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 64d659dd_17c2bc3b
UUID: 64d659dd_578844a3
Bytes: 613
Good question and something to think about. What should happen now (but I think is not completely implemented), is that the compiled code is thrown away (the entrypoint can be overwritten). In the end, the previous PS was doing a similar thing by hijacking the jni entrypoint.

BTW, I am not sure how your implementation would work with the JNI compiler, either. I did not see any code that changed the signature of a call from the quick method to the native bridge one. Your system kind of worked because of the x86 calling convention placing everything on the stack, but for x86-64 this would have never worked.

1896:9-1896:41
Wed Jun 18 19:27:43 2014 +0000
Author: Dong-Yuan Chen <1000428@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 64d659dd_578844a3
UUID: 4466b513_e1dadca5
Bytes: 855
In PS1, all method invocations to foreign JNI methods go through a native bridge wrapper set in entry_point_from_jni_ in ArtMethod. The original fnptr to the foreign JNI method is stored in the newly added field entry_point_from_native_bridge_ in ArtMethod. The native bridge wrapper function is set in RegisterNativeMethods at runtime. See line 2511 of jni_internal.cc in PS1.

The native bridge wrapper function will interpret the calling convention properly based on the native function shorty and the ISA (x86 vs. x86-64.) It encapsulates the handling of calling convention differences inside the wrapper so it is transparent to ART.

Having all native bridge JNI calls go thru generic JNI gives up the benefit of optimized code sequence from JNI compiler. It will be better to be able to leverage the JNI compiler for native bridge JNI calls as well.

1896:9-1896:41
Wed Jun 18 21:36:49 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4466b513_e1dadca5
UUID: a4cbf13b_d11204e7
Bytes: 476
But your strategy *only* works on x86. On other architectures you do not have the leisure of having all arguments on the stack so that you can easily retrieve the args array. You cannot call an arbitrary native function from a JNI call - the signature has to match.

So the proper approach for you would have been to override the signature of the Java method. But then you cannot use the JNI compiler, either, because it won't give you the right things.

Do you see the issue?

File: runtime/mirror/art_method.h

138:4-138:91
Wed Jun 18 01:38:21 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 04975d03_d8d23504
Bytes: 111
Here is where we should throw away the existing entrypoint, and unconditionally set the generic JNI entrypoint.

