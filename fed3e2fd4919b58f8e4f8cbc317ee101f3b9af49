Revision: fed3e2fd4919b58f8e4f8cbc317ee101f3b9af49
Patch-set: 1
File: runtime/gc/collector/concurrent_copying.cc

1652:18-1652:61
Thu Oct 22 05:13:29 2015 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 99784a71_8a4b3bee
Bytes: 273
I don't immediately understand why this is safe.  Doesn't another thread subsequently reading this field expect the copied object to be initialized?  How is the copied data made visible to the other thread?  I would have expected release semantics here, and probably below.

1652:18-1652:61
Thu Oct 22 16:26:20 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 99784a71_8a4b3bee
UUID: 19337ad8_e44e96aa
Bytes: 158
Maybe it would be OK if we put a fence at the end of object scanning? Every read goes through slow path until we set the read barrier flag from grey -> white.

1652:18-1652:61
Thu Oct 22 18:07:04 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 19337ad8_e44e96aa
UUID: 56a1415d_fcd92955
Bytes: 417
I think this is okay.

We update each field of an object with a relaxed CAS (what we do in this function) and then use a release CAS (see object-inl.h) to switch the object from gray to black/white.

This release CAS will make the updated fields visible. If a mutator sees a stale field value before this release CAS, it will take the read barrier slow path and get the correct value (since the object is still gray.)

File: runtime/mirror/object-inl.h

187:12-187:34
Thu Oct 22 18:07:04 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 19337ad8_e46f7629
Bytes: 24
This is the release CAS.

File: runtime/read_barrier-inl.h

66:13-66:67
Thu Oct 22 05:13:29 2015 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 194a9a42_41803c3b
Bytes: 89
Similar concerns here.  But I didn't have time to read the related code carefully enough.

