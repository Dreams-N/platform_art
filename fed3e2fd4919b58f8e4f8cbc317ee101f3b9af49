Revision: fed3e2fd4919b58f8e4f8cbc317ee101f3b9af49
Patch-set: 1
File: runtime/gc/collector/concurrent_copying.cc

1652:18-1652:61
Thu Oct 22 05:13:29 2015 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 99784a71_8a4b3bee
Bytes: 273
I don't immediately understand why this is safe.  Doesn't another thread subsequently reading this field expect the copied object to be initialized?  How is the copied data made visible to the other thread?  I would have expected release semantics here, and probably below.

1652:18-1652:61
Thu Oct 22 16:26:20 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 99784a71_8a4b3bee
UUID: 19337ad8_e44e96aa
Bytes: 158
Maybe it would be OK if we put a fence at the end of object scanning? Every read goes through slow path until we set the read barrier flag from grey -> white.

File: runtime/read_barrier-inl.h

66:13-66:67
Thu Oct 22 05:13:29 2015 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 194a9a42_41803c3b
Bytes: 89
Similar concerns here.  But I didn't have time to read the related code carefully enough.

