Revision: 74eb1b264691c4eb399d0858015a7fc13c476ac6
Patch-set: 32
File: compiler/optimizing/prepare_for_register_allocation.cc

140:1-150:3
Fri Jan 29 11:49:35 2016 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 349a0eef_a5f2e400
Bytes: 510
I thought about this some more.  This check will cause  selects with a long compare to be quite inefficient on x86, as the comparison will have to be materialized.

In addition, there is no easy way that I know to generate a single condition code representing a long comparison on X86, which is needed to control CMOV.

I am planning to move this check to the HSelect generation, and avoid HSelect on x86 if the comparison is between longs.  That is sufficient to remove this check and generate efficient code.

140:1-150:3
Fri Jan 29 11:55:45 2016 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 349a0eef_a5f2e400
UUID: d468d2a0_ff18f705
Bytes: 169
Okay, you will generate a single CC by comparing the materialized compare result with 0, but it is still slow, and undoes the work to merge the long compare with the HIf

140:1-150:3
Fri Jan 29 12:44:45 2016 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d468d2a0_ff18f705
UUID: 7153b827_a664c623
Bytes: 893
Yep, I agree that this is not very efficient - the point was to get Selects in already and find a better solution later, so feel free to tweak this.

That said, we typically try to avoid platform-specific code in the HIR optimizations and assume that codegens can always generate the code they want from the HIR. Now I know that I've already broken that by forcing input0 of the Select to be the false value, but would be a shame to spread such assumptions further.

The "right" way of doing this would be to investigate how the register allocator could spill the true value (input1) of the Select. What happens in the highlighted case here is that the Select has effectively 4 inputs - val_false, val_true, cond_lhs, cond_rhs. We set out=val_false=needs_reg_pair, cond_lhs=needs_reg_pair, cond_rhs=needs_reg_pair. If we could set val_true=needs_double_stack, then we'd have no problem at all.

140:1-150:3
Fri Jan 29 13:14:00 2016 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7153b827_a664c623
UUID: 14950abd_019e2e48
Bytes: 626
I disagree.  Even if we allowed an input to be forced to the  stack, the x86 long compare would still need to materialize -1/0/1, which will then be compared to 0 to set the CC in order to implement the select.  This is VERY inefficient.  The same applies if the compare was FP.

What I would really prefer is a virtual function in CodeGenerator called ShouldGenerateSelect, which is passed in all 4 inputs (or just the types of the compare and moves), and returns a boolean.  That allows the code generator to proactively decide before getting into trouble later.  Last time I suggested something like that, it was shot down.

140:1-150:3
Fri Jan 29 13:49:27 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 14950abd_019e2e48
UUID: 9143cc4f_ef950104
Bytes: 218
Or we could have the HCondition generate the CC, HSelect use the CC and modify the parallel move resolver to not touch the CC.

When does the parallel move resolver touch the CC? Is it just for loading a zero with XOR?

140:1-150:3
Fri Jan 29 13:54:42 2016 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 9143cc4f_ef950104
UUID: 5422228b_082f4762
Bytes: 140
I see some subl/addl that could become lea for stack manipulation, the xorl for 0, a xorpd for 0.0, and xorls to do an exchange of registers

