Revision: bcf90a8207bf7198cc1b70a021d7b18fe8aa347a
Patch-set: 9
File: compiler/optimizing/induction_var_analysis.cc

48
Thu Sep 03 18:32:59 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e486eed4_efcde0bc
Bytes: 273
minor: you were also mentioning wanting to support smaller types like bytes and short yesterday (offline)

Not sure if we care enough since most arithmetic is done on int/long followed by a truncation to a smaller type (does this induction analysis support truncation yet?)

48
Thu Sep 03 20:29:13 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e486eed4_efcde0bc
UUID: 8497f201_20a9905e
Bytes: 297
This is one of those "as needed" things on my own wishlist. I have written induction variable recognizer that also dealt with narrowing and widening type conversions (provided one can prove that it remains within the valid range).

But that seems a lot of work for very little gains at the moment.

381
Thu Sep 03 18:32:59 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 644d9e85_8202cb47
Bytes: 101
minor: Would be great to have some comments here on what is 0 and 31 and why it's <31 instead of <=31

381
Thu Sep 03 20:29:13 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 644d9e85_8202cb47
UUID: e486eed4_cf6fbbc5
Bytes: 17
L379? not enough?

383
Thu Sep 03 18:32:59 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 240f267a_e69d60d0
Bytes: 7
see 381

383
Thu Sep 03 20:29:13 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 240f267a_e69d60d0
UUID: 8497f201_e0b2c8c9
Bytes: 4
same

