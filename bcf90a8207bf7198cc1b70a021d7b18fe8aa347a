Revision: bcf90a8207bf7198cc1b70a021d7b18fe8aa347a
Patch-set: 9
File: compiler/optimizing/induction_var_analysis.cc

48
Thu Sep 03 18:32:59 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e486eed4_efcde0bc
Bytes: 273
minor: you were also mentioning wanting to support smaller types like bytes and short yesterday (offline)

Not sure if we care enough since most arithmetic is done on int/long followed by a truncation to a smaller type (does this induction analysis support truncation yet?)

48
Thu Sep 03 20:29:13 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e486eed4_efcde0bc
UUID: 8497f201_20a9905e
Bytes: 297
This is one of those "as needed" things on my own wishlist. I have written induction variable recognizer that also dealt with narrowing and widening type conversions (provided one can prove that it remains within the valid range).

But that seems a lot of work for very little gains at the moment.

381
Thu Sep 03 18:32:59 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 644d9e85_8202cb47
Bytes: 101
minor: Would be great to have some comments here on what is 0 and 31 and why it's <31 instead of <=31

381
Thu Sep 03 20:29:13 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 644d9e85_8202cb47
UUID: e486eed4_cf6fbbc5
Bytes: 17
L379? not enough?

381
Thu Sep 03 21:01:40 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e486eed4_cf6fbbc5
UUID: 6492fe15_7f1742dd
Bytes: 613
Well that sort of explains why it's <31 and not <=31 but only because you already explained that to me offline. It might just need to be a bit more explicit.

For example a slightly more verbose explanation would be more enlightening:

   // The restriction on the shift factor (using the range [0,31) instead of [0,31]) 
   // is to avoid generating a negative constant (i.e. x << 31 is the same as x * negative_value).

And it also doesn't address why it's 0 and 31 and not 12345 and 78910.

   // Don't handle any values outside of [0,31) because they are unlikely
   // to occur as a constant in typical code.

383
Thu Sep 03 18:32:59 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 240f267a_e69d60d0
Bytes: 7
see 381

383
Thu Sep 03 20:29:13 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 240f267a_e69d60d0
UUID: 8497f201_e0b2c8c9
Bytes: 4
same

