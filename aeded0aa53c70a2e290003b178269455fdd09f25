Revision: aeded0aa53c70a2e290003b178269455fdd09f25
Patch-set: 3
File: runtime/gc/allocator/rosalloc.cc

2111:9-2111:27
Wed Jul 09 01:31:52 2014 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e474097d_d4a5d5a8
Bytes: 676
Technically, this is wrong, since page_map_[i] can presumably be concurrently modified?  Memory barriers don't change that.  An atomic<bool> (or perhaps Atomic<t> for now) shouldn't be any bigger than a bool, so there shouldn't be a fundamental reason not to use it.

This doesn't quite look like double-checked locking.  As far as I can tell, nothing bad happens if this erroneously reads a wrong value outside the critical section.  I suspect there's not a real memory ordering issue here, and a memory_order_relaxed load should be OK. 

As a practical matter, since there doesn't seem to be an ordering issue, this is also extremely likely to work if page_map_ is volatile.

2111:9-2111:27
Wed Jul 09 22:42:32 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e474097d_d4a5d5a8
UUID: b9015cf5_55cfec95
Bytes: 462
Thanks, Hans.

I think that as long as we are okay with missing an opportunity to release pages occasionally (leaving an just-freed page as kPageMapEmpty rather than kPageMapReleased), it is fine.

As I understand, in the 'lazy initialization or singleton' pattern (a common example of double-checked locking), the equivalent of missing an opportunity to release pages occasionally would correspond to returning an not-yet-fully-initialized object, which is bad.

2111
Wed Jul 09 23:30:25 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b9015cf5_55cfec95
UUID: 995e582a_6d2111bd
Bytes: 51
The race here should be benign. I'll add a comment.

2157:4-2157:34
Wed Jul 09 01:31:52 2014 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e474097d_34cc496b
Bytes: 152
Can we do this when we resurrect the page instead?  Memset may bring this into the cache, which would be bad here, and might be useful at the other end.

2157
Wed Jul 09 23:30:25 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e474097d_34cc496b
UUID: d9045004_961b3c65
Bytes: 72
I'll add TODO: I think only the mac build has that madvise doesn't zero.

2166:8-2166:43
Wed Jul 09 01:31:52 2014 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e474097d_14c74d4b
Bytes: 68
Can this ever be false?  Is it safe to do the madvise if it's false?

2166:8-2166:43
Wed Jul 09 22:42:32 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e474097d_14c74d4b
UUID: f9f75445_925eaa24
Bytes: 147
This is safe as the case where it can be false is when it's already kPageMapReleased. The other cases are caught by the DHECK in the previous line.

2166
Wed Jul 09 23:30:25 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f9f75445_925eaa24
UUID: d9045004_5625b496
Bytes: 8
Correct.

