Revision: bd824548c571a9fc51ee0bf1b6fe3c38742163a8
Patch-set: 4
File: /COMMIT_MSG

15:0-15:74
Tue Jul 07 12:25:09 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f8f4ce42_ff95bf47
Bytes: 15
Nit: long line.

File: compiler/dex/quick/dex_file_method_inliner.cc

591:6-591:19
Tue Jul 07 12:25:09 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1840c241_f095e047
Bytes: 60
Maybe document that Quick does not implement this intrinsic?

File: compiler/optimizing/intrinsics_arm.cc

865
Tue Jul 07 12:25:09 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f8f4ce42_1f8aa321
Bytes: 38
Nit: end comment-sentences with a "."?

865:0-870:51
Tue Jul 07 11:37:03 2015 +0000
Author: Vladimir Marko <1033066@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d8fb8a32_feab815e
Bytes: 98
Too many temps may cause unnecessary spills, this can be done easily with 3 temps with some reuse.

866:0-870:51
Tue Jul 07 12:25:09 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f8f4ce42_bf9f3764
Bytes: 25
Maybe use a loop instead?

872:47-872:49
Tue Jul 07 11:37:03 2015 +0000
Author: Vladimir Marko <1033066@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1840c241_903d7499
Bytes: 7
Why R0?

893:0-894:66
Tue Jul 07 12:25:09 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f8f4ce42_7f81afd7
Bytes: 172
Replace with

  uint32_t count_offset = mirror::String::CountOffset().Int32Value();
  uint32_t value_offset = mirror::String::ValueOffset().Int32Value();

and adjust users?

897:0-900:17
Tue Jul 07 12:25:09 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1840c241_70ed7087
Bytes: 439
This pattern occurs several times in this code.  Instead of using `it`, what about factoring the loads like this:

  Label return_false;

  // ...

  // Check if input is null, return false if so.
  __ cmp(argument, ShifterOperand(0));
  __ b(&return_false, EQ);
 
  // ...

  // (Likewise for `klass_` field comparison, String lengths comparison, etc.)

  // ...

  __ Bind(&return_false);
  __ LoadImmediate(out, 0, EQ);
  __ b(&end);

?

904:5-904:13
Tue Jul 07 12:25:09 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1840c241_50902c51
Bytes: 8
Receiver

905:74-905:82
Tue Jul 07 12:25:09 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f8f4ce42_ff7edf8d
Bytes: 6
Ditto.

906:2-906:33
Tue Jul 07 11:37:03 2015 +0000
Author: Vladimir Marko <1033066@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f8f4ce42_3f7b2772
Bytes: 155
Is there an explicit null check for the invoke? It could be an implicit check on this LDR but it needs to be moved before the "argument==null" check above.

907:19-907:36
Tue Jul 07 11:37:03 2015 +0000
Author: Vladimir Marko <1033066@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 18f28255_c050de56
Bytes: 53
Don't use implicit class_offset==0, make it explicit.

906:0-907:37
Tue Jul 07 12:25:09 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 18f28255_a074baf4
Bytes: 339
You're loading the `klass_` fields, right?  If so, this should be more explicit IMO (even if `class_offset` is known to be zero):

  __ ldr(temp_str, Address(str, class_offset));
  __ ldr(temp_arg, Address(arg, class_offset));


with `class_offset` defined earlier as:

  uint32_t class_offset = mirror::Object::ClassOffset().Int32Value();

914:5-914:9
Tue Jul 07 11:37:03 2015 +0000
Author: Vladimir Marko <1033066@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 18f28255_2062ea36
Bytes: 28
The string length is 32-bit.

923:0-926:17
Tue Jul 07 12:25:09 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f8f4ce42_ff46df24
Bytes: 174
Likewise, maybe use

  __ cmp(count_str, ShifterOperand(count_arg));
  __ b(&return_true  NE);

  // ...

  __ Bind(&return_true);
  __ LoadImmediate(out, 1);
  __ b(&end)

?

933:2-933:51
Tue Jul 07 11:37:03 2015 +0000
Author: Vladimir Marko <1033066@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1840c241_1052a4e0
Bytes: 339
Compare 2 characters at a time, please.

Thanks to value_offset%4==0, we can start comparing characters two at a time without any hassle. And thanks to kObjectAlignment%4==0 all strings with an odd length will be zero-padded, so we can use 32-bit comparison even for the last character. (Use static_assert or DCHECK for those assumptions.)

935:33-935:34
Tue Jul 07 12:25:09 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 18f28255_e3f64cce
Bytes: 17
sizeof(uint16_t)?

936:34-936:35
Tue Jul 07 12:25:09 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d829ca86_2ece6727
Bytes: 6
Ditto?

938:0-939:31
Wed Jul 08 14:56:20 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 782e1e92_6b2581b8
Bytes: 599
This is really hurting benchmarks for long strings. Either use the return_false and return_true labels as suggested by Roland, or (since you've already used SUBS instead of CMP here)  you can go really tricky: change all the "CMP ..." above to "SUBS out, ..." as well, change the exit sequence to

  // Calculate "out = (out == 0) ? 1 : 0" using RSB+ADC.
  is_zero:
    RSB temp, out, #0
    ADC out, out, temp
  // End of code.
  end:

and change all the "ITcc+MOV out, #0+Bcc end" sequences to "Bcc is_zero" or "Bcc end" as needed. Use Location::kNoOutputOverlap for "out" to avoid ugly surprises.

