Revision: b91c07a1dca31e812e66a69ce8d26bbe06c42124
Patch-set: 1
File: compiler/optimizing/register_allocator.cc

609
Tue Jan 13 14:28:44 2015 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0e6f85ad_b3d79804
Bytes: 208
For an X86, if this is a register pair, we only need to save 4 bytes for each of the registers in the pair.  Is there some way to detect this?  Or is this done automatically because the type wouldn't be long?

605:0-613:9
Tue Jan 13 14:45:29 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4ec7bdd5_258a4eae
Bytes: 290
You should do all this at the very end. So maximum_number_of_live_registers_ computation is the same.

Actually, we should just pass to codegen->ComputeFrameSize the number of live core registers, *and* the number of live FP registers. Then we wouldn't care here about size of a core/float.

605:0-613:9
Tue Jan 13 14:53:33 2015 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4ec7bdd5_258a4eae
UUID: 6ecac1df_0c02db7b
Bytes: 465
I don't understand how 'at the very end' should be done.  I just tweaked the existing code.  Where should it be done?

I can change this to maintain 2 separate variables for core & FP variables.   Is there a 'size of FP register' call?   Any thoughts on how 16 byte XMM registers vs. 8 byte doubles should be handled?  Is this supposed to handle vectors in the future, or are the live values guaranteed to be primitive types?

Please let me know what you recommend.

605:0-613:9
Tue Jan 13 14:58:26 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6ecac1df_0c02db7b
UUID: 4ec7bdd5_65260624
Bytes: 142
Yes 2 different variables, and pass the two to CodeGenerator::ComputeFrameSize.

Currently, we're only dealing with double (8 byte) on x86/64.

