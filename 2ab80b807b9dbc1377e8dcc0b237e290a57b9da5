Revision: 2ab80b807b9dbc1377e8dcc0b237e290a57b9da5
Patch-set: 9
File: compiler/optimizing/intrinsics_mips.cc

1784:63-1784:81
Thu Feb 25 12:44:00 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 22c49160_7b5637a8
Bytes: 74
This comment is not clear to me; do you mean "Multi-byte UTF-16 involved"?

1784:63-1784:81
Thu Feb 25 18:14:50 2016 +0000
Author: Chris Larsen <1071873@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 22c49160_7b5637a8
UUID: e2b0b90b_93d06719
Bytes: 503
I can improve the comment:

'The "bltu" conditional branch tests to see if the character value fits in a valid 16-bit (MIPS halfword) value. If it doesn't then the character being searched for, if it exists in the string, is encoded/stored in the string using UTF-16 into two (16-bit) halfwords. Currently the assembly code used to implement this intrinsic doesn't support searching for a character stored as two halfwords so we fallback to using the generic implementation of indexOf().'

Is this okay?

1784:63-1784:81
Fri Feb 26 15:12:44 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e2b0b90b_93d06719
UUID: 22c49160_be243d8f
Bytes: 10
Yes, SGTM.

1791:4-1798:3
Thu Feb 25 12:44:00 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 22dbb13a_11e51c20
Bytes: 56
Why is this logic here (and not in `art_quick_indexof`)?

1791:4-1798:3
Thu Feb 25 18:14:50 2016 +0000
Author: Chris Larsen <1071873@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 22dbb13a_11e51c20
UUID: a29b218c_c3df261c
Bytes: 644
I'm not sure what you're asking.

If you're asking why there isn't logic in `art_quick_indexof` to choose between "seleqz/selnez", and "movz/movn", none of these instruction appear in `art_quick_indexof`. They did appear in an earlier version of the CL but since then I've defined/used the MINu macro which conditionally selects between the R6, and pre-R6 instructions. See the file runtime/arch/mips/asm_support_mips.S.

If you are asking why doesn't `art_quick_indexof` have a test for 'fromIndex < 0'? It doesn't need to, this code prevents that condition from happening when `art_quick_indexof` is called.

Or are you asking something else?

1791:4-1798:3
Fri Feb 26 15:12:44 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a29b218c_c3df261c
UUID: 22dbb13a_772bb078
Bytes: 361
I was just wondering why this lower-bound clamping was outside `art_quick_indexof` on MIPS, whereas it is _inside_ that entrypoint on ARM (https://android.googlesource.com/platform/art/+/master/runtime/arch/arm/quick_entrypoints_arm.S#1410) and on ARM64 (https://android.googlesource.com/platform/art/+/master/runtime/arch/arm64/quick_entrypoints_arm64.S#1955).

1791:4-1798:3
Fri Feb 26 16:54:39 2016 +0000
Author: Chris Larsen <1071873@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 22dbb13a_772bb078
UUID: 82bb7df1_3eeeead8
Bytes: 285
Honestly, I don't know why it's here. I don't know if an earlier version of the ARM code put it here and I mimicked the code, or if I accidentally left it out of the assembly code and fixed it here when a bug showed up.

Should I move it so the code is consistent across architectures?

1791:4-1798:3
Fri Feb 26 18:55:22 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 82bb7df1_3eeeead8
UUID: 82affd8e_61b3ec63
Bytes: 179
Yes please.

I think we should somehow consider runtime entrypoints as an "internal API", and introducing discrepancies in implementations across architectures is error prone IMO.

1913
Thu Feb 25 12:44:00 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 82affd8e_be7b614e
Bytes: 70
Why is there no null check similar to the ones on lines 1886 and 1943?

1913
Thu Feb 25 18:14:50 2016 +0000
Author: Chris Larsen <1071873@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 82affd8e_be7b614e
UUID: 82bb7df1_3af39dc4
Bytes: 197
Because I patterned to code after the ARM implementation, and the ARM implementation of these three intrinsics follows the same pattern. I can add the test. Is this a bug in the ARM implementation?

1913
Fri Feb 26 15:12:44 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 82bb7df1_3af39dc4
UUID: 22c49160_7e5c65f5
Bytes: 114
I also noticed that discrepancy on ARM, but I didn't dig further to see it this is a bug.  I'll have a look at it.

1913
Fri Feb 26 16:54:39 2016 +0000
Author: Chris Larsen <1071873@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 22c49160_7e5c65f5
UUID: 2271f153_c7d3a2d5
Bytes: 107
I've added the check, and it will be in the next version of the CL.

Let me know if it should be taken out.

1913
Fri Feb 26 18:55:22 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2271f153_c7d3a2d5
UUID: 02c30d5c_8862e7e2
Bytes: 80
Thanks.  I'm investigating internally on whether these null checks are required.

File: runtime/arch/mips/asm_support_mips.S

133:7-133:11
Thu Feb 25 12:44:00 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a220812e_dccf01d1
Bytes: 84
What about implementing and using these `MINs` and `MINu` macros for MIPS64 as well?

133:7-133:11
Thu Feb 25 18:14:50 2016 +0000
Author: Chris Larsen <1071873@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a220812e_dccf01d1
UUID: e2def959_f2e78ccb
Bytes: 262
They can be implemented for MIPS64 but weren't because only because we're not supporting pre-R6 64-bit MIPS implementations so the MIPS64 doesn't need to use #if-#else-#endif.

Do you want these macros added to this patch or do you want them in a separate patch?

133:7-133:11
Fri Feb 26 15:12:44 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e2def959_f2e78ccb
UUID: 62b209f8_808f1c17
Bytes: 284
A separate CL is fine.

I agree that implementing these macros on MIPS64 makes less sense than on MIPS32, because we only (need to) support R6 on the former.  However, if these MINs/MINu patterns are recurring on MIPS64 (I didn't check BTW), it is still nice to factor them in macros.

133:7-133:11
Fri Feb 26 16:54:39 2016 +0000
Author: Chris Larsen <1071873@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 62b209f8_808f1c17
UUID: c2981592_9fc62111
Bytes: 42
It will be in the next version of this CL.

133:7-133:11
Fri Feb 26 18:55:22 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c2981592_9fc62111
UUID: 42c98578_85680cf4
Bytes: 6
Great!

157:2-157:26
Thu Feb 25 12:44:00 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 02c30d5c_3d0cb35c
Bytes: 123
The only difference between the definitions of `MINu` and `MINs` is this line; could you try to refactor these definitions?

157:2-157:26
Thu Feb 25 18:14:50 2016 +0000
Author: Chris Larsen <1071873@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 02c30d5c_3d0cb35c
UUID: e2b0b90b_136e9701
Bytes: 4
Done

157:2-157:26
Fri Feb 26 15:12:44 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e2b0b90b_136e9701
UUID: 62b209f8_a07340f0
Bytes: 58
> Done

I presume this is coming in a follow-up patch set?

157:2-157:26
Fri Feb 26 16:54:39 2016 +0000
Author: Chris Larsen <1071873@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 62b209f8_a07340f0
UUID: 4276e54b_74c4e079
Bytes: 42
Yes, it's already implemented, and tested.

