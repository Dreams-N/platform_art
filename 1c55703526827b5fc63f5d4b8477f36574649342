Revision: 1c55703526827b5fc63f5d4b8477f36574649342
Patch-set: 1
File: compiler/dex/quick/x86/assemble_x86.cc

328:0-331:171
Mon Jun 23 20:39:16 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e4c40963_040a40ad
Bytes: 72
This is unnecessary, use EXT_0F_ENCODING_MAP and pass REX as the prefix.

328:0-331:171
Tue Jun 24 04:08:46 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e4c40963_040a40ad
UUID: c413859f_6d94ad2d
Bytes: 24
Will do a clean-up patch

337:0-341:173
Mon Jun 23 20:39:16 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c4c1c553_bd6b632e
Bytes: 74
This is unnecessary, use EXT_0F_ENCODING_MAP and pass REX_w as the prefix.

337:0-341:173
Tue Jun 24 04:08:46 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c4c1c553_bd6b632e
UUID: e416c98e_eba5252c
Bytes: 24
Will do a clean-up patch

File: compiler/dex/quick/x86/int_x86.cc

40
Mon Jun 23 18:27:46 2014 +0000
Author: Chao-ying Fu <1010712@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c4c1c553_3724d24b
Bytes: 114
Before setting rl_result, we need to clear rl_result.  Otherwise the upper 3 bytes are invalid for usage later on.

40
Mon Jun 23 18:38:29 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c4c1c553_3724d24b
UUID: 44d5d5fe_038dd0dc
Bytes: 125
We do not plan to use the upper 3 bytes. See the code below. all arithmetic is 8 bit ending up with sign extension to 64-bit.

40
Mon Jun 23 18:44:11 2014 +0000
Author: Chao-ying Fu <1010712@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 44d5d5fe_038dd0dc
UUID: e4c40963_fe5dd5cb
Bytes: 100
Ok.  I didn't notice the 8-bit sub and sign-extension.  Hopefully, this time is good.  Thanks a lot!

43:0-43:75
Mon Jun 23 20:39:16 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e4db2937_6b7bbf02
Bytes: 40
This should be sign-extension to 32-bit.

43:0-43:75
Tue Jun 24 04:08:46 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e4db2937_6b7bbf02
UUID: c413859f_4d99f161
Bytes: 192
I do not see x86 instruction allowing us to do a sign extension from 8-bit to 32-bit and use the whole r0-r15 register set at the same time. So I decided to use 8-bit to 64-bit sign extension.

43:0-43:75
Tue Jun 24 04:22:45 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: c413859f_4d99f161
UUID: 649e596e_461a90d2
Bytes: 84
the same instruction without a REX_W prefix will do a 32-bit movsx, that is 0F BE /r

43:0-43:75
Tue Jun 24 04:48:52 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 649e596e_461a90d2
UUID: e416c98e_0b76c1ea
Bytes: 81
Yeah, it will do but it will not allow us to use registers > 4 (r9l for example).

43:0-43:75
Tue Jun 24 08:09:33 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e416c98e_0b76c1ea
UUID: 048d9d44_d7a5562c
Bytes: 357
Ugh, that looks like an instruction decode bug in movsx. A REX prefix without REX.W is generating a 64-bit result, and normalizing the byte register doesn't work :-/ movsxw and movzx at least have the decency to use a REX.W prefix. There will be a bug in the disassembler because of this, we should mask in REX.W when we see a blank REX with movsxb (0F BE).

43:0-43:75
Tue Jun 24 08:22:02 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 048d9d44_d7a5562c
UUID: e472491f_054fb27d
Bytes: 50
we'll try to look into this issue in disassembler.

File: compiler/dex/quick/x86/utility_x86.cc

611:0-613:9
Mon Jun 23 20:39:16 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e4c40963_e4daa4f3
Bytes: 23
This looks very broken.

611:0-613:9
Tue Jun 24 06:04:24 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e4c40963_e4daa4f3
UUID: 44d5d5fe_a39b44e9
Bytes: 86
And this is required due to sign extension of the constant in later add/mov operation.

611:0-613:9
Tue Jun 24 08:09:33 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 44d5d5fe_a39b44e9
UUID: 048d9d44_d7d4767b
Bytes: 300
I don't follow. If the value is 0x00 00 00 00 FF FF FF FF then val_lo is 0xFF FF FF FF (or -1) and val_hi is 0. This code will make val_hi = 1. The code below will then generate:
r_dest := 1
r_dest <<= 32
r_dest += 0xFF FF FF FF
which will lead to 0x1 FF FF FF FF in r_dest rather than 0xFF FF FF FF.

611:0-613:9
Tue Jun 24 08:22:02 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 048d9d44_d7d4767b
UUID: 6487392a_6935a5fb
Bytes: 228
No, r_dest :=1, r_dest <<= 32 and r_dest += 0x FF FF FF FF FF FF FF FF (due to sign extension of immediate for add). So it will be 0x 00 00 00 01 00 00 00 00 + 0x FF FF FF FF FF FF FF FF = 0x 00 00 00 00 FF FF FF FF as expected.

611:0-613:9
Tue Jun 24 08:53:10 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6487392a_6935a5fb
UUID: 048d9d44_b74a8a8d
Bytes: 356
Can you address this in a comment, but I'm confused as to why you are doing it this way.
If val_hi is 0 then use the B8 encoding with no REX.W prefix. If val_hi is -1 then use C7 with a REX.W prefix, so the immediate is sign-extended. For all other values use the B8 with REX.W prefix and a 64-bit immediate. You shouldn't be needing to do shifts and adds.

611:0-613:9
Tue Jun 24 09:00:55 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 048d9d44_b74a8a8d
UUID: 6487392a_8983b944
Bytes: 152
For now LIR does not support 64-bit immediate. This work is in progress. So we cannot use 64-bit immediate at this moment. This is why all these things.

611:0-613:9
Tue Jun 24 09:23:07 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6487392a_8983b944
UUID: 048d9d44_37485a92
Bytes: 124
Agreed, for the B8+REX.W and 64-immediate you'd need a new encoding kind where you'd store the 64-bit immediate over 2 ints.

611:0-613:9
Tue Jun 24 09:30:38 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 048d9d44_37485a92
UUID: 6487392a_29b00d15
Bytes: 97
Exactly, as I said this work is in progress. As soon as it is ready this code will be re-written.

618:10-618:71
Mon Jun 23 20:39:16 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e4db2937_6bbe5f54
Bytes: 65
res = LoadConstantNoClobber(...)
the top bits are implicitly zero

618:10-618:71
Tue Jun 24 04:08:46 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e4db2937_6bbe5f54
UUID: 44d5d5fe_c3d7687d
Bytes: 17
makes sense to me

620:1-622:9
Mon Jun 23 20:39:16 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e4db2937_0bfddb18
Bytes: 42
move this into the "if (val_hi != 0)" case

620:1-622:9
Tue Jun 24 04:08:46 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e4db2937_0bfddb18
UUID: c413859f_ad7d053c
Bytes: 20
together with above.

File: compiler/dex/quick/x86/x86_lir.h

714:3-714:24
Tue Jun 24 04:22:45 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 048d9d44_b48288ae
Bytes: 129
Could you tweak the comment here, an empty REX prefix used to normalize the byte operations so that they apply to R4 through R15.

714:3-714:24
Tue Jun 24 04:48:52 2014 +0000
Author: Serguei I Katkov <1040038@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 048d9d44_b48288ae
UUID: 44d5d5fe_63921cd3
Bytes: 7
will do

