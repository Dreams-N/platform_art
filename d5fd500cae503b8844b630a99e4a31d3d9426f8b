Revision: d5fd500cae503b8844b630a99e4a31d3d9426f8b
Patch-set: 3
File: compiler/optimizing/nodes.h

3327
Thu Jul 23 15:23:58 2015 +0000
Author: Alexandre Rames <1052304@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2d3aa6f6_c36ae8de
Bytes: 59
How do we handle Intel 80bit floating-point related issues?

3327
Tue Jul 28 09:47:48 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2d3aa6f6_c36ae8de
UUID: 2d862697_60fff29f
Bytes: 118
I thought all our operations in x86/x86-64 were only 32- or 64-bit; is there any place where we use 80-bit operations?

3327
Tue Jul 28 10:21:18 2015 +0000
Author: Alexandre Rames <1052304@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2d862697_60fff29f
UUID: 0d8962a8_ff0f1f6a
Bytes: 290
I meant, do we pay attention that we compile with gcc/clang flags disabling (not enabling?) 80bit float in the C++ compiled code? Otherwise the `ComputeFP` functions could operate with a higher precision than what should happen, and we could get 'wrong' results out of constant propagation.

3327
Tue Jul 28 11:08:35 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0d8962a8_ff0f1f6a
UUID: 4d7fda4c_21524e35
Bytes: 235
Oh right, I thought you were talking about the code generated by ART/dex2oat.  Thanks for pointing that out!  I'll look at the options here (using compile flags; or maybe using special instructions, such as SSE) and I'll update the CL.

3327
Tue Jul 28 16:03:39 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0d8962a8_ff0f1f6a
UUID: cd174afa_953c2481
Bytes: 341
I don't think this really matters. It seems rather unlikely that there will be code produced that doesn't use intermediates. For some reason, multiple operations would have to line up somewhere. I don't think the driver for the constant folding looks that way. (I'd contend that any inliner/unroller that produces such code is a bit insane.)

3327
Tue Jul 28 16:36:32 2015 +0000
Author: Alexandre Rames <1052304@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cd174afa_953c2481
UUID: 4d7fda4c_21fece2d
Bytes: 302
I think that is incorrect and that the issue can happen for a single operation.
If 80bit FP is enabled, the operation can happen with more precision, and when rounded back to 64bit FP the value can be different. I think we have seen this issue in real-world examples when working on the VIXL simulator.

3327
Tue Jul 28 16:40:30 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4d7fda4c_21fece2d
UUID: 2d862697_a053baeb
Bytes: 188
I'll try to come up with an example and turn it into a test.

Regarding the fix, I like the idea of using SSE intrinsics, as it is the closest to what we use in the x86 & x86-64 back ends.

3327
Tue Jul 28 16:42:07 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2d862697_a053baeb
UUID: 6d657ec3_daa8a563
Bytes: 181
This is a tricky issue when cross-compiling. The compiler must know how to evaluate the FP expression exactly as the target would evaluate it if we actually emitted the code for it.

3327
Tue Jul 28 16:47:37 2015 +0000
Author: Alexandre Rames <1052304@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6d657ec3_daa8a563
UUID: ad9936fb_9c37059c
Bytes: 145
There should be tests and code for that in the VIXL simulator that can serve as examples. I'll try to find exacly where and send you the details.

3327
Tue Jul 28 16:58:11 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4d7fda4c_21fece2d
UUID: ad1696fe_57ce0ea5
Bytes: 169
Alex: really? If things are stored into doubles, shouldn't things be correctly rounded for a *single* operation?

Mark: I added you to the bug to chime in on that... :-)

3327
Tue Jul 28 16:58:11 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6d657ec3_daa8a563
UUID: ed1c0e21_d9d1b7ca
Bytes: 135
vmarko: No, you don't need to know how the target would evaluate it. You just need to follow IEEE-754, as that is what Java mandates...

3327
Tue Jul 28 17:10:09 2015 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ed1c0e21_d9d1b7ca
UUID: ed1c0e21_19296f3a
Bytes: 192
The existing x86 compilers will use XMM instructions to compute this, which will be IEEE compliant. I can't see a modern compiler using the 80 bit FP instructions.  I am okay with it as it is.

3327
Tue Jul 28 17:27:55 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ed1c0e21_19296f3a
UUID: 4d68ba9e_9910fb11
Bytes: 401
Reading the Wiki, it seems to me that IEEE-754 compliance is not enough to guarantee the very same results. See "Expression evaluation" and "Reproducibility" at

    https://en.wikipedia.org/wiki/IEEE_floating_point#Expression_evaluation

And even if Java mandates a specific behavior, is there any guarantee for C++11 compilers? The C++ standard provides for a lot of implementation-defined behavior.

3327
Tue Jul 28 17:32:39 2015 +0000
Author: Mark P Mendell <1036869@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4d68ba9e_9910fb11
UUID: 6dae5efb_12caecc2
Bytes: 306
This is theoretically true, but in practice is probably irrelevant.  If you really want to do this portably, you should be using a software IEEE-754 implementation that does what Java wants.  Then it doesn't matter on what machine this is executed on.  I have seen this on other compilers I have worked on.

3327
Tue Jul 28 18:16:36 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6dae5efb_12caecc2
UUID: 2db8e63c_33bd72b1
Bytes: 333
A library would make all this definite. But honestly we'd have to change the interpreter then, too. Instead we may check for the compiler support. Googling gives, for example:
 http://stackoverflow.com/questions/5777484/how-to-check-if-c-compiler-uses-ieee-754-floating-point-standard
hboehm, danalbert and srhines may have opinions.

3327
Tue Jul 28 18:16:36 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4d68ba9e_9910fb11
UUID: 6dae5efb_b5d94a6f
Bytes: 491
AFAIK the JLS provides clear guidance. Expression evaluation doesn't apply here, as long as the folding takes both precedence and order specified in the JLS into account (both of which are above the ComputeFP).

I did not want to intimate that we can rely on C++11 guarantees. I just wanted to state that it doesn't matter what the target does. The target must be doing it as defined by the JLS (which is double precision, not 80b, with defined rounding mode), or we're doing things wrong...

3327
Tue Jul 28 21:10:46 2015 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6dae5efb_b5d94a6f
UUID: 4db19a56_bad9356f
Bytes: 835
As far as I can tell:

1) C and C++ allow 80 bit arithmetic, though everybody is probably right that this is unlikely in practice with modern compiler options.
2) 80 bit operations can give the wrong results by Java rules, under unlikely conditions, even for a single operation.  Consider an operation that has to very slightly round up to get the nearest 80 bit result x.  Assume that x is half-way between the two closest 64 bit results, and the higher one is even.  Thus rounding to 64 bits gets us the higher value, which is not the nearest 64-bit result to the true answer.

Thus doing this portably and correctly, probably does require a library.  Or possibly just checking our compiler options might do.

I'm also not positive that C++ arithmetic will handle denormals correctly.  That presumably also depends on compiler flags.

3327
Wed Jul 29 08:52:06 2015 +0000
Author: Alexandre Rames <1052304@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4db19a56_bad9356f
UUID: 6d657ec3_7af5d943
Bytes: 803
I talked with Jacob and dug a little in VIXL. So we have seen issues like Hans explains in the VIXL simulator, in a similar context where we do *one* operation at a time.
Custom code has been implemented to handle the simulation of FP operations. Correctness is checked in the tests by validating an execution trace of the simulator against real hardware, so we are confident in the results.

Some pointers:

- simulation
vixl/src/vixl/a64/simulator-a64.cc: `Simulator::VisitFPDataProcessing2Source`
- simulation helpers declaration:
vixl/src/vixl/a64/simulator-a64.h: look for `#define NEON_FP3SAME_LIST(V)`
- simulation helpers implementation:
vixl/src/vixl/a64/logic-a64.cc: look for `LogicVRegister Simulator::FN`

- tests
vixl/test/test-simulator-a64.cc: look for `DEFINE_TEST_FP(fadd, 2Op, Basic)`

3327
Wed Jul 29 08:59:18 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6d657ec3_7af5d943
UUID: ad9936fb_ff0f1b6a
Bytes: 57
Thanks all!

Alexandre, I'll have a look a your pointers.

