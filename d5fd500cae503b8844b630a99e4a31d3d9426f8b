Revision: d5fd500cae503b8844b630a99e4a31d3d9426f8b
Patch-set: 3
File: compiler/optimizing/nodes.h

3327
Thu Jul 23 15:23:58 2015 +0000
Author: Alexandre Rames <1052304@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2d3aa6f6_c36ae8de
Bytes: 59
How do we handle Intel 80bit floating-point related issues?

3327
Tue Jul 28 09:47:48 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2d3aa6f6_c36ae8de
UUID: 2d862697_60fff29f
Bytes: 118
I thought all our operations in x86/x86-64 were only 32- or 64-bit; is there any place where we use 80-bit operations?

3327
Tue Jul 28 10:21:18 2015 +0000
Author: Alexandre Rames <1052304@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2d862697_60fff29f
UUID: 0d8962a8_ff0f1f6a
Bytes: 290
I meant, do we pay attention that we compile with gcc/clang flags disabling (not enabling?) 80bit float in the C++ compiled code? Otherwise the `ComputeFP` functions could operate with a higher precision than what should happen, and we could get 'wrong' results out of constant propagation.

3327
Tue Jul 28 11:08:35 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0d8962a8_ff0f1f6a
UUID: 4d7fda4c_21524e35
Bytes: 235
Oh right, I thought you were talking about the code generated by ART/dex2oat.  Thanks for pointing that out!  I'll look at the options here (using compile flags; or maybe using special instructions, such as SSE) and I'll update the CL.

3327
Tue Jul 28 16:03:39 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0d8962a8_ff0f1f6a
UUID: cd174afa_953c2481
Bytes: 341
I don't think this really matters. It seems rather unlikely that there will be code produced that doesn't use intermediates. For some reason, multiple operations would have to line up somewhere. I don't think the driver for the constant folding looks that way. (I'd contend that any inliner/unroller that produces such code is a bit insane.)

