Revision: 5bfa2b8bd5819faf8537376f3d16be6fdd7fe9c3
Patch-set: 3
File: /COMMIT_MSG

10:41-12:50
Wed Apr 08 21:13:31 2015 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 237f124e_0a739f97
Bytes: 139
Won't recomputing the PC be a performance regression if you have say a loop using a floating point literal? The literals being PC relative.

10:41-12:50
Wed Apr 08 21:18:11 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 237f124e_0a739f97
UUID: a3c5c2ce_a530fe1d
Bytes: 166
We have register promotion which takes loop depth into account and in X86Mir2Lir::CountRefs() we even double the weight of the anchor uses. I think we should be fine.

10:41-12:50
Wed Apr 08 21:21:33 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a3c5c2ce_a530fe1d
UUID: a3c5c2ce_8535020e
Bytes: 278
And the whole sentence actually refers to the fact that previously the sequence was "call +0; pop <reg>; sub <reg>, <offset-of-pop>" and we completely avoid the "sub". Instead, we take the anchor offset into account when generating PC-relative offsets or the large switch table.

10:41-12:50
Wed Apr 08 21:37:13 2015 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a3c5c2ce_8535020e
UUID: 83c43ed3_8afd0fed
Bytes: 323
SGTM. I think your statement of "rewrite all PC-relative addressing on x86" is some what over the top. You've inlined the macro to compute the beginning of the method and removed the subtract, adjusting the instructions that use the beginning of the method to incorporate the offset. Its more of a tinker than a rewrite ;-)

