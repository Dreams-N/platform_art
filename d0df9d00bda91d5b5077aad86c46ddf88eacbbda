Revision: d0df9d00bda91d5b5077aad86c46ddf88eacbbda
Patch-set: 2
File: compiler/optimizing/code_generator_mips.cc

4884:36-4884:44
Mon Jan 11 14:13:29 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ea4a4b41_72d8b8a2
Bytes: 9
MIPS32R6?

4884:36-4884:44
Mon Jan 11 18:51:06 2016 +0000
Author: Alexey Frunze <1056098@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ea4a4b41_72d8b8a2
UUID: 277bbeaf_14963434
Bytes: 244
MIPS32R6 in our case is a subset of MIPS64R6 and doesn't exist as a separate architecture of its own, at least for now. So, you can write either in the comment, but the emulator needs to be fixed for MIPS64R6, which will cover MIPS32R6 as well.

4884:36-4884:44
Tue Jan 12 12:13:13 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 277bbeaf_14963434
UUID: 67f216a9_2e7587d5
Bytes: 38
All right, thanks for the explanation.

4915:13-4915:20
Mon Jan 11 14:13:29 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ca4d875b_7140b837
Bytes: 422
The Dalvik bytecode documentation specifies that for values above std::numeric_limits<int64_t>::max() (resp. std::numeric_limits<int32_t>::max()), the {float,double}-to-long (resp. {float,double}-to-int) instructions should produce std::numeric_limits<int64_t>::max() (resp. std::numeric_limits<int32_t>::max()).

How does the TRUNC.L.fmt (resp. TRUNC.W.fmt) instruction deal with such values?  (Same question for MIPS64.)

4915:13-4915:20
Mon Jan 11 18:51:06 2016 +0000
Author: Alexey Frunze <1056098@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ca4d875b_7140b837
UUID: 27d01ee4_ec372b1f
Bytes: 478
R2 (NAN2008=0):
< min --> max
> max --> max
NaN --> max

R6 (NAN2008=1):
< min --> min
> max --> max
NaN --> 0

IOW, the difference is only in handling NaNs and negative values less than the minimum.

There's no difference between MIPS32 and MIPS64 other than the truncate/round/ceil/floor instructions with L in the format requiring a 64-bit FPU, which is always true for MIPS64 and R6 (AKA FR=1), while older MIPS32R2 could have either a 32-bit FPU (AKA FR=0) or a 64-bit one.

4915:13-4915:20
Tue Jan 12 12:13:13 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 27d01ee4_ec372b1f
UUID: 27fc9e7c_cc5faf50
Bytes: 361
So only the behavior of the R6 (NAN2008=1) instructions match the Dex {float,double}-to-{int,long} specification (https://source.android.com/devices/tech/dalvik/dalvik-bytecode.html); the R2 (NAN2008=0) ones do not produce the expected result for values above max and NaN.

Should you adjust the code for the R2 cases, or maybe delegate to runtime entry points?

4915:13-4915:20
Tue Jan 12 20:56:00 2016 +0000
Author: Alexey Frunze <1057043@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 27fc9e7c_cc5faf50
UUID: a7532e54_728598c3
Bytes: 920
It's NaN and values below the minimum that need special care on R2/NAN2008=0 and with the currently incorrect implementation of R6 in the emulator (it must have NAN2008=1, but doesn't).

This code takes care of them by comparing the float/double input with numeric_limits<int64_t/int32_t>::min() and then, if input >= min turns out true, it procedes to the trunc instruction, which takes care of values greater than the maximum the same way with any NAN2008 setting.

Otherwise (input >= min is false), the input is compared with itself (to detect a NaN) and the output is set to either the minimum or 0.

The runtime, where still used, takes care of the special cases. See file art/runtime/entrypoints/math_entrypoints.cc, functions art_d2l(), art_f2l(), art_d2i(), art_f2i() and the magic behind them in art_float_to_integral<int_type, float_type>().

I believe everything's correct (no failures in math tests either).

4915:13-4915:20
Wed Jan 13 11:05:17 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a7532e54_728598c3
UUID: 67f216a9_aee33732
Bytes: 347
Right; sorry, I read your initial reply too fast and thought the case of values above max (intead of the case of values below min) was not handled as expected for NAN2008=0, because there was no test for them.

Thanks for the explanation.  This looks correct to me.  Maybe add the first three paragraphs of your reply as a comment above line 4885?

4915:13-4915:20
Thu Jan 14 01:49:45 2016 +0000
Author: Alexey Frunze <1057043@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 67f216a9_aee33732
UUID: 27673e34_91e66b64
Bytes: 4
Done

4944:34-4944:42
Mon Jan 11 14:13:29 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8a570fe9_cfc1bd09
Bytes: 9
MIPS32R6?

4944:34-4944:42
Mon Jan 11 18:51:06 2016 +0000
Author: Alexey Frunze <1056098@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8a570fe9_cfc1bd09
UUID: 0776bac5_53a04462
Bytes: 14
Same as above.

