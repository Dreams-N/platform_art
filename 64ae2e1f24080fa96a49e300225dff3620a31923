Revision: 64ae2e1f24080fa96a49e300225dff3620a31923
Patch-set: 3
File: runtime/arch/mips/quick_entrypoints_mips.S

1348:4-1348:25
Fri Dec 11 17:44:02 2015 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 253496db_29141a1b
Bytes: 219
This is a no-op, not a fake dependency.  We need a fake dependency on the load of status into t5.

As it stands, this is clearly wrong.  Unless we get more clarification on the architecture, we need a SYNC_ACQUIRE here.

1348:4-1348:25
Fri Dec 11 22:17:37 2015 +0000
Author: Raghu Gandham <1064548@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 253496db_29141a1b
UUID: 6553ee27_7ccad674
Bytes: 1857
As per the spec below - section 4.2 Execution order behavior states the following 
"Uniprocessor Data Dependencies are always maintained. These include read-after-write, write-after-write and
write-after-read hazards". Using these dependencies for two instructions, we can build a larger dependency tree. The dependency tree is mostly derived information and is not documented for MIPS AFAIK if that is what you are asking.

MIPS Coherence Protocol specification
https://imagination-technologies-cloudfront-assets.s3.amazonaws.com/documentation/MD00605-2B-CMPCOHERE-AFP-01.01.pdf

Although addu instruction below appears as a nop, it will need to be executed by any MIPS processor to maintain the following dependencies.I have simplified the instruction sequence for discussion.

1. lw    $t5, STATUS($t0) 
2. addu  $t0, $t0, $zero  #WAR dependency on $t0
3. lw    $t5, FLAGS($t0) #RAW dependency on $t0 

While maintaining both the above dependencies, through 
register renaming, I can see a possibility of a CPU 
reading flags before status.
                           addu TMP1, $t0, $zero
                           lw   TMP2, FLAGS(TMP1)
 lw $t5, STATUS($t0)
                           move t0, TMP1
                           move t5, TMP2

Hence my earlier suggestion of introducing only addu dependency instead of "xor and addu" may not work on CPUs where aggressive speculative loads are enabled. However"xor and addu" will introduces a series of RAW dependencies which would serialize the execution.

1. lw    $t5, STATUS($t0) 
2. xor   $t5, $t5, $t5   # RAW on $t5
3. addu  $t0, $t0, $t5   # RAW on $t5
4. lw    $t5, FLAGS($t0) #RAW on $t0

@Hans, If you agree that this information is sufficient, we would upload another patch with "xor and addu" to maintain the load dependencies.If you need more information on any specific topic, let me know.

1348:4-1348:25
Fri Dec 11 23:48:34 2015 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6553ee27_7ccad674
UUID: e5cc3e7f_6275b614
Bytes: 1281
You identified the place where I also got stuck.  The questions is what that statement in 4.2 really means.  Does it mean that cross-processor ordering is enforced?  Or does it essentially only mean that a single core sees its own writes in the correct order, i.e. uniprocessor semantics are correctly maintained?

I asked David Lau that question in a previous exchange, and his answer was:

"It just means that for the CPU executing the code, the RAW, WAR, WAW dependencies are always honored."

I'm inclined to read that as the latter, especially since, as you point out, you can't really do register renaming and maintain WAR dependencies.  Thus my best guess now is that the SYNC_ACQUIRE is needed, and dependencies do not affect visibility across cores.  Initially I read 4.2 roughly the way you did. In retrospect, the mention of write-after-read hazards should have dissuaded me from that.

My sense is that hardware architects are very unlikely to reflect anything but RAW dependencies in cross-core memory ordering, and they're unenthusiastic about that, because even that inhibits some optimizations.

My current interpretation scares me because of implications on final field accesses.  The added fence here seems comparatively minor.

We really do need a clarification.

1348:4-1348:25
Sat Dec 12 17:17:17 2015 +0000
Author: Raghu Gandham <1064548@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e5cc3e7f_6275b614
UUID: 45db4a39_c6bf7878
Bytes: 1101
The statement in section 4.2 only means that uniprocessor semantics are correctly maintained. It does not guarantee cross-processor ordering of the resulting memory transactions. 

In my opinion, the visibility of loads to other processors does not matter in this situation since we are talking about a cached access. It only matters that the first load completes before the second load is initiated on the current processor. We achieve it successfully through a series of RAWs. However if we have non-dependent loads or loads which are dependent through Write-after-Reads, then SYNC_ACQUIRE is mandatory to ensure that loading of status is complete before loading of flags and size is initiated.

For sake of completeness, I will mention how stores are expected to complete on MIPS where ever the status is being updated. On the store side of the story, visibility of the stores is mandatory. Hence a sync_wmb/sync_mb/sync is required.

1. sw    $t1, FLAGS($t4)
2. sw    $t2, SIZE($t4) 
3. sync_wmb      # Required for rest of the loads to be globally visible before status.
4. sw    $t3, STATUS($t4)

1348:4-1348:25
Sun Dec 13 04:12:25 2015 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 45db4a39_c6bf7878
UUID: 25157684_4aa1d7c8
Bytes: 628
Can you point me at the spec that states that if two loads, such that the address of the second is dependent on the result of the first, i.e. there is a RAW dependency, then the first load must complete before the second is initiated?

Although this sounds like a vacuous requirement, it is not.  It prevents data speculation.  DEC Alpha violated this rule for a different reason, related to cache architecture.  I would also like to see it pinned down, since it may help to answer my next question, which is how such a RAW dependency is defined, and whether it includes the kind of "fake" dependencies we're trying to use here.

1348:4-1348:25
Mon Dec 14 23:31:27 2015 +0000
Author: Raghu Gandham <1064548@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 25157684_4aa1d7c8
UUID: 25157684_78de29fe
Bytes: 1256
The second load can only be initiated after the address of the load instruction is known. But the address of the second load is dependent on the result of the previous instruction. As section 4.2 states that all RAW, WAR, WAW dependencies should be satisfied, each instruction after the first load will need to be executed until the address of the 2nd load is calculated. Only after the address gets calculated, the second load can be initiated. Data speculation is allowed as long as execution order rules (section 4.2) are satisfied. In our example there is no scope for a speculative 2nd load due to the RAW dependency on the address of the load.

I had run this example by both architecture and hardware teams and both confirmed that these semantically fake dependencies are real dependencies for a MIPS processor and are sufficient to ensure that the second load gets initiated after the address dependency is satisfied.

Unfortunately, there is no MIPS specific documentation about the dependencies. The Wikipedia definition matches the assumptions on MIPS.
read after write (RAW), a true dependency
write after read (WAR), an anti-dependency
write after write (WAW), an output dependency

https://en.wikipedia.org/wiki/Hazard_(computer_architecture)

1348:4-1348:25
Tue Dec 15 00:08:51 2015 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 25157684_78de29fe
UUID: 65e04ee1_e7f1d08d
Bytes: 1629
The fact that the hardware teams believe fake dependencies are enforced is encouraging.

The fact that we're still talking about RAW, WAR, WAW dependencies at once seems very strange to me.  It seems entirely unreasonable to me to have hardware memory ordering be influenced by anything other than a RAW dependency, since WAR and WAW dependencies are removed by register renaming, as Ragu pointed out.  If the source code says:

lw $t1, x
copy $t1 to $t2
lw $t1, y

I would be really surprised if that caused the loads to be ordered. That's certainly not true on any of the other weakly ordered architectures I've encountered (ARM, Power, Itanium (and Alpha)).

If I have, with no unexpected aliasing

lw $t1, x
lw $t2, 0($t1)

the loads could in theory be performed by caching the previous address used by the second load (from the last time that instruction was executed), and then using that to run both loads in parallel, aborting the second one if the first one returns a different result.  In that case the data dependency would not force the first load to complete before the second.  I do not know of real architectures that do this, but I believe it has been seriously proposed in computer architecture papers (cf. http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.46.3036&rep=rep1&type=pdf from Europar '97).

As I mentioned, Alpha had a different cache-related reason for not enforcing ordering here, which I can't immediately reconstruct.

Thus I don't believe we can implicitly assume that an address dependency orders accesses; you really need a commitment by the architects not to violate such dependencies.

