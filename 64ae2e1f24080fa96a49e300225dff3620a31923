Revision: 64ae2e1f24080fa96a49e300225dff3620a31923
Patch-set: 3
File: runtime/arch/mips/quick_entrypoints_mips.S

1348:4-1348:25
Fri Dec 11 17:44:02 2015 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 253496db_29141a1b
Bytes: 219
This is a no-op, not a fake dependency.  We need a fake dependency on the load of status into t5.

As it stands, this is clearly wrong.  Unless we get more clarification on the architecture, we need a SYNC_ACQUIRE here.

1348:4-1348:25
Fri Dec 11 22:17:37 2015 +0000
Author: Raghu Gandham <1064548@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 253496db_29141a1b
UUID: 6553ee27_7ccad674
Bytes: 1857
As per the spec below - section 4.2 Execution order behavior states the following 
"Uniprocessor Data Dependencies are always maintained. These include read-after-write, write-after-write and
write-after-read hazards". Using these dependencies for two instructions, we can build a larger dependency tree. The dependency tree is mostly derived information and is not documented for MIPS AFAIK if that is what you are asking.

MIPS Coherence Protocol specification
https://imagination-technologies-cloudfront-assets.s3.amazonaws.com/documentation/MD00605-2B-CMPCOHERE-AFP-01.01.pdf

Although addu instruction below appears as a nop, it will need to be executed by any MIPS processor to maintain the following dependencies.I have simplified the instruction sequence for discussion.

1. lw    $t5, STATUS($t0) 
2. addu  $t0, $t0, $zero  #WAR dependency on $t0
3. lw    $t5, FLAGS($t0) #RAW dependency on $t0 

While maintaining both the above dependencies, through 
register renaming, I can see a possibility of a CPU 
reading flags before status.
                           addu TMP1, $t0, $zero
                           lw   TMP2, FLAGS(TMP1)
 lw $t5, STATUS($t0)
                           move t0, TMP1
                           move t5, TMP2

Hence my earlier suggestion of introducing only addu dependency instead of "xor and addu" may not work on CPUs where aggressive speculative loads are enabled. However"xor and addu" will introduces a series of RAW dependencies which would serialize the execution.

1. lw    $t5, STATUS($t0) 
2. xor   $t5, $t5, $t5   # RAW on $t5
3. addu  $t0, $t0, $t5   # RAW on $t5
4. lw    $t5, FLAGS($t0) #RAW on $t0

@Hans, If you agree that this information is sufficient, we would upload another patch with "xor and addu" to maintain the load dependencies.If you need more information on any specific topic, let me know.

1348:4-1348:25
Fri Dec 11 23:48:34 2015 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6553ee27_7ccad674
UUID: e5cc3e7f_6275b614
Bytes: 1281
You identified the place where I also got stuck.  The questions is what that statement in 4.2 really means.  Does it mean that cross-processor ordering is enforced?  Or does it essentially only mean that a single core sees its own writes in the correct order, i.e. uniprocessor semantics are correctly maintained?

I asked David Lau that question in a previous exchange, and his answer was:

"It just means that for the CPU executing the code, the RAW, WAR, WAW dependencies are always honored."

I'm inclined to read that as the latter, especially since, as you point out, you can't really do register renaming and maintain WAR dependencies.  Thus my best guess now is that the SYNC_ACQUIRE is needed, and dependencies do not affect visibility across cores.  Initially I read 4.2 roughly the way you did. In retrospect, the mention of write-after-read hazards should have dissuaded me from that.

My sense is that hardware architects are very unlikely to reflect anything but RAW dependencies in cross-core memory ordering, and they're unenthusiastic about that, because even that inhibits some optimizations.

My current interpretation scares me because of implications on final field accesses.  The added fence here seems comparatively minor.

We really do need a clarification.

1348:4-1348:25
Sat Dec 12 17:17:17 2015 +0000
Author: Raghu Gandham <1064548@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e5cc3e7f_6275b614
UUID: 45db4a39_c6bf7878
Bytes: 1101
The statement in section 4.2 only means that uniprocessor semantics are correctly maintained. It does not guarantee cross-processor ordering of the resulting memory transactions. 

In my opinion, the visibility of loads to other processors does not matter in this situation since we are talking about a cached access. It only matters that the first load completes before the second load is initiated on the current processor. We achieve it successfully through a series of RAWs. However if we have non-dependent loads or loads which are dependent through Write-after-Reads, then SYNC_ACQUIRE is mandatory to ensure that loading of status is complete before loading of flags and size is initiated.

For sake of completeness, I will mention how stores are expected to complete on MIPS where ever the status is being updated. On the store side of the story, visibility of the stores is mandatory. Hence a sync_wmb/sync_mb/sync is required.

1. sw    $t1, FLAGS($t4)
2. sw    $t2, SIZE($t4) 
3. sync_wmb      # Required for rest of the loads to be globally visible before status.
4. sw    $t3, STATUS($t4)

1348:4-1348:25
Sun Dec 13 04:12:25 2015 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 45db4a39_c6bf7878
UUID: 25157684_4aa1d7c8
Bytes: 628
Can you point me at the spec that states that if two loads, such that the address of the second is dependent on the result of the first, i.e. there is a RAW dependency, then the first load must complete before the second is initiated?

Although this sounds like a vacuous requirement, it is not.  It prevents data speculation.  DEC Alpha violated this rule for a different reason, related to cache architecture.  I would also like to see it pinned down, since it may help to answer my next question, which is how such a RAW dependency is defined, and whether it includes the kind of "fake" dependencies we're trying to use here.

