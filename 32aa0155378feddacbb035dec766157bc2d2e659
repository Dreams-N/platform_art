Revision: 32aa0155378feddacbb035dec766157bc2d2e659
Patch-set: 7
File: /COMMIT_MSG

10:46-10:57
Fri Feb 12 12:35:58 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 7daf0c90_5e7a4500
Bytes: 66
I think this is confusing, it's not related to HBasicBlock, is it?

File: compiler/optimizing/bounds_check_elimination.cc

506:61-506:67
Fri Feb 12 14:07:57 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 9d9da072_374ea067
Bytes: 33
likely or, in some cases, certain

1147:19-1147:74
Fri Feb 12 14:07:57 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: fde93cd0_7fb1cb27
Bytes: 310
This is misleading. We have chosen kMaxLengthForAddingDeoptimize so that if the first and last indexes are valid, all indexes in between will also be valid. You should add DCHECK_LE(distance, kMaxLengthForAddingDeoptimize) and static_assert(kMaxLengthForAddingDeoptimize < std::numeric_limits<int32_t>::max()).

1201:45-1201:83
Fri Feb 12 14:07:57 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: fde93cd0_5fa32fd8
Bytes: 481
I think these should be eliminated after we have added the deoptimization compares. Assuming that we see the bound checks in the order in which they appear in the snippet, consider

    int x = a[i] + a[i+1];
    if (b) {
      x += a[i+2];  // min_c = 0, max_c = 1 at this point.
    }
    x+= a[i+3] + a[i+4];

We would not add the a[i+2] bound check to the candidate list here even though we can obviously eliminate it after adding the deoptimization compares for a[i]...a[i+4].

1218:67-1218:73
Fri Feb 12 14:07:57 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1ddb703a_03c9526f
Bytes: 17
likely or certain

