Revision: 4d1875732004d1c65d660a22f7e880f1947d87ef
Patch-set: 3
File: compiler/optimizing/code_generator.cc

63:0-63:34
Sun Mar 02 20:23:20 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 5c920913_7fbbcfee
Bytes: 103
Seems odd we also have Assembler::Create, can we make the use of Assembler::Create and this consistent?

63:0-63:34
Tue Mar 04 16:20:17 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 5c920913_7fbbcfee
UUID: fcce5d4a_ec188bd3
Bytes: 113
What do you mean by consistent? I'll always end up switching here too, as I need to pick the right CodeGenerator.

File: compiler/optimizing/code_generator.h

72:2-72:12
Sun Mar 02 20:23:20 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 5c920913_5fb60b08
Bytes: 7
* const

72:2-72:12
Tue Mar 04 16:20:17 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 5c920913_5fb60b08
UUID: 1cc2511e_adad9d17
Bytes: 4
Done

File: compiler/optimizing/code_generator_arm.cc

28:0-28:25
Sun Mar 02 20:23:20 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 3c52b523_e38f45d3
Bytes: 17
no frame pointer?

28:0-28:25
Tue Mar 04 16:20:17 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 3c52b523_e38f45d3
UUID: dccb593b_eb763119
Bytes: 16
Can do :). Done.

File: compiler/optimizing/code_generator_x86.cc

28:0-28:20
Sun Mar 02 20:23:20 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 7c58ad41_59916436
Bytes: 19
Why frame pointers?

28:0-28:20
Tue Mar 04 16:20:17 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7c58ad41_59916436
UUID: fcce5d4a_0cbdd748
Bytes: 153
Better experience with debugging tools. I can see ART currently does not push frame pointers, but I guess the stack walker could work with both versions.

28:0-28:20
Tue Mar 04 22:16:52 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: fcce5d4a_0cbdd748
UUID: 7c66ed13_f54b6f47
Bytes: 289
The other thing on x86 is that we could always on entry do:

push fs:[last_frame_pointer_offset]
mov esp, fs:[last_frame_pointer_offset]
...
pop fs:[last_frame_pointer_offset]

if we were to want frame pointers and not blow a register. The primary concern being we have very few registers.

28:0-28:20
Wed Mar 05 15:10:55 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7c66ed13_f54b6f47
UUID: 1cc2511e_d3a9aca5
Bytes: 121
Yes, we could. I'm still worried about the use of fs:.. though, I'll investigate the size/performance cost at some point.

28:0-28:20
Thu Mar 06 00:48:51 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1cc2511e_d3a9aca5
UUID: 1c7df19f_174866eb
Bytes: 835
Quick isn't smart about its use of fs: and consequently whenever it needs the thread it uses fs:. You can reduce need for the thread by unrolling loops, avoiding suspend checks that dominate others, etc. Comparing this naive use of fs: to using a register, in some cases you can see a 1% performance win from not using fs in a micro benchmark that attempts to reproduce the conditions from quick. This doesn't measure the cost of losing the register across all compiled code. I think what I prefer in the case that using fs: is an impediment is to allocate a temporary to hold the thread and then have the codegen use the temporary if there or fs: otherwise.
I expect in a reasonable "optimizing" compiler the extra register will be of more performance advantage than the smaller instruction encoding. This has been my past experience.

File: compiler/optimizing/codegen_test.cc

30:6-30:54
Sun Mar 02 20:23:20 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 7c58ad41_3996b030
Bytes: 80
we have MakeExecutable which is a similar to this, can we just have 1 code path.

30:6-30:54
Tue Mar 04 16:20:17 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7c58ad41_3996b030
UUID: 1cc2511e_6d433584
Bytes: 4
Done

