Revision: d8cca802b80b59c057571a352c6580074696c769
Patch-set: 2
File: compiler/optimizing/bounds_check_elimination.cc

68:0-69:60
Wed Feb 10 16:20:00 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 9d9da072_d14c841b
Bytes: 7
/*out*/

68:0-69:60
Wed Feb 10 18:22:20 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 9d9da072_d14c841b
UUID: bdc1846e_209eeeda
Bytes: 76
I followed the style of this file, but added here and where else it applies.

867:10-867:64
Wed Feb 10 16:20:00 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: fde93cd0_9c730528
Bytes: 182
Why do you need this? What about

    int foo(int[][] array) {
        int[] a = array[off1];
        int result = a[off2]+a[off2+1]+a[off2+2]+a[off2+3];
        return result;
    }

867:10-867:64
Wed Feb 10 18:22:20 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: fde93cd0_9c730528
UUID: fdce9ca2_e8d57b63
Bytes: 429
I am not sure I understand your example, but I don't need this. I was overly concerned about matching array references, since the current approach is detached (collect them, but then rely on range propagation to eliminate them).

I actually have a new approach that simply removes bound checks on the ones collected, so we don't need to worry about that (and it is even less code changed compared to current file).

Stay tuned...

