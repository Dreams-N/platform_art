Revision: 5b2c149571b2fa168b99f3d2e2bfd1564b8830a6
Patch-set: 5
File: runtime/class_linker.cc

6545:43-6545:48
Fri Sep 09 17:22:07 2016 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ab0ebe7a_a60b6884
Bytes: 81
Will the rest arrays be passed by value? Anyway to make them passed by reference?

6545:43-6545:48
Fri Sep 09 17:27:05 2016 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ab0ebe7a_a60b6884
UUID: ab0ebe7a_86f46c4e
Bytes: 42
no but added things to make it more clear.

6545
Fri Sep 09 17:36:07 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ab0ebe7a_6644d09e
Bytes: 452
nit: don't need two functions

  std::reference_wrapper<const ScopedArenaVector<ArtMethod*>> lists[] = {std::cref(list), std::cref(rest)...};

  for (auto&& list_wrapper : lists) { 
      const ScopedArenaVector<ArtMethod*>& list = list_wrapper.get();
  // existing code
  }

  // or just use a pointer instead of reference_wrapper. key is that arrays of references are illegal
  // but by using an array we can avoid recursively calling this function.

6545
Fri Sep 09 17:41:46 2016 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ab0ebe7a_6644d09e
UUID: ab0ebe7a_e66ba0ad
Bytes: 23
I like this way better.

6545:43-6545:48
Fri Sep 09 17:42:01 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ab0ebe7a_a60b6884
UUID: ab0ebe7a_8698ecc6
Bytes: 138
Without including & or && it will pass by value, see  http://www.aristeia.com/TalkNotes/C++TypeDeductionandWhyYouCareCppCon2014.pdf page 7

6545:43-6545:48
Fri Sep 09 17:47:29 2016 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ab0ebe7a_8698ecc6
UUID: ab0ebe7a_462ef453
Bytes: 77
so I changed it to const Types& ... rest in the next version, does that work?

6545:43-6545:48
Fri Sep 09 17:48:46 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ab0ebe7a_462ef453
UUID: ab0ebe7a_c63024a1
Bytes: 27
Yes, that definitely works.

6605
Fri Sep 09 17:36:07 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ab0ebe7a_e6f1e05c
Bytes: 75
nit: separating into 2 CHECKs will make it easier to determine which failed

6605
Fri Sep 09 17:41:46 2016 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ab0ebe7a_e6f1e05c
UUID: ab0ebe7a_2688187c
Bytes: 94
Really the first is just a short circuit. Also the names should be different from prettyMethod

7187:39-7187:45
Fri Sep 09 17:36:07 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ab0ebe7a_a61ec879
Bytes: 69
Can you turn this into a named constant? 0xFFFF seems pretty magical.

7187:39-7187:45
Fri Sep 09 17:41:46 2016 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ab0ebe7a_a61ec879
UUID: ab0ebe7a_a69b68c2
Bytes: 56
It's just getting the lower 16 bits. It's not very magic

7187:39-7187:45
Fri Sep 09 17:48:46 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ab0ebe7a_a69b68c2
UUID: ab0ebe7a_a6cd28b3
Bytes: 146
That doesn't explain why it's setting the lower 16 bits. It's some kind of implied context that other people don't understand when they read this.

7187:39-7187:45
Fri Sep 09 17:57:45 2016 +0000
Author: Alex Light <1047769@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ab0ebe7a_a6cd28b3
UUID: ab0ebe7a_c9a675ad
Bytes: 199
It is just making explicit that we expect the truncation of the number when it is converted to the uint16_t this function expects. It is done the same way many other places in this function and file.

7187:39-7187:45
Fri Sep 09 18:10:21 2016 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ab0ebe7a_c9a675ad
UUID: ab0ebe7a_c92b15ed
Bytes: 954
I see..

   static_cast<uint16_t>(i)

is much more clear then. It does the same exact thing because a cast to an unsigned value is the modulus 2^sizeof.

And it's more readable. And there's less magic.

0xFFFF seems like some java-ism to go from int/long to short because they don't have proper unsigned types.

Look at what it does, I made the implicit conversions explicit:

   0xFFFF & i -> 0xFFFF has to be converted to size_t first
   (size_t)(0xFFFF) & i
   // and 0xFFFF is a signed int here so we have to consider (a) signed int32->unsigned32 and 
   // (b) signed int32 -> unsigned int64 depending on arch
   Now the whole type is size_t.
   (uint16_t)((size_t)(0xFFFF) & i)
   and it has to do an implicit uint16_t conversion anyway because the type of the expression doesn't
    match function parameter.

Plus we have to worry about this magic number 0xFFFF. VS:

   static_cast<uint16_t>(i)

No implicit hidden conversions, no magic numbers.

