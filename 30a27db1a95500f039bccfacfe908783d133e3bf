Revision: 30a27db1a95500f039bccfacfe908783d133e3bf
Patch-set: 3
File: runtime/gc/accounting/bitmap.cc

95:15-95:32
Fri Oct 23 19:25:01 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 16b509da_1a229d75
Bytes: 314
Would it make sense to have this line in jit_code_cache.cc rather than here because jit_code_cache depends on bitmap, not the other way around?

(If you feel like it, I think it's an option to try to move this class to a more generic location, outside of gc/. Mathieu? No problem not to do that in this CL though.)

95:15-95:32
Fri Oct 23 21:00:25 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 16b509da_1a229d75
UUID: 16c1896c_fa9f898c
Bytes: 175
I think I need it here because that's where the template methods of MemoryRangeBitmap are (to avoid stl template instantiation errors). I agree having it elsewhere is cleaner.

95:15-95:32
Mon Oct 26 17:15:36 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 16c1896c_fa9f898c
UUID: 7671e51a_6546a63c
Bytes: 45
it's unfortunate to need keeping this here...

File: runtime/jit/jit_code_cache.cc

297:15-297:18
Fri Oct 23 19:25:01 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 76dac536_5d717b0b
Bytes: 129
I think this should use the parallel version AtomicTestAndSetBit() as multiple runnable threads could try to set in a checkpoint.

297:15-297:18
Fri Oct 23 21:00:25 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 76dac536_5d717b0b
UUID: 56b5c1f6_bca901b8
Bytes: 65
Why could it be a problem that multiple threads set the same bit?

297:15-297:18
Fri Oct 23 21:55:21 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 56b5c1f6_bca901b8
UUID: 76dac536_038072c0
Bytes: 116
You can lose writes if two threads are marking bits to the same word in the bitmap if you dont use AtomicTestAndSet.

297:15-297:18
Fri Oct 23 22:16:42 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 76dac536_038072c0
UUID: f69a3588_e1cda697
Bytes: 62
Ah good to know, will change to AtomicTestAndSet then, thanks!

297:15-297:18
Mon Oct 26 14:27:19 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f69a3588_e1cda697
UUID: 36b04d09_1bed9be4
Bytes: 4
Done

312:7-312:10
Fri Oct 23 19:25:01 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 16b509da_fa8ec9bc
Bytes: 109
How about adding

CHECK(thread == self || thread->IsSuspended());

like the other checkpoint closure classes?

312:7-312:10
Mon Oct 26 14:27:19 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 16b509da_fa8ec9bc
UUID: 36b04d09_fb1aefb5
Bytes: 4
Done

326:2-326:6
Fri Oct 23 19:25:01 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f6b795e1_b94e1f56
Bytes: 214
Would we want to LOG instead VLOG if a non-debug build? This should happen rarely in production but if it happens, it may be worth warning as performance could degrade noticeably and someone may want to know about?

326:2-326:6
Mon Oct 26 14:27:19 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f6b795e1_b94e1f56
UUID: 36b04d09_db1f33a4
Bytes: 4
Done

332
Fri Oct 23 22:08:17 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 36e4cdf6_417a767a
Bytes: 134
Do you want to clear the live bitmap? If this is not done, the things which end up marked will be held live permanantly in future GCs.

332
Fri Oct 23 22:16:42 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 36e4cdf6_417a767a
UUID: 56b5c1f6_7cb4990a
Bytes: 125
Yeah that was the intent of the Clear call below on the individual bit. Should I use Bitmap::Clear() for clearing everything?

332
Mon Oct 26 14:27:19 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 56b5c1f6_7cb4990a
UUID: 36b04d09_bb146789
Bytes: 4
Done

357
Fri Oct 23 22:08:17 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 36e4cdf6_6196921b
Bytes: 151
Is there a race here with multiple JIT compiler threads where a thread could compile a method, set the entry point, but not have the live/mark bit set?

357
Fri Oct 23 22:16:42 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 36e4cdf6_6196921b
UUID: 1683491e_8ab3ab22
Bytes: 143
Good catch. Adding a WaitForPotentialGCToComplete or maybe just marking the bit if we see a GC when setting an entry point should fix it. WDYT?

357
Mon Oct 26 14:27:19 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1683491e_8ab3ab22
UUID: 1698a98e_e2312627
Bytes: 190
Actually, I don't think we have a problem. We only set the entry point when we have the lock. And we only have the lock if there is no collection in progress. I added a DCHECK in CommitCode.

363:19-363:35
Fri Oct 23 21:55:21 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 36e4cdf6_2111ea6a
Bytes: 227
Iterating over this is probably not safe since the ArtMethod pointers may have been class unloaded, any idea how to deal with this? Maybe I should add a sweeping phase that removes ArtMethods that have an unmarked class loader.

363:19-363:35
Fri Oct 23 22:16:42 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 36e4cdf6_2111ea6a
UUID: 7671e51a_85b3a222
Bytes: 375
Two options I think:
1) We don't do much with the ArtMethod if the bit is not set: we clear the counter of the method and we dcheck the entrypoint. We could decide on not doing anything by removing the dcheck and have a different strategy for counting again in the interpreter.
2) We could have a hook when the class loader is being deleted to clear the methods in the cache.

363:19-363:35
Fri Oct 23 23:00:25 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7671e51a_85b3a222
UUID: 96df3923_84f80a30
Bytes: 197
If the ArtMethod's linear alloc has been freed then it could cause corruption to clear the counter. I think clearing ArtMethods as we perform unloading might be OK. I'll try to implement that soon.

363:19-363:35
Mon Oct 26 14:27:19 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 96df3923_84f80a30
UUID: 16c1896c_da1f25a4
Bytes: 147
Turns out it's more the changing of all entry points to interpreter that will be problematic. I've added the hook form the class loader destructor.

372:25-372:30
Fri Oct 23 19:25:01 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 56e941ce_bce0c180
Bytes: 47
Is this necessary? We just checked if it's set?

372:25-372:30
Fri Oct 23 21:00:25 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 56e941ce_bce0c180
UUID: 7671e51a_25a58edc
Bytes: 41
Isn't it necessary for the next GC round?

372:25-372:30
Fri Oct 23 21:55:21 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7671e51a_25a58edc
UUID: 96df3923_21af2806
Bytes: 106
Hiroshi means that you alrady know the live bit is not set since that is what is checked in the condition.

372:25-372:30
Fri Oct 23 22:16:42 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 96df3923_21af2806
UUID: d67c51f3_a8d95b56
Bytes: 64
Yup got things mixed up, this should have been in the if branch.

372:25-372:30
Fri Oct 23 23:00:25 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d67c51f3_a8d95b56
UUID: f6ceb575_2aa0e3cb
Bytes: 116
I think its better to clear the whole bitmap at the end of the GC since that will madvise dirty pages in the bitmap.

File: runtime/jit/jit_code_cache.h

123:0-123:23
Fri Oct 23 22:08:17 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 76dac536_83272252
Bytes: 20
Sort alphabetically.

135
Fri Oct 23 22:08:17 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 96df3923_81a47cf7
Bytes: 18
GUARDED_BY(lock_)?

File: runtime/jit/profiling_info.cc

89:53-89:74
Fri Oct 23 19:25:01 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d6d53101_20d00ab6
Bytes: 103
Do you mind changing this to "Read()" (enabling the read barrier)? Or I'll make this change separately.

89:53-89:74
Mon Oct 26 14:27:19 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d6d53101_20d00ab6
UUID: 36b04d09_9b19abc1
Bytes: 4
Done

