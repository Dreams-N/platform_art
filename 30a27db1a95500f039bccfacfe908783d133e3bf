Revision: 30a27db1a95500f039bccfacfe908783d133e3bf
Patch-set: 3
File: runtime/gc/accounting/bitmap.cc

95:15-95:32
Fri Oct 23 19:25:01 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 16b509da_1a229d75
Bytes: 314
Would it make sense to have this line in jit_code_cache.cc rather than here because jit_code_cache depends on bitmap, not the other way around?

(If you feel like it, I think it's an option to try to move this class to a more generic location, outside of gc/. Mathieu? No problem not to do that in this CL though.)

95:15-95:32
Fri Oct 23 21:00:25 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 16b509da_1a229d75
UUID: 16c1896c_fa9f898c
Bytes: 175
I think I need it here because that's where the template methods of MemoryRangeBitmap are (to avoid stl template instantiation errors). I agree having it elsewhere is cleaner.

File: runtime/jit/jit_code_cache.cc

297:15-297:18
Fri Oct 23 19:25:01 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 76dac536_5d717b0b
Bytes: 129
I think this should use the parallel version AtomicTestAndSetBit() as multiple runnable threads could try to set in a checkpoint.

297:15-297:18
Fri Oct 23 21:00:25 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 76dac536_5d717b0b
UUID: 56b5c1f6_bca901b8
Bytes: 65
Why could it be a problem that multiple threads set the same bit?

297:15-297:18
Fri Oct 23 21:55:21 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 56b5c1f6_bca901b8
UUID: 76dac536_038072c0
Bytes: 116
You can lose writes if two threads are marking bits to the same word in the bitmap if you dont use AtomicTestAndSet.

312:7-312:10
Fri Oct 23 19:25:01 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 16b509da_fa8ec9bc
Bytes: 109
How about adding

CHECK(thread == self || thread->IsSuspended());

like the other checkpoint closure classes?

326:2-326:6
Fri Oct 23 19:25:01 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f6b795e1_b94e1f56
Bytes: 214
Would we want to LOG instead VLOG if a non-debug build? This should happen rarely in production but if it happens, it may be worth warning as performance could degrade noticeably and someone may want to know about?

363:19-363:35
Fri Oct 23 21:55:21 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 36e4cdf6_2111ea6a
Bytes: 227
Iterating over this is probably not safe since the ArtMethod pointers may have been class unloaded, any idea how to deal with this? Maybe I should add a sweeping phase that removes ArtMethods that have an unmarked class loader.

372:25-372:30
Fri Oct 23 19:25:01 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 56e941ce_bce0c180
Bytes: 47
Is this necessary? We just checked if it's set?

372:25-372:30
Fri Oct 23 21:00:25 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 56e941ce_bce0c180
UUID: 7671e51a_25a58edc
Bytes: 41
Isn't it necessary for the next GC round?

372:25-372:30
Fri Oct 23 21:55:21 2015 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7671e51a_25a58edc
UUID: 96df3923_21af2806
Bytes: 106
Hiroshi means that you alrady know the live bit is not set since that is what is checked in the condition.

File: runtime/jit/profiling_info.cc

89:53-89:74
Fri Oct 23 19:25:01 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d6d53101_20d00ab6
Bytes: 103
Do you mind changing this to "Read()" (enabling the read barrier)? Or I'll make this change separately.

