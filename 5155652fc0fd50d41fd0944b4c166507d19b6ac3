Revision: 5155652fc0fd50d41fd0944b4c166507d19b6ac3
Patch-set: 1
File: runtime/atomic.h

42:17-42:51
Wed May 21 01:38:33 2014 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 9f2f188c_74c31e71
Bytes: 19
Also check alignof?

75:2-81:3
Wed May 21 01:38:33 2014 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 9f2f188c_94bd6af2
Bytes: 210
Should be explicit about memory order, at least in a comment.  SequentiallyConsistent for now?  Relaxed is also quite common for dumb counters.  Those should probably use a more scalable data structure, but ...

350:2-350:32
Wed May 21 01:38:33 2014 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 9f2f188c_74443e30
Bytes: 208
Needs to follow the load, and should probably be LoadAny, with the proviso that ARMv8 ishld most probably doesn't work, in spite of the fact that it appears to.  Maybe leave as LoadLoad for now, and I'll fix.

File: runtime/base/mutex-inl.h

224:33-224:48
Wed May 21 01:38:33 2014 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 9f1ab865_6ec8c559
Bytes: 297
Very similar issue to the other code I'm reviewing.  I think this has to be ordered with respect to the CAS.  A release_cas probably doesn't do that.  This change doesn't break things any more, but I don't think the code is quite right.  I'm still trying to understand the right C++11 constraints.

File: runtime/base/mutex.cc

74:64-74:72
Wed May 21 01:38:33 2014 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 9f1ab865_aeeb7d43
Bytes: 99
Needs to be at least memory_order_acquire to keep accesses from moving out of the critical section.

79:64-79:72
Wed May 21 01:38:33 2014 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 9f2f188c_547f02ef
Bytes: 28
Needs to be at least release

File: runtime/base/mutex.h

168:14-168:78
Wed May 21 01:38:33 2014 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 9f1ab865_8e6a01fe
Bytes: 170
spelling of contetion (was there already)
I'm not sure you need SequentiallyConsistent here any more than for any of the other relaxed uses.
Neither problem matters much.

File: runtime/gc/collector/mark_sweep.cc

885:25-885:51
Wed May 21 01:38:33 2014 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ff281483_d8f44266
Bytes: 89
Does this need to be sequentially consistent?  Is someone else accessing it concurrently?

1218:32-1219:61
Wed May 21 01:38:33 2014 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ff281483_98f7da6e
Bytes: 132
Does this really need to be sequentially consistent?  Is anything else still changing these?  If there's no race, it doesn't matter.

File: runtime/gc/heap.cc

1316:55-1316:76
Wed May 21 01:38:33 2014 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 9f1ab865_d921e1bd
Bytes: 290
The question again is whether you care about seeing all  memory accesses by other threads to other variables that preceded num_bytes_allocated getting its current value.  SequentiallyConsistent is clearly safe, but I'm not sure I understand why it's being used here and not in other places.

File: runtime/instrumentation.cc

525:63-525:85
Wed May 21 01:38:33 2014 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 9f1ab865_d98b2159
Bytes: 107
I don't think SequentiallyConsistent every helps in such a DCHECK.  We're not really looking at the result.

File: runtime/mirror/object.cc

142:52-142:73
Wed May 21 01:38:33 2014 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 9f1ab865_396c55d8
Bytes: 17
Should be relaxed

File: runtime/thread_pool_test.cc

85:21-85:46
Wed May 21 01:38:33 2014 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 9f2f188c_3ff68ff9
Bytes: 50
Seems blatantly inconsistent with previous change.

