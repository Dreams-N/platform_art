Revision: a1246331ec4f86943c10dbc90f4917b310773092
Patch-set: 2
File: compiler/optimizing/ssa_builder.cc

651
Tue Nov 03 17:10:46 2015 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 562a227b_6edc6408
Bytes: 74
This is hacky. Couldn't we instead add logic to delete affected loop phis?

651
Tue Nov 03 17:22:12 2015 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 562a227b_6edc6408
UUID: f6195673_eb516ce2
Bytes: 113
This looks like marking `phi` dead on line 291 if `input` is nullptr would do the trick. Correct me if i'm wrong.

651
Wed Nov 04 10:13:19 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f6195673_eb516ce2
UUID: d659b274_3aedc1e7
Bytes: 336
Actually this does not work in the general case. If the local before is a phi, at this stage it's typed void so we will mis it.

Let's discuss about this. Could we give an initial type to a phi? That would make the type propagation convergence faster, but not sure if we handle it (today or even with your DeadPhiHandling change). WDYT?

651
Wed Nov 04 18:47:47 2015 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d659b274_3aedc1e7
UUID: d683721b_8a7c8bca
Bytes: 1371
Ah yeah, that's nasty. So don't forget there's three places where we create phis:

1) visiting a block that's not a loop header
This creates a phi for each vreg defined in all predecessors. It does not do any typing though, so it will create a phi even if the values are of a different size - we rely on DeadPhiHandling to not revive it / will rely on type propagation to mark it dead. But that's after the StoreLocal was visited.

You could get away with assigning a type in this case though. You could initialize the phi to kPrimInt if there are only 32-bit inputs, and kPrimLong otherwise. Type propagation will either type it properly or mark the phi dead.

2) visiting a block that is a loop header:
We eagerly create empty phis for all vregs defined in the pre-header. The problem is different here, though, because we only have locals for the pre-header. It should work just the same with a single input though. Either you get the type size right and the phi stays in the environments, or you get it wrong, typing will fail anyway and the phi gets removed.

3) requesting locals for a catch block
Eagerly creating catch phis. Again, you could base the initial type for a phi for each vreg based on the current locals.

So that sounds like it could work. I'd prefer if you waited until my CL goes in, though, because the above relies on dealing with type conflicts.

File: test/543-env-long-ref/smali/TestCase.smali

23
Tue Nov 03 17:10:46 2015 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 7643a650_5df8366e
Bytes: 60
Why don't you just test the environment values with checker?

23
Tue Nov 03 17:13:03 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7643a650_5df8366e
UUID: f675d6b9_f395d0ff
Bytes: 174
I could, but the jdwp debugger doesn't use checker ;-) so this test is just reproducing the bug you would see with jdwp, which is (I'm sorry) superior than a checker test ;-)

23
Tue Nov 03 17:19:56 2015 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f675d6b9_f395d0ff
UUID: d63612de_a02db887
Bytes: 267
Surely your test is not meant to verify stack map generation and neither simulate the way jdwp accesses vregs, but merely check the fact that a value was removed from the environment. I'm not gonna be a checker-evangelist though, so will leave it to your judgement ;)

