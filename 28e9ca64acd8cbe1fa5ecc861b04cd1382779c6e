Revision: 28e9ca64acd8cbe1fa5ecc861b04cd1382779c6e
Patch-set: 4
File: /COMMIT_MSG

56:0-56:4
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2d80bdc3_2a074775
Bytes: 18
Nice improvements.

File: runtime/arch/quick_alloc_entrypoints.S

35:0-35:26
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2d80bdc3_ca17b39b
Bytes: 79
Note to self: Why do we need separate alloc entry points for dlmalloc/rosalloc?

File: runtime/arch/quick_alloc_entrypoints.cc

60:0-60:6
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0d7db99f_a93e053b
Bytes: 167
I assume this default value kAllocatorTypeDLMalloc isn't used at all, that is, it's always overwritten via the ChangeCollector() call from Heap::Heap(). Is this right?

File: runtime/entrypoints/entrypoint_utils.cc

86:0-86:2
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8dd609da_9a2811b3
Bytes: 60
Mention the allocator_type change issue here (leave a TODO)?

File: runtime/entrypoints/entrypoint_utils.h

82:0-82:4
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8dd609da_a512966b
Bytes: 395
In the comment, can you elaborate on the allocator change issue while the entry point is ongoing with regard to the collector transition issue and the ResolveType(), EnsureInitialized() which may cause the thread to be suspended?

As we discussed in the in-person conversation, it'd be nice if we can avoid the need to check the allocator change here, or do it in a cleaner way. Any better idea?

106:0-106:4
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4d25f1ed_473c2ea7
Bytes: 137
Would it be worth checking allocator_type != heap->GetCurrentAllocator() before calling heap->AllocObject(), rather than falling through?

107:0-107:4
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0d7db99f_29075575
Bytes: 191
Why the asymmetry, calling Heap::AllocObject() (as opposed to calling Class::Alloc() with the current allocator here while calling Array::Alloc() with the current allocator below in line 165?

File: runtime/entrypoints/portable/portable_alloc_entrypoints.cc

23:0-23:9
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2d80bdc3_4504f42d
Bytes: 24
Can we make this static?

File: runtime/gc/collector/garbage_collector.cc

87:0-87:6
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8dd609da_e58bbe52
Bytes: 105
In what call path does this case (the mutator lock is already exclusively held) happens? Leave a comment?

File: runtime/gc/collector/mark_sweep.cc

1131:0-1131:2
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0d7db99f_84e1b045
Bytes: 231
In the old code, the allocation stack space used to be temporarily reused as a buffer passed to FreeList(). In the new code, we use this separate stack-allocated buffer. There's no noticeable performance loss due to this, I assume?

1141:0-1141:4
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0d7db99f_a94fe5a5
Bytes: 58
Does this if statement filter out the bump pointer spaces?

1187:0-1187:2
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8dd609da_85cf529b
Bytes: 368
In the new code, we iterate over 'objects' (the allocation stack) three times, once for each of the alloc spaces (dlmalloc and rosalloc ones) and once for the large object space (IIUC), as opposed to once in the old code. Is there a rationale for this? Would it make sense to swap the inner/outer loops so that we iterate over the allocation stack iteration loop once?

File: runtime/gc/collector/semi_space.cc

103:0-103:6
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0d7db99f_e402e4d0
Bytes: 664
Is it the case that to_space_ can point to either one of the bump pointer spaces (normal case) or the rosalloc/dlmalloc space (which happens when the application goes from the background to the foreground)?

Would it make it a bit cleaner if it was structured like:

if (space == to_space_ && space->GetLiveBitMap() != nullptr) {
  BindLiveToMarkBitmap(to_space_);
} else if (space->GetGcRetentionPolicy() == space::kGcRetentionPolicyNeverCollect
          || space->GetGcRetentionPolicy() == space::kGcRetentionPolicyFullCollect) {
  ImmuneSpace(space);
}

as whether a space has a non-null live bitmap could be independent of whether to call ImmuneSpace() on it?

228:0-228:2
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8dd609da_859e724c
Bytes: 55
Is there a reason not to use uint64_t instead int here?

237:0-237:2
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2d80bdc3_e5e8a09d
Bytes: 85
What happens if the freed bytes is negative? Would it be ok in terms of RecordFree()?

357:0-357:10
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2d80bdc3_05efdc9c
Bytes: 269
I believe this is necessary when we switch from background (bump pointer) to foreground (free list). Is there a reason not to call GetLiveBitmap() on the to-space and to instead store (cache) the live bitmap object in to_space_live_bitmap_ other than a performance one?

File: runtime/gc/collector/semi_space.h

269:0-269:2
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0d7db99f_848770fc
Bytes: 167
Can you leave a short comment/note on what this to_space_ and from_space_ could point to in what situations, such as a bump pointer space or a rosalloc/dlmalloc space?

270:0-270:2
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2d80bdc3_a5fce88c
Bytes: 85
Why do we keep this live bitmap here outside of the space itself (is it performance)?

File: runtime/gc/heap-inl.h

60:8-60:10
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2d80bdc3_e58d00d9
Bytes: 95
Same comment as the quick entrypoint code. It'd be nice if we can avoid the need to check this.

145:0-145:8
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2d80bdc3_c5fec41b
Bytes: 157
Just paraphrasing to confirm, as rosalloc_space_ is of type RosAllocSpace rather than type MallocSpace this call can be inlined without the reinterpret_cast.

146:0-146:8
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2d80bdc3_0574bc14
Bytes: 71
Move DCHECK above line 145 (a minor point)?

Same comment for line 156.

File: runtime/gc/heap.cc

292:5-292:9
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0d7db99f_8a19b75e
Bytes: 189
Typo: TOOD -> TODO.

Also, if we suspend the threads here, could we get rid of the code that checks/detects that the allocator has changed in the quick alloc entry point path (I guess not)?

335:0-335:4
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0d7db99f_ea75cb5b
Bytes: 70
This function gets called asynchronously with regard to the GC, right?

344:4-344:26
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0d7db99f_2ad4232c
Bytes: 67
Why trigger a collection here when the process state didn't change?

386:0-386:2
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0d7db99f_2a0983f5
Bytes: 288
Isn't it the case that only one of rosalloc_space_ and dlmalloc_space_ is not null? If so, we don't need to pass two live bitmaps to MarkAllocStack (and avoiding adding a new parameter to it)? Or, is this meant to be general enough to be able to handle two non-null distinct live bitmaps?

908:0-908:4
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2d80bdc3_45d4f4d3
Bytes: 27
int64_t instead of int32_t?

1145:2-1145:4
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0d7db99f_0af5a739
Bytes: 113
To reduce the indentation level, how about doing:

if (collector_type == collector_type_) {
  return;
}

instead?

1153:0-1153:4
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8dd609da_061fe86e
Bytes: 130
The code in StartGC() already existed and worked, but I wonder why we need to busy-wait here. Is there a way to simply block-wait?

1162:29-1162:44
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0d7db99f_ca9a4fdb
Bytes: 157
rosalloc_space_ could be null here. Maybe move this Compact() call below after main_space is set and pass main_space instead? Test with kUseRosAlloc = false?

1185:45-1185:52
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0d7db99f_4a615f20
Bytes: 84
nit: we don't need to initialize it to nullptr as it'll be overwritten anyway below?

1337:0-1337:2
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8dd609da_a6129c6b
Bytes: 323
This is communicated in person, but if kUseRosAlloc is false (we use dlmalloc), then this code would overwrite the new main space (after the zygote fork) with the newly-created non-moving space here. The fix, as we discussed, is to not overwrite dlmalloc_space_ here and store the new non-moving space to non_moving_space_.

File: runtime/gc/heap.h

95:43-95:54
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8dd609da_450deac7
Bytes: 60
allocations -> allocator (to be consistent with the others)?

485:24-485:40
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ad266df6_0a887bc1
Bytes: 82
nit: Is name GetRosAllocSpace() better as it matches the class name RosAllocSpace?

File: runtime/runtime.cc

384:5-384:7
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ad266df6_4ac553d9
Bytes: 56
I think "is" is missing. Either add "is" or remove "it"?

File: runtime/utils.cc

441:0-441:3
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4d25f1ed_a7a6cad7
Bytes: 99
Would it be worth keeping the size_t version as well in case we really want unsigned 64-bit size_t?

