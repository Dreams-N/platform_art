Revision: 28e9ca64acd8cbe1fa5ecc861b04cd1382779c6e
Patch-set: 4
File: /COMMIT_MSG

56:0-56:4
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2d80bdc3_2a074775
Bytes: 18
Nice improvements.

File: runtime/arch/quick_alloc_entrypoints.S

35:0-35:26
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2d80bdc3_ca17b39b
Bytes: 79
Note to self: Why do we need separate alloc entry points for dlmalloc/rosalloc?

35
Tue Jan 07 23:04:26 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2d80bdc3_ca17b39b
UUID: 4d25f1ed_2ddc7985
Bytes: 105
Currently we don't but I thought we might want to switch the entrypoint allocator in the earlier designs.

File: runtime/arch/quick_alloc_entrypoints.cc

60:0-60:6
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0d7db99f_a93e053b
Bytes: 167
I assume this default value kAllocatorTypeDLMalloc isn't used at all, that is, it's always overwritten via the ChangeCollector() call from Heap::Heap(). Is this right?

60
Tue Jan 07 23:04:26 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0d7db99f_a93e053b
UUID: 4d25f1ed_0d0a553b
Bytes: 73
Yes, there just needs to be a default, even if its overridden right away.

File: runtime/entrypoints/entrypoint_utils.cc

86:0-86:2
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8dd609da_9a2811b3
Bytes: 60
Mention the allocator_type change issue here (leave a TODO)?

86
Tue Jan 07 23:04:26 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8dd609da_9a2811b3
UUID: 4d25f1ed_4d560d1e
Bytes: 4
Done

File: runtime/entrypoints/entrypoint_utils.h

82:0-82:4
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8dd609da_a512966b
Bytes: 395
In the comment, can you elaborate on the allocator change issue while the entry point is ongoing with regard to the collector transition issue and the ResolveType(), EnsureInitialized() which may cause the thread to be suspended?

As we discussed in the in-person conversation, it'd be nice if we can avoid the need to check the allocator change here, or do it in a cleaner way. Any better idea?

82
Tue Jan 07 23:04:26 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8dd609da_a512966b
UUID: 8d2b69c2_2ffe2d53
Bytes: 4
Done

106:0-106:4
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4d25f1ed_473c2ea7
Bytes: 137
Would it be worth checking allocator_type != heap->GetCurrentAllocator() before calling heap->AllocObject(), rather than falling through?

106
Tue Jan 07 23:04:26 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4d25f1ed_473c2ea7
UUID: 8d2b69c2_4f26014c
Bytes: 17
Shouldn't matter.

107:0-107:4
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0d7db99f_29075575
Bytes: 191
Why the asymmetry, calling Heap::AllocObject() (as opposed to calling Class::Alloc() with the current allocator here while calling Array::Alloc() with the current allocator below in line 165?

107
Tue Jan 07 23:04:26 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0d7db99f_29075575
UUID: 4d25f1ed_6d5b1135
Bytes: 4
Done

File: runtime/entrypoints/portable/portable_alloc_entrypoints.cc

23:0-23:9
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2d80bdc3_4504f42d
Bytes: 24
Can we make this static?

23
Tue Jan 07 23:04:26 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2d80bdc3_4504f42d
UUID: 8d2b69c2_4fa9e12f
Bytes: 4
Done

File: runtime/gc/collector/garbage_collector.cc

87:0-87:6
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8dd609da_e58bbe52
Bytes: 105
In what call path does this case (the mutator lock is already exclusively held) happens? Leave a comment?

87
Tue Jan 07 23:04:26 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8dd609da_e58bbe52
UUID: 4d25f1ed_6dadd1b5
Bytes: 4
Done

File: runtime/gc/collector/mark_sweep.cc

1131:0-1131:2
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0d7db99f_84e1b045
Bytes: 231
In the old code, the allocation stack space used to be temporarily reused as a buffer passed to FreeList(). In the new code, we use this separate stack-allocated buffer. There's no noticeable performance loss due to this, I assume?

1131
Tue Jan 07 23:04:26 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0d7db99f_84e1b045
UUID: 8d2b69c2_2fe46d94
Bytes: 38
I didn't measure any performance loss.

1141:0-1141:4
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0d7db99f_a94fe5a5
Bytes: 58
Does this if statement filter out the bump pointer spaces?

1141
Tue Jan 07 23:04:26 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0d7db99f_a94fe5a5
UUID: ad266df6_106eec1b
Bytes: 16
Fixed in new CL.

1187:0-1187:2
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8dd609da_85cf529b
Bytes: 368
In the new code, we iterate over 'objects' (the allocation stack) three times, once for each of the alloc spaces (dlmalloc and rosalloc ones) and once for the large object space (IIUC), as opposed to once in the old code. Is there a rationale for this? Would it make sense to swap the inner/outer loops so that we iterate over the allocation stack iteration loop once?

1187
Tue Jan 07 23:04:26 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8dd609da_85cf529b
UUID: 8d2b69c2_cffe711b
Bytes: 505
Without hardcoding the maximum number of allocation spaces, the approach of iterating over the spaces for each reference would be significantly slower than the current approach. In the new CL i make sure the spaces are sorted in the manner that the spaces most likely to contain more references are processed first. Keep in mind that references get deleted from the stack once we have found a space which contains them. So the allocation stack should get smaller each iteration. Added a few more comments.

File: runtime/gc/collector/semi_space.cc

103:0-103:6
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0d7db99f_e402e4d0
Bytes: 664
Is it the case that to_space_ can point to either one of the bump pointer spaces (normal case) or the rosalloc/dlmalloc space (which happens when the application goes from the background to the foreground)?

Would it make it a bit cleaner if it was structured like:

if (space == to_space_ && space->GetLiveBitMap() != nullptr) {
  BindLiveToMarkBitmap(to_space_);
} else if (space->GetGcRetentionPolicy() == space::kGcRetentionPolicyNeverCollect
          || space->GetGcRetentionPolicy() == space::kGcRetentionPolicyFullCollect) {
  ImmuneSpace(space);
}

as whether a space has a non-null live bitmap could be independent of whether to call ImmuneSpace() on it?

228:0-228:2
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8dd609da_859e724c
Bytes: 55
Is there a reason not to use uint64_t instead int here?

228
Tue Jan 07 23:04:26 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8dd609da_859e724c
UUID: 4d25f1ed_cd7cbd45
Bytes: 78
I was just matching the return types, might as well change to uint64_t though.

237:0-237:2
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2d80bdc3_e5e8a09d
Bytes: 85
What happens if the freed bytes is negative? Would it be ok in terms of RecordFree()?

237
Tue Jan 07 23:04:26 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2d80bdc3_e5e8a09d
UUID: ad266df6_d3929e83
Bytes: 16
Its handled now.

357:0-357:10
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2d80bdc3_05efdc9c
Bytes: 269
I believe this is necessary when we switch from background (bump pointer) to foreground (free list). Is there a reason not to call GetLiveBitmap() on the to-space and to instead store (cache) the live bitmap object in to_space_live_bitmap_ other than a performance one?

357
Tue Jan 07 23:04:26 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2d80bdc3_05efdc9c
UUID: 4d25f1ed_0d709564
Bytes: 62
This is only an optimization to avoid a virtual function call.

File: runtime/gc/collector/semi_space.h

269:0-269:2
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0d7db99f_848770fc
Bytes: 167
Can you leave a short comment/note on what this to_space_ and from_space_ could point to in what situations, such as a bump pointer space or a rosalloc/dlmalloc space?

269
Tue Jan 07 23:04:26 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0d7db99f_848770fc
UUID: 8d2b69c2_d20f3a44
Bytes: 15
Added comments.

270:0-270:2
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2d80bdc3_a5fce88c
Bytes: 85
Why do we keep this live bitmap here outside of the space itself (is it performance)?

270
Tue Jan 07 23:04:26 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2d80bdc3_a5fce88c
UUID: ad266df6_f3c7e27d
Bytes: 14
Added comment.

File: runtime/gc/heap-inl.h

60:8-60:10
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2d80bdc3_e58d00d9
Bytes: 95
Same comment as the quick entrypoint code. It'd be nice if we can avoid the need to check this.

60
Tue Jan 07 23:04:26 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2d80bdc3_e58d00d9
UUID: ad266df6_1319d65c
Bytes: 3
Yes

145:0-145:8
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2d80bdc3_c5fec41b
Bytes: 157
Just paraphrasing to confirm, as rosalloc_space_ is of type RosAllocSpace rather than type MallocSpace this call can be inlined without the reinterpret_cast.

145
Tue Jan 07 23:04:26 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2d80bdc3_c5fec41b
UUID: ad266df6_73adb2b5
Bytes: 3
Yes

146:0-146:8
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2d80bdc3_0574bc14
Bytes: 71
Move DCHECK above line 145 (a minor point)?

Same comment for line 156.

146
Tue Jan 07 23:04:26 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2d80bdc3_0574bc14
UUID: ad266df6_53b22e15
Bytes: 4
Done

File: runtime/gc/heap.cc

292:5-292:9
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0d7db99f_8a19b75e
Bytes: 189
Typo: TOOD -> TODO.

Also, if we suspend the threads here, could we get rid of the code that checks/detects that the allocator has changed in the quick alloc entry point path (I guess not)?

292
Tue Jan 07 23:04:26 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0d7db99f_8a19b75e
UUID: ad266df6_b350caef
Bytes: 152
I think I'll just delete the TODO since we suspend threads in UpdateProcessState. And no we couldn't get rid of the checks in the allocator entrypoints.

335:0-335:4
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0d7db99f_ea75cb5b
Bytes: 70
This function gets called asynchronously with regard to the GC, right?

335
Tue Jan 07 23:04:26 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0d7db99f_ea75cb5b
UUID: ad266df6_f34a423d
Bytes: 70
Yes, it can get called at any point, including when the GC is running.

344:4-344:26
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0d7db99f_2ad4232c
Bytes: 67
Why trigger a collection here when the process state didn't change?

344
Tue Jan 07 23:04:26 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0d7db99f_2ad4232c
UUID: 4d25f1ed_edfb815a
Bytes: 24
Saves a bit more memory.

386:0-386:2
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0d7db99f_2a0983f5
Bytes: 288
Isn't it the case that only one of rosalloc_space_ and dlmalloc_space_ is not null? If so, we don't need to pass two live bitmaps to MarkAllocStack (and avoiding adding a new parameter to it)? Or, is this meant to be general enough to be able to handle two non-null distinct live bitmaps?

386
Tue Jan 07 23:04:26 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0d7db99f_2a0983f5
UUID: ad266df6_53f50eab
Bytes: 91
No, they can both be non-null. I might end up deleting the allocation stacks in the future.

908:0-908:4
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2d80bdc3_45d4f4d3
Bytes: 27
int64_t instead of int32_t?

908
Tue Jan 07 23:04:26 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2d80bdc3_45d4f4d3
UUID: 8d2b69c2_f2951e6e
Bytes: 4
Done

1145:2-1145:4
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0d7db99f_0af5a739
Bytes: 113
To reduce the indentation level, how about doing:

if (collector_type == collector_type_) {
  return;
}

instead?

1145
Tue Jan 07 23:04:26 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0d7db99f_0af5a739
UUID: 8d2b69c2_725bee34
Bytes: 4
Done

1153:0-1153:4
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8dd609da_061fe86e
Bytes: 130
The code in StartGC() already existed and worked, but I wonder why we need to busy-wait here. Is there a way to simply block-wait?

1153
Tue Jan 07 23:04:26 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8dd609da_061fe86e
UUID: ad266df6_53bfceb3
Bytes: 123
StartGC doesn't block since we don't want to block the GC thread if we have gc disabled due to a GetPrimitiveArrayCritical.

1162:29-1162:44
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0d7db99f_ca9a4fdb
Bytes: 157
rosalloc_space_ could be null here. Maybe move this Compact() call below after main_space is set and pass main_space instead? Test with kUseRosAlloc = false?

1162
Tue Jan 07 23:04:26 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0d7db99f_ca9a4fdb
UUID: ad266df6_7393f245
Bytes: 4
Done

1185:45-1185:52
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0d7db99f_4a615f20
Bytes: 84
nit: we don't need to initialize it to nullptr as it'll be overwritten anyway below?

1185
Tue Jan 07 23:04:26 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0d7db99f_4a615f20
UUID: 8d2b69c2_32ca168d
Bytes: 4
Done

1337:0-1337:2
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8dd609da_a6129c6b
Bytes: 323
This is communicated in person, but if kUseRosAlloc is false (we use dlmalloc), then this code would overwrite the new main space (after the zygote fork) with the newly-created non-moving space here. The fix, as we discussed, is to not overwrite dlmalloc_space_ here and store the new non-moving space to non_moving_space_.

1337
Tue Jan 07 23:04:26 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8dd609da_a6129c6b
UUID: ad266df6_33821aee
Bytes: 16
Fixed in new CL.

File: runtime/gc/heap.h

95:43-95:54
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8dd609da_450deac7
Bytes: 60
allocations -> allocator (to be consistent with the others)?

95
Tue Jan 07 23:04:26 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8dd609da_450deac7
UUID: 4d25f1ed_8d8ac5bd
Bytes: 4
Done

485:24-485:40
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ad266df6_0a887bc1
Bytes: 82
nit: Is name GetRosAllocSpace() better as it matches the class name RosAllocSpace?

485
Tue Jan 07 23:04:26 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ad266df6_0a887bc1
UUID: ad266df6_336b3a7e
Bytes: 4
Done

File: runtime/runtime.cc

384:5-384:7
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ad266df6_4ac553d9
Bytes: 56
I think "is" is missing. Either add "is" or remove "it"?

384
Tue Jan 07 23:04:26 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ad266df6_4ac553d9
UUID: 8d2b69c2_b250c6ef
Bytes: 4
Done

File: runtime/utils.cc

441:0-441:3
Tue Jan 07 01:56:05 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4d25f1ed_a7a6cad7
Bytes: 99
Would it be worth keeping the size_t version as well in case we really want unsigned 64-bit size_t?

441
Tue Jan 07 23:04:26 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4d25f1ed_a7a6cad7
UUID: 8d2b69c2_92d66211
Bytes: 39
Probably not, 63 bits should be enough.

