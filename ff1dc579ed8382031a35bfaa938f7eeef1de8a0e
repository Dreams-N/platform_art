Revision: ff1dc579ed8382031a35bfaa938f7eeef1de8a0e
Patch-set: 4
File: compiler/optimizing/code_generator_arm.cc

2579
Wed Dec 17 11:13:06 2014 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a1204cdf_68b023d3
Bytes: 8
Atomic ?

2590
Wed Dec 17 11:13:06 2014 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a1204cdf_48b55fc1
Bytes: 5
ditto

2618:0-2620:52
Tue Dec 16 22:36:07 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 017758c2_33b588c2
Bytes: 52
Why not passing the FieldInfo to avoid these checks?

2630:17-2630:93
Tue Dec 16 22:36:07 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 217a9caa_94b9e4eb
Bytes: 32
Maybe add a is_wide local above.

2631:0-2631:64
Tue Dec 16 22:36:07 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 217a9caa_f4acd8aa
Bytes: 42
But not for thumb?? How did you test this?

2654:33-2654:51
Tue Dec 16 22:36:07 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 217a9caa_b4b660f9
Bytes: 19
Pass the FieldInfo?

2697:8-2697:29
Tue Dec 16 22:36:07 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 017758c2_d3b9b4bc
Bytes: 26
GenerateWideVolatileStore?

2697
Wed Dec 17 11:13:06 2014 +0000
Author: Serban Constantinescu <1030338@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 017758c2_d3b9b4bc
UUID: e1cb2464_a2989e84
Bytes: 344
I suggest renaming this to AtomicStore - to me volatile implies ordering guarantees, ldrexd and strexd only guarantee atomic updates. The dmb(s) do the ordering.

It gets even more confusing if you look at this and then at ARM64 load-acquire/store-release which are volatile load/ volatile store since they guarantee memory ordering constrains.

File: compiler/optimizing/code_generator_x86.cc

2753:0-2757:58
Wed Dec 17 05:44:53 2014 +0000
Author: Razvan Lupusoru <1054033@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e1588471_3acae1ae
Bytes: 257
1) Does the quick implementation match? If no, is the quick implementation actually atomic?

2) Are long fields guaranteed to be aligned on 64-bit boundary? Because I am not sure that it will be atomic otherwise in case of cache line split (even for movsd).

File: compiler/optimizing/nodes.h

2155:44-2155:48
Tue Dec 16 22:36:07 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 217a9caa_54a58cb9
Bytes: 165
Probably false for volatile fields? Within a method, can we optimize two loads of a volatile field into one, even if we can prove there is no side effect in between?

2155:44-2155:48
Wed Dec 17 05:44:53 2014 +0000
Author: Razvan Lupusoru <1054033@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 217a9caa_54a58cb9
UUID: 014af898_7bd45f53
Bytes: 442
Good catch. This should be false to express correct semantics. I believe we already should have art unit tests in which there is a volatile get of a terminating condition (I have seen Vmarko refer to this kind of case before).

Regarding your second questions, it makes sense that it should be possible. If there is any synchronization needed, it is up to programmer to set barrier in which case there should be some "side-effect" in between.

2696:7-2696:28
Tue Dec 16 22:36:07 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e1d164e3_32a4b0bb
Bytes: 126
Why this change? We are not going to merge two HMonitorOperations into one, so it doesn't make sense to implement this method.

