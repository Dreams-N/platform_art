Revision: e8e42f3548fd894f860912bb1b71ce6fa2d7daf3
Base-for-patch-set: 3
File: runtime/entrypoints/entrypoint_utils.cc

293:6-293:59
Tue Mar 10 15:12:23 2015 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1ccfcd73_e1f1c6e4
Bytes: 35
why isn't this a functional change?

293:6-293:59
Tue Mar 10 15:19:20 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1ccfcd73_e1f1c6e4
UUID: bcf161a4_91ff7eaa
Bytes: 69
Because the passed throw_location isn't used later in the call stack.

293:6-293:59
Tue Mar 10 16:02:54 2015 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: bcf161a4_91ff7eaa
UUID: 7ce9a9ce_bc2601e6
Bytes: 675
That's irrelevant, this throw location is not the same as the current method. Having the code now use the current method elsewhere on the call stack is a functional change, no? I can believe that there are bugs in this code, but it looks now that unboxed exception throwing will not report that the unboxing failure happened in the called proxy method but in the caller as determined by the current method.
Fwiw, the throw location existed to match JDWP APIs that may not yet have been implemented. It seems this change may need reversing were those to be implemented. I'm sure Seb has a fuller picture. The trick with the throw location was making sure it was robust for GC.

293:6-293:59
Tue Mar 10 16:05:41 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7ce9a9ce_bc2601e6
UUID: 5ce4e5f6_9b294bbb
Bytes: 352
Ian, the functional change is here: 
https://android-review.googlesource.com/#/c/139210/.

This change is just about removing the code leading to creating a ThrowLocation that is now unused.

I filed a bug for this. I'm sure if the test shows we're not behaving properly, we can workaround it without requiring a ThrowLocation for all the other places.

293:6-293:59
Tue Mar 10 16:18:49 2015 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 5ce4e5f6_9b294bbb
UUID: dcb1b5f2_d7dabc64
Bytes: 795
Agreed, it appears there is a lack of testing in the debugging and instrumentation with interaction with JDWP - is ART_TEST_TRACING being run (this covers the proxy tests) ? As I recall, the JDWP APIs allow you to do method and this object filtering. How can you retrieve a this object when the activation holding it has been removed? Stashing in the debugger is problematic due to differentiating re-throws from going up the call stack. That was the motivation for having the API, but the instrumentation link appears not to be present at least in this change. In this case we're severely faking the throw location in terms of the receiver object and the throwing method. As you say, if all the tests pass then everything must be good and I'm sure Seb is on top of the filtering implementation.

293:6-293:59
Tue Mar 10 16:29:36 2015 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dcb1b5f2_d7dabc64
UUID: bcc88176_56c79492
Bytes: 386
I added extra JDWP tests for the throw location (including throwing from native). As you said, The 'this' object is for Instance filtering. I can add extra tests there too to ensure we report the object properly.

I believe the proxy invoke change can be tested with a run-test by checking the 1st element in the stack trace of the exception references the proxy method, not the caller.

File: runtime/runtime.cc

1019:26-1019:42
Tue Mar 10 15:12:23 2015 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1ccfcd73_611936ac
Bytes: 35
why isn't this a functional change?

