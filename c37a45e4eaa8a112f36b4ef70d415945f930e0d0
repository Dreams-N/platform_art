Revision: c37a45e4eaa8a112f36b4ef70d415945f930e0d0
Patch-set: 1
File: compiler/optimizing/intrinsics_arm64.cc

1799:32-1799:39
Thu Jun 02 17:29:23 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 79e3ad4a_61a556ab
Bytes: 37
Can LDP/STP use an unaligned address?

1799:32-1799:39
Fri Jun 03 08:56:04 2016 +0000
Author: Scott Wakeling <1076052@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 79e3ad4a_61a556ab
UUID: c6f6769d_6be5c1e9
Bytes: 1432
Yes.

ARMv8 supports unaligned data accesses to Normal memory by LDP/STP.

Software can control whether a misaligned access to Normal memory by one of these instructions causes an Alignment fault Data Abort exception:

  - When executing at PL0 or PL1, by setting bit [1] in the System Control Register (SCTLR.A).
  - When executing at EL2, by setting bit [1] in the Hyp System Control Register (HSCTLR.A).

We think it's safe to assume, in this case, this won't happen. What do you think?

In general, the cost of an unaligned LDP/STP is an extra cycle in the issue stage. Exceptions that may incur a further penalty are load operations that cross a cache line boundary, or store operations that cross a 16-byte boundary. These may reduce bandwidth or incur additional latency. The benchmark we've quoted performance improvements from in this patch's commit message trigger both these cases with significant gain over what's currently committed.

LDRD/STRD instructions on ARM *do* fault on non-WORD aligned addresses. We felt the additional code required to check and correct such misaligned addresses belonged more in an optimized routine meant for handling larger workloads than in an intrinsic that is inlined so often and which has the more common use case of working with shorter runs of memory. So on ARM we elected not to use LDRD/STRD, and on ARM64 we chose to take the performance gain from the simpler code you see here.

1803
Fri Jun 03 10:22:22 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 66530a56_1819e5c9
Bytes: 406
The loop is not exactly optimal, it contains one extra CMP+Bcc. What about

    SUBS    num_chr, #8
    BLT     remainder_preheader
  loop:
    LDP ...
    SUBS    num_chr, #8
    STP ...
    BHS     loop
  remainder_preheader:
    ADDS    num_chr, #8
    BEQ     done
  remainder:
    LDRH ...
    SUBS    num_chr, #1
    STRH ...
    BNE     remainder
  done:

(This also handles num_chr == 0 correctly.)

1803
Fri Jun 03 10:28:03 2016 +0000
Author: Scott Wakeling <1076052@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 66530a56_1819e5c9
UUID: 66530a56_9824d5fc
Bytes: 39
I'll give this a try and benchmark it..

1805
Fri Jun 03 10:22:22 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 66530a56_d8476db0
Bytes: 48
You're not handling num_chr == 0 correctly here.

1805
Fri Jun 03 10:28:03 2016 +0000
Author: Scott Wakeling <1076052@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 66530a56_d8476db0
UUID: 66214ae2_c8ecafcc
Bytes: 162
getCharsNoCheck can't be called with num_chr == 0, getChars throws IndexOutOfBoundsException first.

num_chr == 0 coming out of &loop is handled by the B(eq, ..).

1805
Fri Jun 03 10:36:02 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 66214ae2_c8ecafcc
UUID: 66530a56_387f89cd
Bytes: 263
getCharsNoCheck() _can_ be called with srcBegin==srcEnd. For the latest version refer to https://android-review.googlesource.com/234690 . (And thanks for bringing my attention to the getCharsNoCheck(), otherwise I wouldn't have found the deficient bounds checks.)

