Revision: efdda7569c16e3ecb1d511a123672f668c63c61b
Patch-set: 3
File: runtime/thread-inl.h

81:0-85:3
Mon Jun 29 23:37:22 2015 +0000
Author: Man Cao <1073545@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 934c958c_a41837a4
Bytes: 170
Is this part necessary for correctness (i.e. a thread will pass the barrier in a bounded time), or it's just for performance (i.e. a thread will pass the barrier sooner)?

81:0-85:3
Tue Jun 30 07:49:42 2015 +0000
Author: Yu L Li <1039961@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 934c958c_a41837a4
UUID: 133a65f6_a3b9a437
Bytes: 2233
I think this check is necessary for SetStateUnsafe. The proposed SuspendAll mechanism works as follows:
1) SuspendAllInternal (should*) ensure that all required threads suspended.
2) Grabbing the mutator_lock_ exclusively ensures that only one SuspendAll would return.

In 1), the SuspendAllInternal will wait for all required threads in kRunnable to pass barrier themselves. There are three portals in ART for a thread to exit the kRunnable state: TransitionFromRunnableToSuspended, SetState and SetStateUnsafe. The pass barrier request should be checked in all these portals.

There are some unsafe thread state changes in ART. Debugger thread could be set to kRunnable when the SuspendAllInternal in GC thread sees it.

Here is an execution sequence where I think the SuspendAllInternal in GC thread might starve (if the pass barrier request is not checked in SetStateUnsafe):

Debugger thread SuspendAll -> Debugger thread changes into kRunnable (by SetStateUnsafe) -> GC thread SuspendAllInternal -> Debugger thread changes back to Suspended (without passing the barrier) -> GC thread starved...

*Also after 1) but before 2), the Debugger thread might be in kRunnable for a short period of time (set by the SetStateUnsafe). But the proposed SuspendAll mechanism is still correct because,

a. SetStateUnsafe to kRunnable is always guarded by the exclusive mutator_lock_. When the SuspendAll returns (hold the mutator_lock_ exclusively), threads cannot be set to kRunnable by SetStateUnsafe.
b. SetState cannot set the state to kRunnable.
c. TransitionFromSuspendedToRunnable needs to wait for the suspend count -1 by ResumeAll.

After the SuspendAll, no threads could transit to kRunnable until the ResumeAll executes.

I will add a comment at the SuspendAllInternal to state that certain thread might change to kRunnable temporarily.

For SetState, if we could ensure that the original state cannot be the kRunnable in ART, no pass barrier check is needed. Currently, SetState will not be used to set the state from runnable to suspended in ART (suspended state -> suspended state in all places). But maybe we could keep the check here cause the SetState definition does not forbid setting the state from runnable to suspended?

81:0-85:3
Tue Jun 30 23:17:38 2015 +0000
Author: Man Cao <1073545@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 133a65f6_a3b9a437
UUID: 339be98e_e7e01611
Bytes: 464
Thanks for the explanation. Yes, I agree that the check in SetStateUnsafe is necessary to avoid the starvation in your example, and the exclusive mutator_lock_ in this case guarantees the safety. It's probably not a bad idea to remove SetStateUnsafe altogether.

For SetState, I think we can just put a CHECK_NE(old_state_and_flags.state, kRunnable) instead. The use of both SetState and SetStateUnsafe should be strictly restricted, they are both somewhat unsafe.

81:0-85:3
Wed Jul 01 03:04:18 2015 +0000
Author: Yu L Li <1039961@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 339be98e_e7e01611
UUID: d3760d12_a65b4601
Bytes: 4
Done

File: runtime/thread.cc

803:4-803:73
Mon Jun 29 23:37:22 2015 +0000
Author: Man Cao <1073545@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 132185e2_88b91738
Bytes: 36
AtomicSetFlag() does the same thing.

803:4-803:73
Tue Jun 30 07:49:42 2015 +0000
Author: Yu L Li <1039961@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 132185e2_88b91738
UUID: 53305d12_85846417
Bytes: 121
Here two flags (kSuspendRequest and kActiveSuspendBarrier) might be set simultaneously. AtomicSetFlag could only set one.

803:4-803:73
Tue Jun 30 23:17:38 2015 +0000
Author: Man Cao <1073545@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 53305d12_85846417
UUID: 5383fd1c_64f0668c
Bytes: 19
Yes, you are right.

817:0-822:5
Mon Jun 29 23:37:22 2015 +0000
Author: Man Cao <1073545@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 332a09c0_bd21b7d9
Bytes: 522
I think this part is the inner if check of a double-checked locking. All the callers to this function except SuspendAllInternal() would first check the kActiveSuspendBarrier flag without holding the thread_suspend_count_lock_. The race is that the suspender thread calling SuspendAllInternal() and the "this" thread could execute this function simultaneous, because SuspendAllInternal() would install the pass barrier for all non-ignored threads.

Probably it's more intuitive to comment about this double-checked locking?

817:0-822:5
Tue Jun 30 07:49:42 2015 +0000
Author: Yu L Li <1039961@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 332a09c0_bd21b7d9
UUID: f3d8713c_bfec3709
Bytes: 232
Yes, something like the double-checked locking. For already suspended threads, the barrier could be passed by SuspendAllInternal or TransitionFromSuspendedToRunnable. First do a quick check whether the barrier has been passed.
Done.

850:0-855:5
Mon Jun 29 23:37:22 2015 +0000
Author: Man Cao <1073545@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 53277df4_33dcda56
Bytes: 414
However, I don't think this is possible. Have you verified this can ever happen?

The check point function is only installed for runnable threads, and the thread requesting a check point would only execute the check point function for threads without the function installed. See Thread::RequestCheckpoint() and its callers.

Besides, the old CHECK(found_checkpoint) is not failing. So maybe change this to a CHECK?

850:0-855:5
Tue Jun 30 07:49:42 2015 +0000
Author: Yu L Li <1039961@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 53277df4_33dcda56
UUID: d3dfed21_1e2e0dce
Bytes: 30
Yes, this is impossible.
Done.

File: runtime/thread.h

970:0-974:5
Mon Jun 29 23:37:22 2015 +0000
Author: Man Cao <1073545@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 73f6419f_aed857e7
Bytes: 42
Same here. For correctness or performance?

970:0-974:5
Tue Jun 30 07:49:42 2015 +0000
Author: Yu L Li <1039961@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 73f6419f_aed857e7
UUID: 73a3a180_4c075355
Bytes: 53
For correctness. Details are in the SetState comment.

File: runtime/thread_list.cc

543:8-543:12
Mon Jun 29 23:37:22 2015 +0000
Author: Man Cao <1073545@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 53277df4_0a67db48
Bytes: 10
two spaces

543:8-543:12
Tue Jun 30 07:49:42 2015 +0000
Author: Yu L Li <1039961@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 53277df4_0a67db48
UUID: 53305d12_0578549f
Bytes: 4
Done

986:0-997:9
Mon Jun 29 23:37:22 2015 +0000
Author: Man Cao <1073545@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 934c958c_c1c685aa
Bytes: 80
These are the same as the code below, after the else block. Are these redundant?

986:0-997:9
Tue Jun 30 07:49:42 2015 +0000
Author: Yu L Li <1039961@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 934c958c_c1c685aa
UUID: 73a3a180_6c0c8f78
Bytes: 10
Yes, Done.

