Revision: d9ffd0dd7266f6a5e76f29d98dbe1a04f64cbb9b
Patch-set: 34
File: compiler/optimizing/register_allocator_graph_color.cc

73:38-73:44
Mon Aug 08 12:04:00 2016 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 79bc9b97_0aa93b29
Bytes: 124
Might be worth a short comment inside the branch that this means it was inserted so people don't have to open c++ reference.

85:27-85:39
Mon Aug 08 12:04:00 2016 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 99478f8f_bbf0a763
Bytes: 36
find(other) != adjacent_nodes_.end()

137:9-138:55
Mon Aug 08 12:04:00 2016 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 19239fed_a7dc0a3b
Bytes: 52
!Primitive::IsFloatingPointType(interval->GetType())

210
Mon Aug 08 12:04:00 2016 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 39b223c6_0833871a
Bytes: 122
So how exactly do you guarantee that this won't loop indefinitely in production? Should we have linear scan as a fallback?

225:6-225:28
Mon Aug 08 12:04:00 2016 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 79bc9b97_ea49478b
Bytes: 134
This seems expensive. Do you have to build it from scratch in each iteration? In how many iterations does this thing typically finish?

361:100-361:107
Mon Aug 08 12:04:00 2016 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 990eaf7b_c332d657
Bytes: 9
long line

557
Fri Aug 05 22:46:45 2016 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b977f3bf_fb57e0cd
Bytes: 183
Maybe a question for Nicolas. If it's not a slow path only safepoint, do we need to add to safepoints_ here? I thought live registers are only meaningful for slow path only safepoint.

835
Fri Aug 05 22:46:45 2016 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b977f3bf_5edda20d
Bytes: 60
Can you assert here that adjacent->GetInterval()->IsFixed()?

835
Fri Aug 05 22:56:04 2016 +0000
Author: Matthew Gharrity <1108540@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b977f3bf_5edda20d
UUID: b977f3bf_3e90e6ef
Bytes: 339
There are cases where a pre-colored interval is not "fixed". For example,  I split an interval just after a fixed register def and assign the parent interval a register, but the interval itself is not marked as fixed.
Perhaps I can clear this up in my next CL by changing adjacent->GetInterval()->HasRegister() to adjacent->IsPrecolored().

