Revision: d9ffd0dd7266f6a5e76f29d98dbe1a04f64cbb9b
Patch-set: 34
File: compiler/optimizing/register_allocator_graph_color.cc

73:38-73:44
Mon Aug 08 12:04:00 2016 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 79bc9b97_0aa93b29
Bytes: 124
Might be worth a short comment inside the branch that this means it was inserted so people don't have to open c++ reference.

73:38-73:44
Wed Aug 10 00:00:47 2016 +0000
Author: Matthew Gharrity <1108540@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 79bc9b97_0aa93b29
UUID: b927f349_bd26c320
Bytes: 31
I will add this to a future CL.

85:27-85:39
Mon Aug 08 12:04:00 2016 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 99478f8f_bbf0a763
Bytes: 36
find(other) != adjacent_nodes_.end()

85:27-85:39
Wed Aug 10 00:00:47 2016 +0000
Author: Matthew Gharrity <1108540@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 99478f8f_bbf0a763
UUID: b927f349_1d36d74d
Bytes: 31
I will add this to a future CL.

137:9-138:55
Mon Aug 08 12:04:00 2016 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 19239fed_a7dc0a3b
Bytes: 52
!Primitive::IsFloatingPointType(interval->GetType())

137:9-138:55
Wed Aug 10 00:00:47 2016 +0000
Author: Matthew Gharrity <1108540@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 19239fed_a7dc0a3b
UUID: b927f349_fd051b6c
Bytes: 43
Good catch; I'll rector this in my next CL.

210
Mon Aug 08 12:04:00 2016 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 39b223c6_0833871a
Bytes: 122
So how exactly do you guarantee that this won't loop indefinitely in production? Should we have linear scan as a fallback?

210
Wed Aug 10 00:00:47 2016 +0000
Author: Matthew Gharrity <1108540@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 39b223c6_0833871a
UUID: b927f349_5da52ffb
Bytes: 348
See the comment above the definition of kMaxGraphColoringAttemptsDebug. Essentially, if a coloring round fails, it is guaranteed that live intervals are split, which makes the interference graph sparser. We avoid trying to split the same intervals repeatedly (and thus looping forever) by making sure that we split long intervals before short ones.

225:6-225:28
Mon Aug 08 12:04:00 2016 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 79bc9b97_ea49478b
Bytes: 134
This seems expensive. Do you have to build it from scratch in each iteration? In how many iterations does this thing typically finish?

225:6-225:28
Wed Aug 10 00:00:47 2016 +0000
Author: Matthew Gharrity <1108540@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 79bc9b97_ea49478b
UUID: b927f349_bac0094b
Bytes: 131
Very few in practice: 90% of methods take 1 iteration, ~9% take 2, ~1% take 3, and I believe 6 iterations is the highest I've seen.

361:100-361:107
Mon Aug 08 12:04:00 2016 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 990eaf7b_c332d657
Bytes: 9
long line

361:100-361:107
Wed Aug 10 00:00:47 2016 +0000
Author: Matthew Gharrity <1108540@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 990eaf7b_c332d657
UUID: b927f349_1d9fb7a5
Bytes: 30
Good catch; fixing in next CL.

557
Fri Aug 05 22:46:45 2016 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b977f3bf_fb57e0cd
Bytes: 183
Maybe a question for Nicolas. If it's not a slow path only safepoint, do we need to add to safepoints_ here? I thought live registers are only meaningful for slow path only safepoint.

557
Fri Sep 02 11:44:01 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b977f3bf_fb57e0cd
UUID: 16fd3327_fee021bc
Bytes: 100
They're meaningful also for regular calls, where we need to know live callee-savee registers (IIRC).

557
Fri Sep 02 17:22:25 2016 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 16fd3327_fee021bc
UUID: 76ee6f74_473f4277
Bytes: 88
I found GetLiveRegisters()/SaveLiveRegisters() all seem to be related to slow path code.

557
Sat Sep 03 01:19:42 2016 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 76ee6f74_473f4277
UUID: 3642374d_d2a8a292
Bytes: 80
Ok, we need to generate stack maps so it's needed more than for slow path calls.

835
Fri Aug 05 22:46:45 2016 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b977f3bf_5edda20d
Bytes: 60
Can you assert here that adjacent->GetInterval()->IsFixed()?

835
Fri Aug 05 22:56:04 2016 +0000
Author: Matthew Gharrity <1108540@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b977f3bf_5edda20d
UUID: b977f3bf_3e90e6ef
Bytes: 339
There are cases where a pre-colored interval is not "fixed". For example,  I split an interval just after a fixed register def and assign the parent interval a register, but the interval itself is not marked as fixed.
Perhaps I can clear this up in my next CL by changing adjacent->GetInterval()->HasRegister() to adjacent->IsPrecolored().

