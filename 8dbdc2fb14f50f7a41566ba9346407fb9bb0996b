Revision: 8dbdc2fb14f50f7a41566ba9346407fb9bb0996b
Patch-set: 1
File: runtime/gc/heap.cc

410:65-412:81
Wed Aug 27 18:58:23 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 53ef61ff_2ac2536a
Bytes: 172
the code and the comment below don't match up. Why do we only check in the zygote case? dex2oat allocates objects like Strings, that may end up as large object allocations.

410:65-412:81
Wed Aug 27 19:47:34 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 53ef61ff_2ac2536a
UUID: 9333997e_28b90f61
Bytes: 196
This was derived from talking with mathieuc and basically up for review. Valgrind consistently gives us a non-moving space before the image space. If that can be fixed, I'd be fine with that, too.

410:65-412:81
Wed Aug 27 23:20:52 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 9333997e_28b90f61
UUID: 7321c530_62064cf2
Bytes: 450
I can see that we can skip this no-gap check if there is no image (eg dex2oat).

I don't see what the Valgrind case looks like. It's got an image, but the non-moving space comes before the image space? I don't see how that happens. Does it have a separate non-moving space (from the main space)? Can you clarify?

In any case, this check should be enabled as much as possible. Or else, we'd have a large object being treated as immune and a GC crash.

410:65-412:81
Wed Aug 27 23:27:53 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7321c530_62064cf2
UUID: 7321c530_a2fc644d
Bytes: 61
dex2oat has an image in the case that we're compiling an app.

410:65-412:81
Thu Aug 28 00:07:05 2014 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7321c530_62064cf2
UUID: 931c79fc_ba449181
Bytes: 232
Running dex2oat under valgrind, it consistently makes it so that the non_moving_space_ has a lower address then the image space, so CheckNoGaps triggers a check.

And yes, this was *with* an image, as I was trying to compile an app.

412
Thu Aug 28 00:43:05 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 931c79fc_ba449181
UUID: 7338e55c_950b94b8
Bytes: 231
With the current logic, the only time the compiler might attempt to immune the non moving space is if GSS is enabled. In this case separate_non_moving_space==true and hopefully we would have that the space is right after the image.

410:65-412:81
Thu Aug 28 00:55:07 2014 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 931c79fc_ba449181
UUID: 7321c530_a8c68350
Bytes: 950
If separate_non_moving_space is false in your dex2oat situation, the main space and the non-moving space are the same space, in which case we should allocate the main space right after the image, but to allocate the main space (main_mem_map_1) we use MapAnonymousPreferredAddress() which does not guarantee the result is at the specified address, instead of MapAnonymous() which does, as in:

267:  main_mem_map_1.reset(MapAnonymousPreferredAddress(kMemMapSpaceName[0], request_begin, capacity_,
268:                                         PROT_READ | PROT_WRITE, &error_str));

This seems a bug to me.

But I am not sure if separate_non_moving_space is false in your dex2oat situation. Can you instrument this function and see what the value separate_non_moving_space is (as well as, if you will, the result addresses of the MapAnonymousPreferredAddress() and MapAnonymous() which could be added to the error message of the LOG(FATAL) in line 417)?

