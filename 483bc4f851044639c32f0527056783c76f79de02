Revision: 483bc4f851044639c32f0527056783c76f79de02
Patch-set: 3
File: compiler/optimizing/nodes.h

1236:10-1236:20
Mon Jul 20 22:46:24 2015 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 383666c8_4fd22147
Bytes: 162
This seems surprisingly permissive.

If I have tmp1 = x; tmp2 = v; tmp3 = x;

where only v is volatile, is this enough to prevent the last load from reusing tmp1?

1236:10-1236:20
Mon Jul 20 23:10:09 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 383666c8_4fd22147
UUID: 185442e3_d932671d
Bytes: 561
It suffices for the cases where side effects is used (only potential write-read dependences)

Since a volatile read basically invalidates the "cache", we know that any prior write has a potential dependence with anything after at or after the volatile read. Likewise, since a volatile write flushes the "cache", we know that any subsequent read may depend on anything at or before that write.

If the fact that others may start using this in the wrong way worries you, I am happy to make this an All() instead in both cases. It won't have a very adverse affect.

1236:10-1236:20
Mon Jul 20 23:41:43 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 185442e3_d932671d
UUID: 0d0ec228_d78c1cc0
Bytes: 390
Actually you convinced me already :-)

For example

for (i ..) {
      a[i] = mVolatile;
      b[i] = mNormal
}

should not lift the mNormal out of the loop (which would be done with a "does mNormal depend on anything in the loop" query), since it could break the happens-before from another thread the writes mNormal and then mVolatile, to the read of of mVolatile and then read of mNormal

4277:10-4277:29
Mon Jul 20 22:46:24 2015 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 78429e31_eeb67f47
Bytes: 32
This handles monitor entry/exit?

4277:10-4277:29
Mon Jul 20 23:11:25 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 78429e31_eeb67f47
UUID: 185442e3_394a9378
Bytes: 66
monitor operations are handled by the MonitorOperation instruction

