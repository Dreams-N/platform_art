Revision: c767ba25cfb45b0995bc84140f26758413a414a3
Patch-set: 5
File: runtime/thread_list.cc

547:11-547:35
Thu Jul 09 00:46:03 2015 +0000
Author: Man Cao <1073545@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 9833d2f4_efd17d73
Bytes: 846
I think the failure can only happen if there are no more available slot for active_suspend_barriers[]. This is different from the spurious fail from Thread::RequestCheckpoint(), which could fail because of a CAS.

If there are no more available slot for active_suspend_barriers[], this while loop would spin wait holding the thread_suspend_count_lock_. Then no other threads can execute PassActiveSuspendBarriers(), because they also need to grab the thread_suspend_count_lock_. Would this be a deadlock? (I think ThreadList::RunCheckpoint() has a similar deadlock problem.)

Maybe this cannot happen because 3 slots for active_suspend_barriers[] are sufficient so that they cannot be full? And why? If this is the case, probably get rid of this while(true) loop and use a CHECK_NE(available_barrier, kMaxSuspendBarriers) in ModifySuspendCount()?

547:11-547:35
Mon Jul 13 23:01:50 2015 +0000
Author: Man Cao <1073545@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 9833d2f4_efd17d73
UUID: 187d22ed_4b10d988
Bytes: 81
I've added logics to handle this case by unlock, sleep and lock, in patch set #7.

