Revision: 004e4b0b5debace7bca2d977562c7d767684cc3d
Patch-set: 3
File: compiler/optimizing/instruction_simplifier_arm64.cc

261:23-263:23
Tue Feb 09 09:44:08 2016 +0000
Author: Alexandre Rames <1052304@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 1d729020_85d1e21d
Bytes: 109
We could still do the transformation in this case.
We would end up with MOV+BIC, which is as good as NOT+AND.

261:23-263:23
Tue Feb 09 13:47:03 2016 +0000
Author: Kevin Brodsky <1087715@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1d729020_85d1e21d
UUID: 1d729020_c5cbda67
Bytes: 267
Yes indeed. [Following offline discussion] Since it doesn't improve the code either in this case, we can leave it like that for now, until a later change that also applies the transformation to arm32 (in which case it is much simpler to always do the transformation).

261:23-263:23
Wed Feb 10 17:50:41 2016 +0000
Author: Artem Serov <1089808@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1d729020_c5cbda67
UUID: bd98a490_627bd651
Bytes: 363
Actually if we avoid checking '!hother->IsConstant()' we can gain performance in case when the constant can not be encoded as an immediate operand into AND instructions. If we don't switch to BitwiseNegated we will have 3 instructions:
 mov r0, #large_constant
 neg r2, r1
 and r0, r0, r2

With BitwiseNegated it will be:

 mov r0, #large_constant
 bic r0, r0, r1

