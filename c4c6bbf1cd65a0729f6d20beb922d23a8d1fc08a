Revision: c4c6bbf1cd65a0729f6d20beb922d23a8d1fc08a
Patch-set: 3
File: compiler/optimizing/load_store_elimination.cc

689:15-689:24
Mon Dec 14 17:58:18 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e59a7e77_d2a56424
Bytes: 86
It doesn't look right to have a Phi related method here. Probably you could rename it.

689:15-689:24
Mon Dec 14 18:10:15 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e59a7e77_d2a56424
UUID: 25673634_54c20cab
Bytes: 132
At first read this looks unsafe as you relax a condition that should be strict.

Wouldn't the proper fix be to not remove the store?

689:15-689:24
Mon Dec 14 18:15:01 2015 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 25673634_54c20cab
UUID: 4568aa02_b560c085
Bytes: 241
As i mentioned in the top-level message, the right way of fixing this is not having any aliasing. I'm working on that anyway... From LSE perspective, I'd add DCHECKs making sure that removing a set is safe, but i'll leave that up to mingyao.

689:15-689:24
Mon Dec 14 18:37:01 2015 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4568aa02_b560c085
UUID: 45db4a39_11527ce4
Bytes: 141
I am okay with doing that in a follow up CL, but I agree with Nicolas that ToPhiType is a bit of a misnomer if we are using this generically.

689:15-689:24
Mon Dec 14 19:35:13 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 45db4a39_11527ce4
UUID: 0593126b_8e4bbbab
Bytes: 583
I used to have a similar check on the store side so if there is possible type aliasing, I didn't eliminate the store. That check was removed due to the fact that I/F, J/D aliasing only happen for arrays. However as this bug showed there can still be int type aliasing, like between boolean and int (I was actually aware of this but somehow still removed the check).

The question is are we sure it's always safe to load as one integer type which is stored as a different integer type? To be on the safe side, we can always keep the store by calling KeepIfIsStore() if types mismatch.

