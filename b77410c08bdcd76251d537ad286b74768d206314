Revision: b77410c08bdcd76251d537ad286b74768d206314
Patch-set: 1
File: runtime/base/variant_map.h

274
Fri Dec 04 18:57:11 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 20a9e45f_e71adc55
Bytes: 220
Why? It's not using forwarding references here, so I thought decay was unnecessary?

I tried a few test cases with and without decay and it doesn't seem any different. Can you please share why this was causing a problem?

274
Fri Dec 04 19:17:57 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 20a9e45f_e71adc55
UUID: e030ac14_42fc1263
Bytes: 370
As noted above, this is really about avoiding type deduction from this argument.

The use case is when TValue is a Base* and you want to pass a Derived* and you'd have to explicitly cast it to Base* (or create a named variable to force the implicit conversion in a different context).

But it seems I'm not actually going to use this after all. Should I revert this bit?

274
Fri Dec 04 19:36:48 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e030ac14_42fc1263
UUID: 009dc025_0fb37556
Bytes: 1082
How would std::decay help?

As far as I know, std::decay doesn't make it decay into the base type, it just turns arrays/fp into pointers, removes the references and cv.

I suppose we could support that requested use-case, it would just mean more template parameters, probably something like:

  template <template <typename TValue> TKeyActual>, typename TValue>
  void Set(const TKeyActual<TValue>& key,
           const TValue& value,
           std::enable_if<std::is_same<TKeyActual<TValue>, TKey<TValue>>::type* = nullptr) {
     // unchanged implementation
  }

Or something like that (probably missing a few typenames), it would to enforce at compile-time that the key type belongs to this map and not some other key.

The reason I just didn't do that in the first place is because it makes the signature way more scary looking than it needs to be for most of the use-cases.

Happy to support it like that, we'd just want extra comments here not to scare people away.

-----
So we should probably either properly support Base/Derived (no decay) or just remove this decay only.

274
Fri Dec 04 19:55:42 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 009dc025_0fb37556
UUID: 00a4e085_c3e8f6a6
Bytes: 535
That completely misses the point. I want the TValue to be deduced from the "key" argument, never from the "value" argument. Deducing from each can lead to different TValue and thus to deduction failure. The std::decay<> serves purely to create a non-deduced context. That's why the

    // NOTE: In the absence of std::omit_from_type_deduction<T> use std::decay<T>.

After TValue is deduced from the "key" argument, the type of the "value" parameter is known and the "value" argument can be implicitly converted to that type if needed.

274
Fri Dec 04 21:24:26 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 00a4e085_c3e8f6a6
UUID: 80561044_b733a835
Bytes: 1485
Oh, I think I understand what this intended now, you likely wanted to use std::identity here (which they removed in the final C++11 draft).

By getting the type to the right of :: it will inhibit type deduction, so just std::remove_reference<TValue>::type is less invasive than decay and be enough.

   template <typename TValue>
   void Set(const TKey<TValue>& key,
            const std::remove_reference<TValue>::type& value)
   {
     ...
   }


The template-template approach I suggested would allow implicit conversions using the explicit constructor, so perhaps it's undesirable.

That being said we're most better off just putting an identity type trait into the detail namespace because remove_reference is still confusing since it does extra work. This way we can also document the intent better.

  namespace detail {
    // Use to suppress type deduction in a function argument
    // See std::identity for more background: 
    // http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1856.html#20.2.2 - move/forward helpers
    //
    // e.g. "template <typename X> void bar(identity<X>::type foo);
    // -> bar(5); // compilation error
    // ->  bar<int>(5); // ok
    template <typename T>
    struct identity {
      using type = T;
    };
  }

   template <typename TValue>
   void Set(const TKey<TValue>& key,
            const detail::identity<TValue>::type& value)  // never deduce TValue from typeof(value), deduce from typeof(key) instead
   {
     ...
   }

274
Mon Dec 07 12:39:39 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 80561044_b733a835
UUID: e0feec6e_d2b8e491
Bytes: 96
Added Identity<> to stl_util.h and cleaned up other places where I used std:decay<> in the past.

File: runtime/runtime.cc

440:14-440:21
Fri Dec 04 18:57:11 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e0842cce_f63628de
Bytes: 28
nit: document parameter name

440:14-440:21
Fri Dec 04 19:17:57 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e0842cce_f63628de
UUID: e0598c74_3a72e1ee
Bytes: 4
Done

449:21-449:39
Fri Dec 04 18:57:11 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 204d6487_786669d6
Bytes: 14
Why not const?

449:21-449:39
Fri Dec 04 19:17:57 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 204d6487_786669d6
UUID: 204e44ac_fc5fc94b
Bytes: 87
Runtime::Init() is calling ReleaseOrDefault() which is not const (and that's intended).

849:19-849:37
Fri Dec 04 18:57:11 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 20a9e45f_a762a4e7
Bytes: 232
Seeing as how it clobbers a ton of stuff with releases, this could be a regular lvalue reference. For speed we can use std::move to pass it to each downcall.

(It'll also make the diff smaller by not needing to change the -> to a .)

849:19-849:37
Fri Dec 04 19:17:57 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 20a9e45f_a762a4e7
UUID: 004940a4_db85b3ee
Bytes: 107
Or maybe rvalue-reference? That would make it clear that the caller should not use the old options anymore.

849:19-849:37
Fri Dec 04 19:36:48 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 004940a4_db85b3ee
UUID: 009dc025_ef5f29be
Bytes: 277
Well I don't think it matters too much if they use the old options anymore, with std::move it would be exactly the same performance.

If you want to force them to move then using only rvalue references is acceptable too.

Either way it would be more descriptive than a pointer.

File: runtime/runtime.h

122
Fri Dec 04 18:57:11 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 00486077_379da089
Bytes: 62
Is anything calling this, e.g. in a test or in a real program?

122
Fri Dec 04 19:17:57 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 00486077_379da089
UUID: 004940a4_1b90bb2f
Bytes: 107
Will be, see TODO comment at https://android-review.googlesource.com/#/c/184410/3/dex2oat/dex2oat.cc@1037 .

122
Fri Dec 04 19:36:48 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 004940a4_1b90bb2f
UUID: e0842cce_7693f87e
Bytes: 62
Sounds good, anything we need to touch in parsed_options_test?

