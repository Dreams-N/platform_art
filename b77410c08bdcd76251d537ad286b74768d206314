Revision: b77410c08bdcd76251d537ad286b74768d206314
Patch-set: 1
File: runtime/base/variant_map.h

274
Fri Dec 04 18:57:11 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 20a9e45f_e71adc55
Bytes: 220
Why? It's not using forwarding references here, so I thought decay was unnecessary?

I tried a few test cases with and without decay and it doesn't seem any different. Can you please share why this was causing a problem?

274
Fri Dec 04 19:17:57 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 20a9e45f_e71adc55
UUID: e030ac14_42fc1263
Bytes: 370
As noted above, this is really about avoiding type deduction from this argument.

The use case is when TValue is a Base* and you want to pass a Derived* and you'd have to explicitly cast it to Base* (or create a named variable to force the implicit conversion in a different context).

But it seems I'm not actually going to use this after all. Should I revert this bit?

274
Fri Dec 04 19:36:48 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e030ac14_42fc1263
UUID: 009dc025_0fb37556
Bytes: 1082
How would std::decay help?

As far as I know, std::decay doesn't make it decay into the base type, it just turns arrays/fp into pointers, removes the references and cv.

I suppose we could support that requested use-case, it would just mean more template parameters, probably something like:

  template <template <typename TValue> TKeyActual>, typename TValue>
  void Set(const TKeyActual<TValue>& key,
           const TValue& value,
           std::enable_if<std::is_same<TKeyActual<TValue>, TKey<TValue>>::type* = nullptr) {
     // unchanged implementation
  }

Or something like that (probably missing a few typenames), it would to enforce at compile-time that the key type belongs to this map and not some other key.

The reason I just didn't do that in the first place is because it makes the signature way more scary looking than it needs to be for most of the use-cases.

Happy to support it like that, we'd just want extra comments here not to scare people away.

-----
So we should probably either properly support Base/Derived (no decay) or just remove this decay only.

File: runtime/runtime.cc

440:14-440:21
Fri Dec 04 18:57:11 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e0842cce_f63628de
Bytes: 28
nit: document parameter name

440:14-440:21
Fri Dec 04 19:17:57 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: e0842cce_f63628de
UUID: e0598c74_3a72e1ee
Bytes: 4
Done

449:21-449:39
Fri Dec 04 18:57:11 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 204d6487_786669d6
Bytes: 14
Why not const?

449:21-449:39
Fri Dec 04 19:17:57 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 204d6487_786669d6
UUID: 204e44ac_fc5fc94b
Bytes: 87
Runtime::Init() is calling ReleaseOrDefault() which is not const (and that's intended).

849:19-849:37
Fri Dec 04 18:57:11 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 20a9e45f_a762a4e7
Bytes: 232
Seeing as how it clobbers a ton of stuff with releases, this could be a regular lvalue reference. For speed we can use std::move to pass it to each downcall.

(It'll also make the diff smaller by not needing to change the -> to a .)

849:19-849:37
Fri Dec 04 19:17:57 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 20a9e45f_a762a4e7
UUID: 004940a4_db85b3ee
Bytes: 107
Or maybe rvalue-reference? That would make it clear that the caller should not use the old options anymore.

849:19-849:37
Fri Dec 04 19:36:48 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 004940a4_db85b3ee
UUID: 009dc025_ef5f29be
Bytes: 277
Well I don't think it matters too much if they use the old options anymore, with std::move it would be exactly the same performance.

If you want to force them to move then using only rvalue references is acceptable too.

Either way it would be more descriptive than a pointer.

File: runtime/runtime.h

122
Fri Dec 04 18:57:11 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 00486077_379da089
Bytes: 62
Is anything calling this, e.g. in a test or in a real program?

122
Fri Dec 04 19:17:57 2015 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 00486077_379da089
UUID: 004940a4_1b90bb2f
Bytes: 107
Will be, see TODO comment at https://android-review.googlesource.com/#/c/184410/3/dex2oat/dex2oat.cc@1037 .

122
Fri Dec 04 19:36:48 2015 +0000
Author: Igor Murashkin <1021471@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 004940a4_1b90bb2f
UUID: e0842cce_7693f87e
Bytes: 62
Sounds good, anything we need to touch in parsed_options_test?

