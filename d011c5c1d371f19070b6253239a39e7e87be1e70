Revision: d011c5c1d371f19070b6253239a39e7e87be1e70
Patch-set: 2
File: runtime/interpreter/interpreter_goto_table_impl.cc

2390:29-2390:40
Fri Apr 25 09:40:35 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 65c57378_393d0fb3
Bytes: 39
Could you just check that a is kReturn?

2390:29-2390:40
Wed May 14 14:36:03 2014 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 65c57378_393d0fb3
UUID: aa26584d_b6c82658
Bytes: 288
I wrote it this way so the "if" is actually simplified by the compiler (after preprocessing). It does not seem to be the case if I use instruction flags: (Instruction::FlagsOf(Instruction::code) & kReturn) != 0" does not seem to be simplified to a constant expression so the "if" remains.

2390:29-2390:40
Thu May 15 08:05:04 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: aa26584d_b6c82658
UUID: 0a3da49e_ee803f3a
Bytes: 106
I see. Maybe add that as a comment, so this information does not get lost in a future refactoring/rewrite.

2390:29-2390:40
Thu May 15 09:12:31 2014 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0a3da49e_ee803f3a
UUID: 2a58a819_0f5bc50d
Bytes: 64
I'll address it in https://android-review.googlesource.com/94701

File: runtime/interpreter/interpreter_switch_impl.cc

53:12-53:16
Thu May 15 08:11:27 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4a531cfd_d0279ca3
Bytes: 43
What happens if a method just has a return?

53:12-53:16
Thu May 15 09:12:31 2014 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4a531cfd_d0279ca3
UUID: 4a531cfd_90b994de
Bytes: 250
We just do not get here. However, we CL https://android-review.googlesource.com/94334, we need to report DexPcChange events in RETURN if there is no listener for MethodExit events. I'm addressing this in https://android-review.googlesource.com/94701.

54:17-54:44
Fri Apr 25 09:40:35 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 65c57378_99441b2c
Bytes: 176
Could you get rid of that check with some refactoring? Move the switch to its own method, only do the check for the first instruction, and loop over the remaining instructions?

54:17-54:44
Thu May 01 00:06:10 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 65c57378_99441b2c
UUID: 0a292485_4e8f73aa
Bytes: 316
I agree. the original purpose was to play code layout games to see if we could trick GCC into actually doing -fthread-jumps. Wrt refactoring, should all of the instrumentation live in a different template specialization? For the threaded interpreter that's easier as it can be achieved by dorking the dispatch table.

54:17-54:44
Wed May 14 14:36:03 2014 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0a292485_4e8f73aa
UUID: 0a1cc41d_f9f593a7
Bytes: 675
I'm not sure moving the switch to its own method would be a good solution. It would make the code more complex, especially because of control flow (RETURN and exception). Note I'm not happy with this flag either. Maybe we could deal with it in a differrent way. I'm thinking about using function pointer but did not try that yet.

Wrt to template specialization, we could do this. However, a debugger can attach in the middle of the execution of a method so we'd need to transition from a non-debug specialization to a debug specialization when that happens (and the contrary too). Indeed, we do that in the threaded interpreter by switching dispatch table when that happens.

54:17-54:44
Thu May 15 08:11:27 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0a1cc41d_f9f593a7
UUID: 2a58a819_afc47976
Bytes: 67
Maybe the switch can stay here, but the loop be in a caller method?

54:17-54:44
Thu May 15 09:12:31 2014 +0000
Author: Sebastien Hertz <1029223@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2a58a819_afc47976
UUID: 2a58a819_cf40dd1b
Bytes: 180
I'm worried about splitting interpreter in two methods. Even with inlining, this could cause performance penalties. Maybe you have a more precise idea and I may not see your point.

