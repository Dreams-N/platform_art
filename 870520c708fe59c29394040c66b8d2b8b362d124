Revision: 870520c708fe59c29394040c66b8d2b8b362d124
Patch-set: 1
File: compiler/optimizing/intrinsics_mips.cc

1956
Tue Feb 16 17:22:56 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: bd82644f_f23468dc
Bytes: 143
Wouldn't a name like GenIsInfiniteOrNaN (so the prefix Gen) be a bit more in line with was is found in this and related files for such methods?

1956
Tue Feb 16 20:11:08 2016 +0000
Author: Chris Larsen <1071873@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: bd82644f_f23468dc
UUID: bd82644f_357c1abd
Bytes: 4
Done

1983:0-2012:25
Sat Feb 13 07:15:43 2016 +0000
Author: Alexey Frunze <1057043@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 5dbec8e3_d98cc6b6
Bytes: 557
Could be shorter and without branches.

Note that except for the sign, an infinity is a single value (with maximum exponent and zero mantissa). Only NaNs have millions and billions of encodings. So you can compare directly.

floats:

  mfc1    TMP, in
  li      AT, INF_FLOAT
  xor     TMP, TMP, AT
  sll     TMP, TMP, 1 # shift the sign out
  sltiu   out, TMP, 1

doubles:

  MoveFromFpuHi TMP, in
  li      AT, HIGH(INF_DOUBLE)
  xor     TMP, TMP, AT
  sll     TMP, TMP, 1 # shift the sign out
  mfc1    AT, in
  or      TMP, TMP, AT
  sltiu   out, TMP, 1

1983:0-2012:25
Tue Feb 16 17:22:56 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 5dbec8e3_d98cc6b6
UUID: fd7f7c1f_2cb29312
Bytes: 4
Done

1983:0-2012:25
Tue Feb 16 20:11:08 2016 +0000
Author: Chris Larsen <1071873@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 5dbec8e3_d98cc6b6
UUID: dd7ab832_713ab0ce
Bytes: 4
Done

2071:33-2071:49
Tue Feb 16 17:22:56 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dd255844_5329a465
Bytes: 263
I was actually thinking of lowering all isNaN(x) into x != x during simplification (so make it a handled as HIR case), since that would implement it for all architectures, and make it more subject to other compiler optimizations.

are there disadvantages to that?

2071:33-2071:49
Tue Feb 16 20:48:55 2016 +0000
Author: Chris Larsen <1071873@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dd255844_5329a465
UUID: 1d71b053_f310e8a4
Bytes: 423
I'm okay with that but what does that mean exactly? Does that mean that the intrinsics which are called out in the compiler/optimizing/intrinsics_*.cc files because place holders, and no corresponding intrinsics functions should be implemented by the machine specific code? For example the compiler/optimizing/intrinsics_*.cc show IntegerCompare, LongCompare, IntegerSignum, and LongSignum as "Handled as HIR instructions."

2071:33-2071:49
Tue Feb 16 21:04:33 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 1d71b053_f310e8a4
UUID: bd1d04f9_1a333dd8
Bytes: 362
Yes, intrinsics that are marked as "Handled as HIR instructions" are already lowered into HIR during simplification. I am in fact going to make another macro that checks we never reach these (so we will have UNIMPLEMENTED_INTRINSIC and UNREACHED_INTRINSIC).

Mips implements a few intrinsics that are always lowered to HIR, so that code is esssentially dead now.

2071:33-2071:49
Tue Feb 16 21:10:29 2016 +0000
Author: Chris Larsen <1071873@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: bd1d04f9_1a333dd8
UUID: 1d71b053_132814c8
Bytes: 174
Is that why you also replied "Done" to Alexey's comment about simplifying the "isInfinite" code to avoid the branch? Are you also, thinking of handling that at the HIR level?

