Revision: 029c6dbc0432a4f5b66041d9c12f1faa601688e2
Patch-set: 2
File: /COMMIT_MSG

9:51-10:10
Thu Dec 18 10:58:47 2014 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 61765414_e68ffe35
Bytes: 19
and long operations

9:51-10:10
Thu Dec 18 12:58:42 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 61765414_e68ffe35
UUID: 41731024_6530668a
Bytes: 4
Done

File: compiler/optimizing/inliner.cc

147:2-152:3
Thu Dec 18 10:58:47 2014 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 618d7444_0ed0ab0f
Bytes: 103
Maybe we could cache the result of RegisterAllocator::CanAllocateRegistersFor? (Perhaps in another CL.)

147:2-152:3
Thu Dec 18 11:03:32 2014 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 618d7444_0ed0ab0f
UUID: 41731024_45f36aaf
Bytes: 113
Not sure if it's worth bothering. Since currently we handle only 3 blocks it shouldn't be expensive to call this.

147:2-152:3
Thu Dec 18 11:23:08 2014 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 41731024_45f36aaf
UUID: 618d7444_aee957ba
Bytes: 361
Right, but a single block can still contain many instructions.  And short/simple methods may nevertheless be called often.  So this code could be run over and over gratuitously.

Actually, it may be even more interesting to cache the larger information "can (should?) this method be inlined?" (at least, the bits that only depend on the callee, not the caller).

147:2-152:3
Thu Dec 18 12:57:26 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 618d7444_aee957ba
UUID: 41731024_25366e89
Bytes: 211
Like Calin said, let's not bother about "can allocate registers for", especially since it's a temporary method.

Caching whether a method is inlineable is in the TODO list (like control flow, method calls, ...).

