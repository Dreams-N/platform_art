Revision: ea6161db27c9d10d8ea2bd9784cd3010928eead1
Patch-set: 3
File: compiler/elf_writer_debug.cc

372
Fri Nov 20 16:31:34 2015 +0000
Author: Tamas Berghammer <1059813@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: db11db43_4ef87335
Bytes: 9
WriteName

372
Mon Nov 23 12:42:41 2015 +0000
Author: David Srbecky <1065473@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: db11db43_4ef87335
UUID: 9b7da3ef_e85b535f
Bytes: 37
Done.  (sorry, I missed it in rebase)

467
Fri Nov 20 16:31:34 2015 +0000
Author: Tamas Berghammer <1059813@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b67fde4b_d6db220f
Bytes: 60
Handle the case when a 64bit value is spread into 2 register

467
Mon Nov 23 12:42:41 2015 +0000
Author: David Srbecky <1065473@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b67fde4b_d6db220f
UUID: bbb8a7d5_99c07b00
Bytes: 4
Done

469
Fri Nov 20 16:31:34 2015 +0000
Author: Tamas Berghammer <1059813@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 9b8e83ee_346b28fa
Bytes: 74
(nit): You can use DW_OP_reg<n> for n < 32 to reduce the size of debug_loc

469
Mon Nov 23 12:42:41 2015 +0000
Author: David Srbecky <1065473@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 9b8e83ee_346b28fa
UUID: fb921f65_2b1ab9bb
Bytes: 4
Done

484
Fri Nov 20 16:31:34 2015 +0000
Author: Tamas Berghammer <1059813@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: db11db43_0e027be7
Bytes: 60
Handle the case when a 64bit value is spread into 2 register

484
Mon Nov 23 12:42:41 2015 +0000
Author: David Srbecky <1065473@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: db11db43_0e027be7
UUID: 9b7da3ef_48461f37
Bytes: 4
Done

501
Fri Nov 20 16:31:34 2015 +0000
Author: Tamas Berghammer <1059813@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: db11db43_eefe271f
Bytes: 67
You can use DW_OP_implicit_value instead of a full dwarf expression

501
Mon Nov 23 12:42:41 2015 +0000
Author: David Srbecky <1065473@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: db11db43_eefe271f
UUID: fbbdbfca_7314a08e
Bytes: 192
Is there any difference?
I used implict_value in the first PS, but then I realized this is more compact and it does not have endian issues. (not that it matters, but just for my peace of mind)

501
Mon Nov 23 14:54:24 2015 +0000
Author: Tamas Berghammer <1059813@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: fbbdbfca_7314a08e
UUID: 5b77ab0e_665a2e33
Bytes: 276
I don't know about any difference. I thought using DW_OP_implicit_value will be more compact but after checking the spec I think the size difference is so small we shouldn't care (DW_OP_implicit_value will be always smaller or the same size as DW_OP_consts+DW_OP_stack_value).

501
Tue Nov 24 02:31:08 2015 +0000
Author: David Srbecky <1065473@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 5b77ab0e_665a2e33
UUID: 9b7da3ef_2ba3a5c3
Bytes: 506
Wouldn't it be expected for implicit_value to store the full 4 bytes of the constant?

Even if not, they both require 3 bytes minimum.  Nonetheless, the size is not really of concern.

The main reason I prefer stack_value is because it does not assume any endian.  (can we also assume little endian on host, for example?)

By the way, is this going to work for floats?  For example double constant is encoded as:
OP_consts 0x11223344 OP_stack_value OP_piece 4 OP_consts 0x55667788 OP_stack_value OP_piece 4

501
Tue Nov 24 12:06:07 2015 +0000
Author: Tamas Berghammer <1059813@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 9b7da3ef_2ba3a5c3
UUID: bbb8a7d5_f963375a
Bytes: 598
I don't know what is expected for implicit_value, but if you prefer the current implementation (because of clarity and endianness) I am fine with it. Most likely it will be cleaner.

For floats I think your example should work but I don't know if anybody ever tested it.

For endianness I think the dwarf should be emitted in target byte order (have to check the spec) and then the consumer should deal with the byte swapping if needed. If you want to be endian independent then you also have to be careful about the case when a 64 bit value is split into 2 register (which one is the lower/higher)

