Revision: 0d507d1e0441e6bd6f3affca3a60774ea920f317
Patch-set: 2
File: compiler/dex/quick/arm/call_arm.cc

362:0-362:41
Wed Mar 19 22:36:17 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dcca7990_1c3fd935
Bytes: 46
I think this is implied. No comment necessary.

399:46-399:47
Thu Mar 20 10:16:46 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dc26f94e_f3d31048
Bytes: 22
Why are we guaranteed?

399
Thu Mar 20 16:56:55 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dc26f94e_f3d31048
UUID: dc4d1911_6a1ce7c6
Bytes: 56
I guess its never guaranteed, but its pretty reasonable.

400:32-400:33
Thu Mar 20 10:16:46 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 5c904999_af62f9e7
Bytes: 88
I don't understand this comment. What's the relation between "enough space" and signals?

400:32-400:33
Thu Mar 20 12:17:48 2014 +0000
Author: Bill Buzbee <1001578@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 5c904999_af62f9e7
UUID: dc4d1911_af01a163
Bytes: 343
The point of this is to ensure that the thread's stack has sufficient space to allow the OS to drop down a sigcontext in the event a signal happens to arrive.  In the large frame case above, unless we move to using an altstack for signal delivery we can't be sure the stack will be valid so SP must be tested for overflow before being updated.

400:32-400:33
Thu Mar 20 12:31:43 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dc4d1911_af01a163
UUID: 5c904999_8f67f5a9
Bytes: 99
OK, thanks Bill for the explanation. What guarantees that the signal processing just requires 2 KB?

400:32-400:33
Thu Mar 20 12:49:44 2014 +0000
Author: Bill Buzbee <1001578@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 5c904999_8f67f5a9
UUID: 9c21e133_ad01b563
Bytes: 743
Because signal handlers are user-defined and thus could use an arbitrary amount of stack, we can't guarantee that sigcontext + handler's memory use will fit in 2K.  However, in that event the error would be in the user's signal handler (who probably ought to be using an altstack).  The runtime system, however, does have a responsibility to ensure that there is sufficient space for the OS to drop a sigcontext and at least begin execution of the user's handler.  If the user's handler blows through the stack once it starts running - not our problem.  The choice of 2K is somewhat arbitrary, but is plenty of room for sigcontext plus a simple handler.  It's also large enough that the vast majority of methods will fit in the fast pass case.

400:32-400:33
Thu Mar 20 16:46:19 2014 +0000
Author: Brian Carlstrom <1003723@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 9c21e133_ad01b563
UUID: 9c21e133_68162bd8
Bytes: 69
Would a choice of something like PTHREAD_STACK_MIN be less arbitrary?

400
Thu Mar 20 16:56:55 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 9c21e133_68162bd8
UUID: 3c30f57d_0adf6ba7
Bytes: 169
PTHREAD_STACK_MIN is 2 * page size, that would probably also work. Since the largest method frame in boot.oat/core.oat is only around 1k, it should cause no regressions.

