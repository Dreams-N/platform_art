Revision: 0d507d1e0441e6bd6f3affca3a60774ea920f317
Patch-set: 2
File: compiler/dex/quick/arm/call_arm.cc

362:0-362:41
Wed Mar 19 22:36:17 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dcca7990_1c3fd935
Bytes: 46
I think this is implied. No comment necessary.

399:46-399:47
Thu Mar 20 10:16:46 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: dc26f94e_f3d31048
Bytes: 22
Why are we guaranteed?

399
Thu Mar 20 16:56:55 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dc26f94e_f3d31048
UUID: dc4d1911_6a1ce7c6
Bytes: 56
I guess its never guaranteed, but its pretty reasonable.

399
Thu Mar 20 17:49:16 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dc4d1911_6a1ce7c6
UUID: dc26f94e_369896a7
Bytes: 168
Sorry the question was too generic. I was also wondering how we handle a call stack of methods that use "small enough" stack space? Or recursive calls on such a method?

399
Thu Mar 20 17:58:21 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dc26f94e_369896a7
UUID: 7c16eddd_bbad733b
Bytes: 730
If a frame is small then we needn't worry about going over the reserved region when it is created, so we manipulate SP directly and check for stack overflows there. This avoids a move in the common path, and a load in the slow path.
Note this optimization isn't done for MIPS, for Intel we only create frames this way. There are TODOs in this change to capture that we need to optimize MIPS and make x86 robust to the signal issue in the same way that ARM is.
That said, signals from outside the runtime shouldn't be delivered on Java stacks. The behavior will always be unpredictable - stack sizes vary between ART and Dalvik, and across Android releases. Robust signal handlers are best written to use an alternate signal stack.

399
Thu Mar 20 18:03:13 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7c16eddd_bbad733b
UUID: dc26f94e_b6dd8655
Bytes: 207
But doesn't that just kill the purposes of this optimization? By doing recursive calls on a method that fits that scheme, we'll end up not having the space we thought would be needed for the signal handling.

399
Thu Mar 20 18:11:53 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dc26f94e_b6dd8655
UUID: dc4d1911_951394e5
Bytes: 422
After the optimization, it still does the overflow check, we just have a SP which temporarily may be in the reserved region during the overflow check. We make sure to still have a small amount of space in the reserved region however since a signal could theoretically come in (though very unlikely). Recursive calls are handled since as soon as the SP goes into the reserved region since we get a stack overflow exception.

399
Thu Mar 20 18:24:57 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dc4d1911_951394e5
UUID: 9c864164_5425228e
Bytes: 77
OK, thanks! Maybe also adding this in the code as a comment might be helpful.

400:32-400:33
Thu Mar 20 10:16:46 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 5c904999_af62f9e7
Bytes: 88
I don't understand this comment. What's the relation between "enough space" and signals?

400:32-400:33
Thu Mar 20 12:17:48 2014 +0000
Author: Bill Buzbee <1001578@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 5c904999_af62f9e7
UUID: dc4d1911_af01a163
Bytes: 343
The point of this is to ensure that the thread's stack has sufficient space to allow the OS to drop down a sigcontext in the event a signal happens to arrive.  In the large frame case above, unless we move to using an altstack for signal delivery we can't be sure the stack will be valid so SP must be tested for overflow before being updated.

400:32-400:33
Thu Mar 20 12:31:43 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: dc4d1911_af01a163
UUID: 5c904999_8f67f5a9
Bytes: 99
OK, thanks Bill for the explanation. What guarantees that the signal processing just requires 2 KB?

400:32-400:33
Thu Mar 20 12:49:44 2014 +0000
Author: Bill Buzbee <1001578@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 5c904999_8f67f5a9
UUID: 9c21e133_ad01b563
Bytes: 743
Because signal handlers are user-defined and thus could use an arbitrary amount of stack, we can't guarantee that sigcontext + handler's memory use will fit in 2K.  However, in that event the error would be in the user's signal handler (who probably ought to be using an altstack).  The runtime system, however, does have a responsibility to ensure that there is sufficient space for the OS to drop a sigcontext and at least begin execution of the user's handler.  If the user's handler blows through the stack once it starts running - not our problem.  The choice of 2K is somewhat arbitrary, but is plenty of room for sigcontext plus a simple handler.  It's also large enough that the vast majority of methods will fit in the fast pass case.

400:32-400:33
Thu Mar 20 16:46:19 2014 +0000
Author: Brian Carlstrom <1003723@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 9c21e133_ad01b563
UUID: 9c21e133_68162bd8
Bytes: 69
Would a choice of something like PTHREAD_STACK_MIN be less arbitrary?

400
Thu Mar 20 16:56:55 2014 +0000
Author: Mathieu Chartier <1015378@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 9c21e133_68162bd8
UUID: 3c30f57d_0adf6ba7
Bytes: 169
PTHREAD_STACK_MIN is 2 * page size, that would probably also work. Since the largest method frame in boot.oat/core.oat is only around 1k, it should cause no regressions.

