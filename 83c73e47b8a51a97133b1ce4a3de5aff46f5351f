Revision: 83c73e47b8a51a97133b1ce4a3de5aff46f5351f
Patch-set: 3
File: compiler/optimizing/code_generator.h

680:0-681:56
Fri Jan 08 11:55:05 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: cae3c748_c749d214
Bytes: 292
As the type parameters `I` and `T` are constrained (`I` should be an instruction type, while `T` should be a slow path code type), I would give them more explicit names, e.g `InstructionType` and `SlowPathCodeType` respectively.

It would make some lines below (e.g. line 704) easier to read.

680:0-681:56
Fri Jan 08 20:08:25 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cae3c748_c749d214
UUID: 8a62afbe_57e54c22
Bytes: 4
Done

683:0-683:20
Fri Jan 08 11:55:05 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0a54ffaf_697e41be
Bytes: 26
Nit: template <typename I>

683:0-683:20
Fri Jan 08 20:08:25 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0a54ffaf_697e41be
UUID: 4a8b57a3_e06dbc09
Bytes: 4
Done

684
Fri Jan 08 11:55:05 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 6aa2db12_718b7206
Bytes: 155
What about adding this check:

  static_assert(std::is_base_of<HInstruction, I>::value,
                "I is not a subclass of art::HInstruction");

here?

684
Fri Jan 08 20:08:25 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6aa2db12_718b7206
UUID: 0a95dfbc_9ec7f91d
Bytes: 4
Done

686:0-686:17
Fri Jan 08 11:55:05 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: ca6e677a_0fb9c9ea
Bytes: 5
Drop?

686:0-686:17
Fri Jan 08 20:08:25 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ca6e677a_0fb9c9ea
UUID: aa5f73f8_5be737fc
Bytes: 4
Done

693:2-693:22
Fri Jan 08 11:55:05 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8a68ef71_aaff4fc9
Bytes: 21
template <typename T>

693:2-693:22
Fri Jan 08 20:08:25 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8a68ef71_aaff4fc9
UUID: 4a8b57a3_206884f6
Bytes: 4
Done

694
Fri Jan 08 11:55:05 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: cae3c748_27e23e2e
Bytes: 269
What about adding these checks:

    static_assert(std::is_base_of<SlowPathCode, T>::value,
                  "T is not a subclass of art::SlowPathCode");
    static_assert(std::is_constructible<T, I*>::value,
                  "T is not constructible from I*");

here?

694
Fri Jan 08 20:08:25 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cae3c748_27e23e2e
UUID: 0a95dfbc_beccb542
Bytes: 4
Done

696:65-697:17
Fri Jan 08 12:44:18 2016 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: cae3c748_67ec4620
Bytes: 541
Do you actually enforce this anywhere? From what I can tell it relies on the fact that no type `I` will ever generate slow paths of two different types `T` and that's not true. HInstanceOf on arm64 can already emit ReadBarrierForHeapReferenceSlowPathARM64 followed by TypeCheckSlowPathARM64. Neither of these has the required T(I*) constructor but it still looks like a dangerous implicit assumption. It would be safer to have `T` a template on the whole class but then you wouldn't be able to have the common InstructionCodeGenerator class.

696:65-697:17
Fri Jan 08 20:08:25 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cae3c748_67ec4620
UUID: 8a62afbe_7ab6b5fa
Bytes: 409
You said it. I originally wanted to template the whole class on both types, but because all slow paths are defined at arch level, that would result in horrible code duplication. This approach allows a generic class/method at the top with minimum changes in the arch specific code. But we lose the ability to have one instruction generate two slow path types indeed (but if time comes, that is doable as well).

696:65-697:17
Fri Jan 08 20:41:52 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8a62afbe_7ab6b5fa
UUID: ea65ebc4_3d37db20
Bytes: 216
I added an explicit run time test on the type found in the map, with a continue if there is a mismatch. That way, we allow future extensions where one instruction can have several slow path types (stored in one map).

696:65-697:17
Mon Jan 11 10:31:21 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8a62afbe_7ab6b5fa
UUID: ca4d875b_918c3c24
Bytes: 570
Note: we could reintroduce arch-specific abstract slow path classes for all back ends (SlowPathCodeARM, SlowPathCodeX86, etc.) and have concrete InstructionCodeGenerator* classes pass the right slow path type to their InstructionCodeGenerator super class:

  template <typename SlowPathType>
  class InstructionCodeGenerator : public HGraphVisitor {
    
    // ...
    
    SlowPathGenerator<HDeoptimize, SlowPathType> deopt_slow_paths_;
  };
  
  // ...
  
  class InstructionCodeGeneratorARM : public InstructionCodeGenerator<arm::SlowPathCodeARM64> {
    // ...
  };

696:65-697:17
Tue Jan 12 00:22:14 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ca4d875b_918c3c24
UUID: 07495aa4_fe069da4
Bytes: 256
But that would not account for several slow types types for one instruction for one back end. In any case, many ways of doing this are possible, but for now I tried to keep the CL as local as possible, with minimum changes in all the back end source trees.

702:11-702:69
Fri Jan 08 10:42:43 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2a2b8319_77860a3f
Bytes: 29
const auto& it : candidates
?

702:11-702:69
Fri Jan 08 20:08:25 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2a2b8319_77860a3f
UUID: aa5f73f8_3b37e320
Bytes: 4
Done

704:29-704:40
Fri Jan 08 11:55:05 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 6a31fb81_dca06564
Bytes: 9
down_cast

704:29-704:40
Fri Jan 08 20:08:25 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6a31fb81_dca06564
UUID: ea65ebc4_9a7b8d09
Bytes: 4
Done

719:4-719:67
Fri Jan 08 11:55:05 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4a2c372e_9bf2f3c1
Bytes: 73
Could we use

  iter->second.emplace_back(instruction, slow_path);

here?

719:4-719:67
Fri Jan 08 19:17:56 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4a2c372e_9bf2f3c1
UUID: ea65ebc4_fa5e49f9
Bytes: 4
Done

726:40-726:49
Fri Jan 08 11:55:05 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 6aa2db12_71625216
Bytes: 28
preamble? (or prerequisite?)

726:40-726:49
Fri Jan 08 20:08:25 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6aa2db12_71625216
UUID: 6a901bcb_1e892d4f
Bytes: 4
Done

727:7-727:12
Fri Jan 08 10:42:43 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0a54ffaf_89961d31
Bytes: 9
HaveSame?

727:33-727:35
Fri Jan 08 11:55:05 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 6aa2db12_b1d2faf6
Bytes: 8
const I*

727:39-727:40
Fri Jan 08 11:55:05 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8a68ef71_0a069ba4
Bytes: 5
const

727:26-727:28
Fri Jan 08 11:55:05 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0a54ffaf_49e7c5ce
Bytes: 8
const I*

727:33-727:35
Fri Jan 08 20:08:25 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6aa2db12_b1d2faf6
UUID: 0a95dfbc_9eea995a
Bytes: 4
Done

727:26-727:28
Fri Jan 08 20:08:25 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0a54ffaf_49e7c5ce
UUID: 0a95dfbc_7e178d31
Bytes: 4
Done

727:7-727:12
Fri Jan 08 20:08:25 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0a54ffaf_89961d31
UUID: 4a8b57a3_e0c13c09
Bytes: 4
Done

727:39-727:40
Fri Jan 08 20:08:25 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8a68ef71_0a069ba4
UUID: 6a79fb72_b6b22822
Bytes: 4
Done

737
Tue Jan 12 00:22:14 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 87562a44_9accc9e6
Bytes: 1
u

740:7-740:20
Fri Jan 08 10:42:43 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 6a31fb81_1c625d15
Bytes: 17
HaveSameStackMap?

740:34-740:35
Fri Jan 08 11:55:05 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 6aa2db12_f1dc820c
Bytes: 5
const

740:21-740:23
Fri Jan 08 11:55:05 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 6a31fb81_9cc18d0a
Bytes: 8
const I*

740:28-740:30
Fri Jan 08 11:55:05 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: eae08b3e_45893c4e
Bytes: 8
const I*

740:7-740:20
Fri Jan 08 20:08:25 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6a31fb81_1c625d15
UUID: 0a95dfbc_beef5569
Bytes: 4
Done

740:34-740:35
Fri Jan 08 20:08:25 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6aa2db12_f1dc820c
UUID: 0a95dfbc_def42140
Bytes: 4
Done

740:28-740:30
Fri Jan 08 20:08:25 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: eae08b3e_45893c4e
UUID: aa5f73f8_7b887b08
Bytes: 4
Done

740:21-740:23
Fri Jan 08 20:08:25 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 6a31fb81_9cc18d0a
UUID: 4a8b57a3_00c7081c
Bytes: 4
Done

763:68-763:72
Fri Jan 08 12:44:18 2016 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: cae3c748_87586adc
Bytes: 28
Nit: Less vague name please.

763:68-763:72
Fri Jan 08 20:08:25 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cae3c748_87586adc
UUID: 6a901bcb_7eb95101
Bytes: 4
Done

776:71-776:76
Fri Jan 08 10:42:43 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4a2c372e_1bd02321
Bytes: 11
missing "."

776:71-776:76
Fri Jan 08 20:08:25 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4a2c372e_1bd02321
UUID: 6a79fb72_36d8d873
Bytes: 4
Done

File: test/561-shared-slowpaths/src/Main.java

20:0-20:19
Fri Jan 08 10:42:43 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 2a2b8319_f799baa4
Bytes: 57
Please add checker tests that we only have one slow path.

20:0-20:19
Fri Jan 08 12:44:18 2016 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 2a2b8319_f799baa4
UUID: ca6e677a_cf3e5109
Bytes: 363
+1 because this doesn't actually show that any sharing is taking place. That said, the test would have to be more concise, or "unit" if you will, to get a case where the register maps are actually equal.

x86: first loop shared, second loop not
x86_64: two out of three shared in first loop, none in second loop
arm: two shared in first loop, all shared in second

20:0-20:19
Fri Jan 08 19:17:56 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: ca6e677a_cf3e5109
UUID: 0a95dfbc_7e5a2d7c
Bytes: 245
Yes, all good points. This test was aimed at testing correctness under sharing. I did not make this a checkers test because, as David correctly observed, sharing happens differently on different architectures.

Let me think about this a bit.....

20:0-20:19
Mon Jan 11 14:35:16 2016 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0a95dfbc_7e5a2d7c
UUID: 8a570fe9_af49d96b
Bytes: 259
Just an idea, but I wonder if you could squeeze out a bit more sharing out of this if you reorganized the instructions in the deopt block, specifically by moving the ALU instructions to the top. If so, it would make writing a platform-independent test easier.

20:0-20:19
Mon Jan 11 18:54:03 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8a570fe9_af49d96b
UUID: 67c69632_6e16cf9e
Bytes: 338
I actually played with that idea already. But making two Deopt instructions adjacent after dyn bce did not improve/force sharing (it resulted in "just as random" sharing on different architectures).

Would it be possible to do something during code generation (i.e. before doing a deopt, do some manipulations to make stack maps similar)?

20:0-20:19
Wed Jan 13 14:53:46 2016 +0000
Author: David Brazdil <1059815@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 67c69632_6e16cf9e
UUID: 27fc9e7c_cfe201ec
Bytes: 1851
Let's have a look. Here's the second deopt block for init() on x86:

  v123    ParallelMove
    mov esi, [esp + 72]
  z91     Equal [l9,l90]
  v92     Deoptimize [z91]
    test edx, edx
    jz/eq +169 (0x00000147)
  i52     ArrayLength [l9]
    mov edi, [edx + 8]
  v119    ParallelMove
    mov eax, esi
  i95     Sub [i17,i15]
    sub eax, ebp
  i96     Sub [i95,i37]
    sub eax, 1
  i97     Add [i96,i15]
    add eax, ebp
  z98     Above [i15,i97]
  v99     Deoptimize [z98]
    cmp ebp, eax
    jnbe/a +172 (0x0000015e)
  z100    AboveOrEqual [i97,i52]
  v101    Deoptimize [z100]
    cmp eax, edi
    jnb/ae/nc +187 (0x00000175)

The problem is that EAX (i97) is still live after v99 but not after v101. The spill set is therefore different and so are the locations of vregs in the stack map:

  DeoptimizationSlowPathX86
    mov [esp + 4], eax
    mov [esp + 8], ecx
    mov [esp + 12], edx
    mov [esp + 16], ebx
    call fs:[0x2c4]  ; pDeoptimize
      v1: in stack (8)
      v2: in stack (12)
      v3: in stack (16)

  DeoptimizationSlowPathX86
    mov [esp + 4], ecx
    mov [esp + 8], edx
    mov [esp + 12], ebx
    call fs:[0x2c4]  ; pDeoptimize
      v1: in stack (4)
      v2: in stack (8)
      v3: in stack (12)

The same thing happens in the first deopt block as well but the Add gets allocated to ESI which is callee-save so the spill set is the same and the slow paths are shared.

I see two ways how you can deal with this. You can spill the union of registers live across the shared slow paths, i.e. spill EAX for v101 too. That would work for any kind of slow path but it's wasteful. Or you can go the other way and leverage the fact that DeoptimizationSlowPath never returns and spill only caller-save registers mentioned in the stack map's dex register map, i.e. not spill EAX at v99 because it doesn't correspond to a vreg.

39:4-39:12
Fri Jan 08 11:55:05 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 8a68ef71_2a035f95
Bytes: 11
Nit: int z;

39:4-39:12
Fri Jan 08 19:17:56 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 8a68ef71_2a035f95
UUID: 8a62afbe_b7c868cf
Bytes: 4
Done

69:13-69:16
Fri Jan 08 11:55:05 2016 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: cae3c748_c71712d7
Bytes: 26
OOB? (And likewise below.)

69:13-69:16
Fri Jan 08 19:17:56 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cae3c748_c71712d7
UUID: 6a901bcb_3e87c982
Bytes: 4
Done

