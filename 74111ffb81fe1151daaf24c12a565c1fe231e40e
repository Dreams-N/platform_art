Revision: 74111ffb81fe1151daaf24c12a565c1fe231e40e
Patch-set: 3
File: compiler/optimizing/register_allocator.cc

104:7-104:9
Thu Oct 23 17:41:26 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f5359ed2_e6a8869a
Bytes: 40
I'm not sure I understand this sentence.

104:7-104:9
Thu Oct 23 23:05:27 2014 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f5359ed2_e6a8869a
UUID: b58de6f4_15b37ee1
Bytes: 942
Usually you would expect inactive intervals to be first moved from active set at some point, so the start of any inactive interval should be before the current interval being processed during linear scan, but it's inactive since it's in a hole at the current instruction position. Basically any interval starting after the current instruction is in unhandled set. I found it a little surprising during some debugging to see inactive intervals that start after the current instruction being processed. And I found those are fixed intervals, and they start in inactive set instead of unhandled. So I added some comment to make it clear. Or should it be stated with more clarity?

I saw some algorithm that adds fixed intervals to unhandled set first, so you don't need to process them (like doing intersecting with the current interval) until they really start. I think the way we do it is fine but just want to make it clear with some comment.

104:7-104:9
Fri Oct 24 14:54:56 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b58de6f4_15b37ee1
UUID: f5359ed2_c12c4c06
Bytes: 150
Oh I see. So should we move them to unhandled and then skip them in in the LinearScan loop?

That would make things consistent and unsurprising, WDYT?

104:7-104:9
Mon Oct 27 17:17:00 2014 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f5359ed2_c12c4c06
UUID: d5d6dada_2b4d1588
Bytes: 366
I thought a little more. Actually adding to inactive may generate better code since it tries to avoid assigning to a register that might be blocked later. Another way to think of fixed interval is it begins with a hole (even though its official start position is later). Then it makes sense it's in inactive first.
The statements in added comment are still accurate.

617:8-617:16
Fri Oct 24 14:54:56 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f5359ed2_81c404d0
Bytes: 116
So you're doing this to ensure all inactive pass the DCHECK line 611?

I think I'd prefer a dedicated loop for that.

617:8-617:16
Mon Oct 27 17:17:00 2014 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f5359ed2_81c404d0
UUID: 35cf3649_12008c6f
Bytes: 243
It's the assert on line 623. debug version will try to verify that an SSA value starting in a hole of an inactive interal won't intersect. Non-debug version will just skip the intersection completely as an optimization due to the SSA property.

676:21-676:28
Fri Oct 24 14:54:56 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f5359ed2_61c920e4
Bytes: 5
ditto

File: compiler/optimizing/register_allocator_test.cc

418:28-418:29
Thu Oct 23 17:41:26 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 7597ee02_217528f7
Bytes: 43
I don't understand the change in this file.

418:28-418:29
Thu Oct 23 23:05:27 2014 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7597ee02_217528f7
UUID: 9592a210_a834bad4
Bytes: 540
The old artificial intervals break this rule:
// Thanks to SSA, a non-split interval starting in a hole of an
// inactive interval should never intersect with that inactive interval.

So I tuned the intervals somewhat to make it work with that rule (add a split). I changed it to non-temp interval since I added an assertion somewhere that temp intervals don't have holes (well, that's my understanding from the code, they have a single range) so they won't be added to inactive set.

So basically I just try to work around some assertions.

File: compiler/optimizing/ssa_liveness_analysis.h

162:23-162:35
Fri Oct 24 14:54:56 2014 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 351e565a_8359c801
Bytes: 134
Maybe change the call sites that use the constructor and make them use this factory method? Then you can make the constructor private.

162:23-162:35
Mon Oct 27 17:17:00 2014 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 351e565a_8359c801
UUID: d5d6dada_2bc2f561
Bytes: 8
Will do.

