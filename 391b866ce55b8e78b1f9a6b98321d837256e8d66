Revision: 391b866ce55b8e78b1f9a6b98321d837256e8d66
Patch-set: 3
File: compiler/optimizing/intrinsics_arm64.cc

893:33-893:45
Fri Dec 18 19:49:12 2015 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 0a2f9f8d_7fa1b764
Bytes: 138
I suspect we're inconsistent about what we generate after a volatile store.  I'm not positive that BarrierReads suffices, but it may well.

1032:27-1032:40
Fri Dec 18 19:08:34 2015 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4a2517a8_b6362eb9
Bytes: 295
Unrelated to this CL, but if this generates a dmb ishst, then I think this is wrong.  It allows a preceding load to be delayed past the stxr.  If the CAS is used to release a lock, then this allows a critical section load to escape from the critical section.

Same problem in the 32 bit version.

1032:27-1032:40
Fri Dec 18 19:49:12 2015 +0000
Author: Hans Boehm <1042828@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4a2517a8_b6362eb9
UUID: ea5fab25_d0fbf42a
Bytes: 496
Hiroshi and I discussed this further.  This indeed seems wrong, and should be fixed asap.  This must say BarrierAll.

The relevant section of the architecture manual is C2.1.8.  A dmb ishst is generated here and that only orders a store followed by a store.  It is not symmetric with dmb ishld, which does order a load followed by either a load or a store.

I currently believe that the trailing fence could be weakened to BarrierReads, which would hopefully make this change performance neutral.

