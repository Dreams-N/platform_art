Revision: cd3385aeedbf257fdde5c1436c784369f66189f0
Patch-set: 1
File: runtime/debugger.cc

3502:20-3502:26
Tue Sep 08 16:05:04 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a4d8763b_a2198046
Bytes: 51
Add a comment why you can just stop the stack walk.

3506:0-3507:18
Tue Sep 08 16:05:04 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a4d8763b_e2138820
Bytes: 149
Can we really enter here? I assume we hit this code when we are in a Quick ManagedFragment, and the upcall check above prevents seeing a ShadowFrame.

3515:0-3515:31
Tue Sep 08 16:05:04 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: e4d42ed5_450c0a7c
Bytes: 81
I don' think so? I believe it should always be true if there was a deopt request?

3554:0-3554:47
Tue Sep 08 16:05:04 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a455d63a_9afcc9e1
Bytes: 127
I guess you could optimize the visit (and avoid false deopt positives) if you start the visit starting from the catch location.

3554:0-3554:47
Wed Sep 09 13:32:20 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a455d63a_9afcc9e1
UUID: e4c34e74_a23684c7
Bytes: 82
The visitor ignores the method == nullptr case anyway, so true param isn't needed?

File: runtime/debugger.h

585:0-585:41
Tue Sep 08 16:05:04 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: c4d56a01_c31e886c
Bytes: 14
4 space indent

File: runtime/quick_exception_handler.h

48:18-48:35
Tue Sep 08 16:05:04 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a4deb6f4_789e955a
Bytes: 53
Why the flag? It's always passed true in this change.

File: runtime/thread.cc

2364:24-2364:29
Tue Sep 08 16:05:04 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a4deb6f4_18a3c9a1
Bytes: 96
Why do you need this? Maybe for simplicity it's better to call FindCatch after the if line 2358?

2364:24-2364:29
Wed Sep 09 13:32:20 2015 +0000
Author: Mingyao Yang <1043514@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a4deb6f4_18a3c9a1
UUID: 24c9e69c_1c9eb922
Bytes: 706
Can we try this? Let the interpreter handle the try-cache. It seems simpler. No need to worry about FindCatch messing up with exceptions. You have to walk the full fragment so can't try the trick that filters out the false positive that Nicolas suggested. But I don't think performance is that important in delivering exception in debugger.
    if (is_deoptimization) {
      exception_handler.DeoptimizeStack();
    } else if (Dbg::IsForcedInterpreterNeededForException(this)) {
      PushDeoptimizationContext(JValue(), false, exception);
      exception_handler.DeoptimizeStack();
      SetException(Thread::GetDeoptimizationException());
    } else {
      exception_handler.FindCatch(exception);
    }

