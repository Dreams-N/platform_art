Revision: ddaa4ee4ae2e735cb50a7790171fd2fa9de5a16c
Patch-set: 3
File: compiler/optimizing/intrinsics_mips.cc

850:58-850:78
Thu Feb 25 17:22:37 2016 +0000
Author: Aart Bik <1074526@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 22d0113b_cc4e3c39
Bytes: 158
The link is good, but would you mind adding a bit of a description in here too?

also, any perf data on how well this compares to e.g. simply a counting loop?

850:58-850:78
Thu Feb 25 19:31:31 2016 +0000
Author: Chris Larsen <1071873@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 22d0113b_cc4e3c39
UUID: a29b218c_e63238d3
Bytes: 1224
New comment:

  // https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel
  //
  // A generalization of the best bit counting method to integers of
  // bit-widths up to 128 (parameterized by type T) is this:
  //
  // v = v - ((v >> 1) & (T)~(T)0/3);                           // temp
  // v = (v & (T)~(T)0/15*3) + ((v >> 2) & (T)~(T)0/15*3);      // temp
  // v = (v + (v >> 4)) & (T)~(T)0/255*15;                      // temp
  // c = (T)(v * ((T)~(T)0/255)) >> (sizeof(T) - 1) * BITS_PER_BYTE; // count
  //
  // For comparison, for 32-bit quantities, this algorithm can be executed
  // using 20 MIPS instructions (the calls to LoadConst32() generate two
  // machine instructions each for the values being used in this algorithm).
  // A(n unrolled) loop based algorithm which was used previously required
  // 25 instructions.
  //
  // For 64-bit quantities, this algorithm gets executed twice, (once
  // for in_lo, and again for in_hi), but saves a few instructions
  // because the mask values only have to be loaded once.  Using this
  // algorithm the count for a 64-bit operand can be performed in 33
  // instructions compared to a loop based algorithm which required 47
  // instructions.

