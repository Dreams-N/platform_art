Revision: edaad91ad7215356320ae98a537845a593ae765c
Patch-set: 1
File: compiler/dex/quick/arm64/utility_arm64.cc

348:6-348:72
Fri Sep 26 22:45:15 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 7069bba1_22a40fa5
Bytes: 161
this seems a little convoluted and leads to a signed/unsigned conversion, prefer:

if (value != INT_MIN) {
  int32_t abs_value = std::abs
  ..
}
return false;

?

812:28-812:29
Fri Sep 26 22:45:15 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 907b8f5f_c946228d
Bytes: 49
&& ?
-LLONG_MIN == LLONG_MIN so why special case?

812:28-812:29
Fri Sep 26 22:53:58 2014 +0000
Author: Bill Buzbee <1001578@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 907b8f5f_c946228d
UUID: 103ddf9e_150113a2
Bytes: 147
My understanding is that although in practice this is the case, negation of LLONG_MIN is technically undefined.  Any language lawyers in the house?

812
Mon Sep 29 11:02:34 2014 +0000
Author: Matteo Franchin <1037505@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 103ddf9e_150113a2
UUID: 10ca3fde_205236f3
Bytes: 434
My understanding is that signed-unsigned conversions are always well defined by the C++ standard (4.7-2, conv.integral). The same holds for negation of unsigned integers (5.3.1-8, expr.unary.op). An alternative could then be,

  uint64_t abs_value = (neg) ? -(uint64_t)value : value;

It may be worth doing this in a separate function (e.g. having a couple of abs functions mapping "int32_t" to "uint32_t" and "int64_t" to "uint64_t".

945:0-945:70
Fri Sep 26 22:45:15 2014 +0000
Author: Ian Rogers <1010118@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d0c347c9_ffc71824
Bytes: 5
ditto

