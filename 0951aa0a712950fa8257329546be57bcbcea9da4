Revision: 0951aa0a712950fa8257329546be57bcbcea9da4
Patch-set: 2
File: compiler/optimizing/code_generator_arm.cc

1819:54-1819:81
Tue Jan 20 10:41:45 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4bc24f1f_96bb12e0
Bytes: 77
Maybe introduce a kOutputOverlap constant in compiler/optimizing/locations.h?

1819:54-1819:81
Tue Jan 20 15:54:00 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4bc24f1f_96bb12e0
UUID: 0b4a1799_a187daa3
Bytes: 108
I find this style in the optimizing compiler rather amusing. Why constants? These should be enums, really...

1819:54-1819:81
Tue Jan 20 18:21:46 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 0b4a1799_a187daa3
UUID: 4bc24f1f_0166fa0c
Bytes: 154
Agreed, these constants should be implemented as an enum.  But my main concern here was to about giving a better name to "!Location::kNoOutputOverlap". :)

1819:54-1819:81
Wed Jan 21 10:53:44 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4bc24f1f_0166fa0c
UUID: 4b408f75_e691f45c
Bytes: 86
Yeah I'm trying to compensate for the lack of named parameters. Added an enum instead.

1819:54-1819:81
Wed Jan 21 11:17:21 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4b408f75_e691f45c
UUID: 4b408f75_46a42899
Bytes: 55
BTW, we should use strongly-typed enums (`enum class').

1896:54-1896:81
Tue Jan 20 10:41:45 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4bc24f1f_b6b88ee3
Bytes: 6
Ditto.

2067:55-2067:61
Tue Jan 20 10:41:45 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4bc24f1f_56a7eac5
Bytes: 54
Does this mean there was also a change in the runtime?

2067:55-2067:61
Tue Jan 20 15:47:56 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4bc24f1f_56a7eac5
UUID: 4bc24f1f_b6816e8f
Bytes: 136
Nope. This was wrong in the first place as I read a bogus table. It worked because we only used the first register to make the transfer.

3311:6-3313:60
Tue Jan 20 15:47:56 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4bc24f1f_36ffbe09
Bytes: 104
quite a lot of repetitions with these DCHECKS. How about a macro, DCHECK_ARM_REGISTER_PAIR(destination)?

3311:6-3313:60
Wed Jan 21 10:53:44 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4bc24f1f_36ffbe09
UUID: 4bc24f1f_6119fee8
Bytes: 23
Yeah, good point. Done.

3324:20-3324:34
Tue Jan 20 15:47:56 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4bc24f1f_d603da7f
Bytes: 247
1) didn't we get rid of register pairs: https://android-review.googlesource.com/#/c/123651/ and assert we don't get one?

Anyway, if this is still needed, add comment to make it clear that arm register pairs are either equal or they don't overlap.

3324:20-3324:34
Wed Jan 21 10:53:44 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4bc24f1f_d603da7f
UUID: 4b408f75_a6108c42
Bytes: 29
Yes, we did. Thanks, removed.

3348:0-3353:9
Tue Jan 20 10:41:45 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: cbd63fdb_5766044b
Bytes: 111
This seems odd to move half a 64-bit value in a 32-bit register.  Shouldn't the destination be a register pair?

3348:0-3353:9
Tue Jan 20 15:47:56 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cbd63fdb_5766044b
UUID: 4b408f75_834f4286
Bytes: 190
This is rather tricky. It's because of the 64-bit constant moves are emitted (it expects the codegen to know which part goes where based on the register). I think extra docs are needed here.

3348:0-3353:9
Wed Jan 21 10:53:44 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4b408f75_834f4286
UUID: 8b0c4779_6f667199
Bytes: 4
Done

3366:0-3366:117
Tue Jan 20 10:41:45 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: cbd63fdb_17707cf7
Bytes: 10
Long line.

3366:0-3366:117
Wed Jan 21 10:53:44 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: cbd63fdb_17707cf7
UUID: 4bc24f1f_a1260622
Bytes: 4
Done

3368:0-3368:118
Tue Jan 20 10:41:45 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4b408f75_a04fd432
Bytes: 10
Long line.

3368:0-3368:118
Wed Jan 21 10:53:44 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4b408f75_a04fd432
UUID: 4b408f75_e61a945e
Bytes: 4
Done

3364:6-3369:9
Tue Jan 20 10:41:45 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4bc24f1f_36a6dec7
Bytes: 73
Likewise, about moving half a 64-bit value into a single 32-bit register.

3364:6-3369:9
Wed Jan 21 10:53:44 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4bc24f1f_36a6dec7
UUID: 4b408f75_4629c876
Bytes: 4
Done

File: compiler/optimizing/nodes.h

2810:8-2811:35
Tue Jan 20 15:47:56 2015 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4b408f75_43a7fac5
Bytes: 50
i'm not sure how will you make this work on x86...

2810:8-2811:35
Wed Jan 21 10:53:44 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4b408f75_43a7fac5
UUID: 8b0c4779_af6fb967
Bytes: 14
Me neither :-)

File: compiler/optimizing/register_allocator.h

135:39-135:53
Tue Jan 20 10:41:45 2015 +0000
Author: Roland Levillain <1052644@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 4b408f75_80c29815
Bytes: 30
"at finding such an interval"?

135:39-135:53
Wed Jan 21 10:53:44 2015 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 4b408f75_80c29815
UUID: 4bc24f1f_61c25ecb
Bytes: 4
Done

