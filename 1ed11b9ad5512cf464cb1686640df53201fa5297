Revision: 1ed11b9ad5512cf464cb1686640df53201fa5297
Patch-set: 2
File: runtime/gc/allocation_record.cc

97:5-97:74
Tue Jun 23 17:39:40 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 7e0fe678_23aacade
Bytes: 299
Does this mean that some of the entries_ are strong GC roots and others are weak GC roots and that the strong/weak boundary changes dynamically (as we add more alloc records), correct? 
Maybe leave a comment about this where entries_ is declared?

And I assume that works in terms of GC correctness.

97:5-97:74
Wed Jun 24 21:31:42 2015 +0000
Author: Man Cao <1073545@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 7e0fe678_23aacade
UUID: 5e0f82b1_5e69d51b
Bytes: 23
Addressed in CL 156415.

File: runtime/runtime.cc

1484:5-1484:23
Tue Jun 23 17:39:40 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: de1a92b3_6f8dc187
Bytes: 292
Side note: I guess another reason it's safe for now is that we only read those GcRoots in AllocRecordObjectMap during a pause for hprof dumping (no read barrier triggers for those GcRoots). Thus, we don't need to temporarily disable new alloc records here for concurrent reference processing.

1484:5-1484:23
Wed Jun 24 21:31:42 2015 +0000
Author: Man Cao <1073545@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: de1a92b3_6f8dc187
UUID: befddec1_f9b53f21
Bytes: 29
Fixed this TODO in CL 156415.

