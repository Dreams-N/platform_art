Revision: a3bb21a29f852a748af1b48763cca321a7b3ab26
Patch-set: 4
File: compiler/driver/compiler_driver.cc

100:0-164:2
Wed Jun 15 14:27:54 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 346221c1_d7795ce3
Bytes: 53
Personally, I would have been happy with three bools.

100:0-164:2
Thu Jun 16 11:21:23 2016 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 346221c1_d7795ce3
UUID: 346221c1_f779006a
Bytes: 21
Seems a bit overkill.

100:0-164:2
Thu Jun 16 11:54:49 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 346221c1_f779006a
UUID: 743659c9_c941b146
Bytes: 72
10 parameters for CompileMethod() are bad enough. Why would you want 12?

100:0-164:2
Thu Jun 16 13:28:12 2016 +0000
Author: Nicolas Geoffray <1038443@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 743659c9_c941b146
UUID: 346221c1_57f8ecb9
Bytes: 99
3 bools in that class. You can keep EnabledCompilers, I agree 10 parameters are pretty bad already.

663:7-663:29
Thu Jun 16 11:21:23 2016 +0000
Author: Calin Juravle <1022077@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 346221c1_57b70c3b
Bytes: 75
I know that this is copy paste, but why is the extract only reference here?

663:7-663:29
Thu Jun 16 11:54:49 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 346221c1_57b70c3b
UUID: b49451c2_5ba663d6
Bytes: 99
For extract-only (i.e. kVerifyAtRuntime) we prefer not to compile anything, not even the JNI stubs.

File: compiler/driver/compiler_driver.h

697:14-697:61
Wed Jun 15 15:23:44 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 145fddcc_e9579112
Bytes: 40
Could you explain what you mean by this?

697:14-697:61
Thu Jun 16 09:40:12 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 145fddcc_e9579112
UUID: 747f394d_cac9b716
Bytes: 450
A class SHALL NOT be defined twice in a dex file. Class definition's items SHALL refer to field and method ids with class_idx_ of that class.

Given that we shard on class definitions, this is enough; however, we would be fine even if sharding on method definitions because we also forbid unordered method definitions in a class def, filter out duplicates within "direct" and "virtual" and forbid the same method index in both "direct" and "virtual".

697:14-697:61
Thu Jun 16 15:07:56 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 747f394d_cac9b716
UUID: 540315bf_441c8bba
Bytes: 232
Thanks.

Now since you touch the whole setup: which part of the spec forbids using the same data offset for two separate methods? What's the argument that we're fine running the dex-to-dex compiler in parallel (I believe we are OK)?

697:14-697:61
Thu Jun 16 15:21:43 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 540315bf_441c8bba
UUID: 346221c1_daa8a18e
Bytes: 152
Hmm, that's an interesting question. Why do you think we are OK?
(If two threads try to quicken the same dex instruction, it can produce wrong results.)

697:14-697:61
Thu Jun 16 15:30:04 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 346221c1_daa8a18e
UUID: 540315bf_447beba7
Bytes: 489
My best guess: Because Quickening works over symbols that include a class name.

Then for it to be resolvable, the receiver (either this or a parameter/field value) must be a subclass of the symbol's class, which means the layout of it is fixed.

So even though we have a race, we should be writing the same value.


Now what I think *may* be wrong (but isn't a race): if the code is OK for one class, but not another. Then quickening may or may not screw up the access-checks interpreter.

697:14-697:61
Thu Jun 16 15:31:25 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 540315bf_447beba7
UUID: 540315bf_848503b6
Bytes: 248
Of course that reasoning is half-assed, thinking about it. No reason for "overlap" to start at the same offset, so "seeing" the same instructions. :-(

Maybe we should tighten the spec, or give a signal from the dex file verifier to punt compiling.

697:14-697:61
Thu Jun 16 17:04:57 2016 +0000
Author: Vladimir Marko <1018108@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 540315bf_848503b6
UUID: 346221c1_ba012d68
Bytes: 229
There is no reason why two methods cannot share the same code_item, right? (The code item does not need to reference the declaring class in any way.) And trying to quicken the same code_item from two different threads shall race.

697:14-697:61
Thu Jun 16 17:37:03 2016 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 346221c1_ba012d68
UUID: 540315bf_adb0eba2
Bytes: 231
My argument was that yes it's a race, but it should quicken to the same index, if it quickens.

(That's for the case that it's the exact code-item. The spec doesn't say [at least that I could find] that code-items may not overlap.)

