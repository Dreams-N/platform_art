Revision: 860a2da1cc8aadeb428ab311ce9231d48b4aec58
Patch-set: 1
File: runtime/gc/allocator/rosalloc.cc

1666:0-1668:43
Sat Apr 25 00:35:58 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d0d99e70_1106ae4d
Bytes: 195
This seems too much of a hardcoding to the existing uses cases and MarkSweep and not necessarily true in the future. I find this error-prone and not a good design from a modularity point of view.

1666:0-1668:43
Sat Apr 25 09:44:28 2015 +0000
Author: Lei Li <1015518@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d0d99e70_1106ae4d
UUID: d0027e8c_8675ca78
Bytes: 782
Actually, this is right for good modularity. The revoke function is just doing the revoke work itself. If lock is required (bulk_free_lock_ currently or whatever in the future), then use the standalone wrapper is better to understand and also consider the future's design. It's something like WaitForGcToComplete and WaitForGcToCompleteLocked in heap.cc. 
In addition, personally it may be not good design to make the revoke work and reclaim work (no matter whatever garbage collector) concurrent, because both will update run metadata, including thread local or not and run bitmaps. If they are concurrent, then the synchronization overhead is improved accordingly. It doesn't seem to bring any side effect to make the revoke work and reclaim work sequential in my opinion. Thanks.

1690:0-1691:52
Sat Apr 25 00:35:58 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: b0d42a38_907bba3c
Bytes: 388
I believe this move violates the existing locking conventions.

It's unfortunate that we don't have more thread safety annotations.

There may be *some* unnecessary locking in certain cases, but I'd rather follow the basic/static locking conventions unless there's a strong reason not to. 

Otherwise, we'd end up with a locking/thread safety mess, which makes reasoning/maintenance hard.

1690:0-1691:52
Sat Apr 25 09:44:28 2015 +0000
Author: Lei Li <1015518@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: b0d42a38_907bba3c
UUID: f00b02a7_87d14601
Bytes: 425
My personal understanding is that with thread local runs introduced, ensure that the synchronization is reduced significantly and finally boost allocate rate which is what we spent lots of effort pursuing. Yes. I totally agree with you to follow the unified and consistent locking conventions for both scalability and maintenance. For example, RevokeRun and RefillRun may be required to add thread safety annotations. Thanks.

1754:0-1756:65
Sat Apr 25 00:35:58 2015 +0000
Author: Hiroshi Yamauchi <1022530@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: d0d99e70_7158525b
Bytes: 124
Similarly, this is too much of a hardcoding to the existing uses cases and MarkSweep and not necessarily true in the future.

1754:0-1756:65
Sat Apr 25 09:44:28 2015 +0000
Author: Lei Li <1015518@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: d0d99e70_7158525b
UUID: d0027e8c_2619762d
Bytes: 254
Hi Yamauchi, thanks for your comments. My personal opinion is that the error is what we really want to expose here if any. The thread local run is lock free. The thread is about to exit. There is no thread local runs for this thread at this step. Thanks.

File: runtime/gc/allocator/rosalloc.h

621:2-622:53
Fri Apr 24 15:39:58 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 10a416b9_ec9fcf33
Bytes: 24
Why no lock annotations?

File: runtime/thread.cc

1271:4-1272:72
Fri Apr 24 15:41:31 2015 +0000
Author: Andreas Gampe <1041833@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 309d9a70_28b0e86b
Bytes: 25
That's a horrible design.

1271:4-1272:72
Sat Apr 25 09:44:28 2015 +0000
Author: Lei Li <1015518@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 309d9a70_28b0e86b
UUID: d0027e8c_867a6a6f
Bytes: 68
Sorry. I made a mistake. The first revoke should be removed. Thanks.

